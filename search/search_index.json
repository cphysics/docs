{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Computational Physics Computational physics is the study and implementation of numerical analysis to solve problems in physics for which a quantitative theory already exists. Historically, computational physics was the first application of modern computers in science, and is now a subset of computational science. In this Online document we will discuss from getting started with Python to Numerical Methods, Fractals and Chaos, Monte Carlo Simulation, Path Integral method, Signal Processing, Partial Differential Equations, Network and Complex System, Neural Networks, Nature Inspired Computing, Parallel and Distributed Computing, Blockchain, Quantum Computing.","title":"Home"},{"location":"#computational-physics","text":"Computational physics is the study and implementation of numerical analysis to solve problems in physics for which a quantitative theory already exists. Historically, computational physics was the first application of modern computers in science, and is now a subset of computational science. In this Online document we will discuss from getting started with Python to Numerical Methods, Fractals and Chaos, Monte Carlo Simulation, Path Integral method, Signal Processing, Partial Differential Equations, Network and Complex System, Neural Networks, Nature Inspired Computing, Parallel and Distributed Computing, Blockchain, Quantum Computing.","title":"Computational Physics"},{"location":"References/","text":"References Mkdocs Deploy MkDocs MkDoc Black and Blue Codehilit Syntax highlight all Syntax highlight code","title":"References"},{"location":"References/#references","text":"","title":"References"},{"location":"References/#mkdocs","text":"Deploy MkDocs MkDoc Black and Blue Codehilit Syntax highlight all Syntax highlight code","title":"Mkdocs"},{"location":"WhyComputationalPhysics/","text":"Why Computational physics Under Construction","title":"Why Computational Physics"},{"location":"WhyComputationalPhysics/#why-computational-physics","text":"Under Construction","title":"Why Computational physics"},{"location":"Montecarlo/BEC/bec/","text":"Bose Einstein Condensation Permutation Sample % matplotlib inline import random N = 3 statistics = {} L = range (N) nsteps = 10 for step in range (nsteps): i = random . randint( 0 , N - 1 ) j = random . randint( 0 , N - 1 ) L[i], L[j] = L[j], L[i] if tuple (L) in statistics: statistics[ tuple (L)] += 1 else : statistics[ tuple (L)] = 1 print L print range (N) print for item in statistics: print item, statistics[item] [2, 1, 0] [0, 1, 2] [1, 2, 0] [0, 1, 2] [0, 2, 1] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [2, 1, 0] [0, 1, 2] [2, 0, 1] [0, 1, 2] [2, 1, 0] [0, 1, 2] [2, 1, 0] [0, 1, 2] (0, 1, 2) 3 (1, 2, 0) 1 (2, 1, 0) 4 (0, 2, 1) 1 (2, 0, 1) 1 Marcov Harmonic Boson import random , math def levy_harmonic_path (k, beta): xk = tuple ([random . gauss( 0.0 , 1.0 / math . sqrt( 2.0 * math . tanh(k * beta / 2.0 ))) for d in range ( 3 )]) x = [xk] for j in range ( 1 , k): Upsilon_1 = ( 1.0 / math . tanh(beta) + 1.0 / math . tanh((k - j) * beta)) Upsilon_2 = [x[j - 1 ][d] / math . sinh(beta) + xk[d] / math . sinh((k - j) * beta) for d in range ( 3 )] x_mean = [Upsilon_2[d] / Upsilon_1 for d in range ( 3 )] sigma = 1.0 / math . sqrt(Upsilon_1) dummy = [random . gauss(x_mean[d], sigma) for d in range ( 3 )] x . append( tuple (dummy)) return x def rho_harm (x, xp, beta): Upsilon_1 = sum ((x[d] + xp[d]) ** 2 / 4.0 * math . tanh(beta / 2.0 ) for d in range ( 3 )) Upsilon_2 = sum ((x[d] - xp[d]) ** 2 / 4.0 / math . tanh(beta / 2.0 ) for d in range ( 3 )) return math . exp( - Upsilon_1 - Upsilon_2) N = 128 T_star = 0.9 beta = 1.0 / (T_star * N ** ( 1.0 / 3.0 )) nsteps = 1000 positions = {} for j in range (N): a = levy_harmonic_path( 1 , beta) positions[a[ 0 ]] = a[ 0 ] for step in range (nsteps): boson_a = random . choice(positions . keys()) perm_cycle = [] while True : perm_cycle . append(boson_a) boson_b = positions . pop(boson_a) if boson_b == perm_cycle[ 0 ]: break else : boson_a = boson_b k = len (perm_cycle) perm_cycle = levy_harmonic_path(k, beta) positions[perm_cycle[ - 1 ]] = perm_cycle[ 0 ] for j in range ( len (perm_cycle) - 1 ): positions[perm_cycle[j]] = perm_cycle[j + 1 ] a_1 = random . choice(positions . keys()) b_1 = positions . pop(a_1) a_2 = random . choice(positions . keys()) b_2 = positions . pop(a_2) weight_new = rho_harm(a_1, b_2, beta) * rho_harm(a_2, b_1, beta) weight_old = rho_harm(a_1, b_1, beta) * rho_harm(a_2, b_2, beta) if random . uniform( 0.0 , 1.0 ) < weight_new / weight_old: positions[a_1] = b_2 positions[a_2] = b_1 else : positions[a_1] = b_1 positions[a_2] = b_2 Marcov Harmonic Boson Movie import random , math , pylab , mpl_toolkits.mplot3d def levy_harmonic_path (k, beta): xk = tuple ([random . gauss( 0.0 , 1.0 / math . sqrt( 2.0 * math . tanh(k * beta / 2.0 ))) for d in range ( 3 )]) x = [xk] for j in range ( 1 , k): Upsilon_1 = ( 1.0 / math . tanh(beta) + 1.0 / math . tanh((k - j) * beta)) Upsilon_2 = [x[j - 1 ][d] / math . sinh(beta) + xk[d] / math . sinh((k - j) * beta) for d in range ( 3 )] x_mean = [Upsilon_2[d] / Upsilon_1 for d in range ( 3 )] sigma = 1.0 / math . sqrt(Upsilon_1) dummy = [random . gauss(x_mean[d], sigma) for d in range ( 3 )] x . append( tuple (dummy)) return x def rho_harm (x, xp, beta): Upsilon_1 = sum ((x[d] + xp[d]) ** 2 / 4.0 * math . tanh(beta / 2.0 ) for d in range ( 3 )) Upsilon_2 = sum ((x[d] - xp[d]) ** 2 / 4.0 / math . tanh(beta / 2.0 ) for d in range ( 3 )) return math . exp( - Upsilon_1 - Upsilon_2) N = 256 T_star = 0.6 beta = 1.0 / (T_star * N ** ( 1.0 / 3.0 )) nsteps = 1000 positions = {} for j in range (N): a = levy_harmonic_path( 1 , beta) positions[a[ 0 ]] = a[ 0 ] for step in range (nsteps): boson_a = random . choice(positions . keys()) perm_cycle = [] while True : perm_cycle . append(boson_a) boson_b = positions . pop(boson_a) if boson_b == perm_cycle[ 0 ]: break else : boson_a = boson_b k = len (perm_cycle) perm_cycle = levy_harmonic_path(k, beta) positions[perm_cycle[ - 1 ]] = perm_cycle[ 0 ] for j in range ( len (perm_cycle) - 1 ): positions[perm_cycle[j]] = perm_cycle[j + 1 ] a_1 = random . choice(positions . keys()) b_1 = positions . pop(a_1) a_2 = random . choice(positions . keys()) b_2 = positions . pop(a_2) weight_new = rho_harm(a_1, b_2, beta) * rho_harm(a_2, b_1, beta) weight_old = rho_harm(a_1, b_1, beta) * rho_harm(a_2, b_2, beta) if random . uniform( 0.0 , 1.0 ) < weight_new / weight_old: positions[a_1] = b_2 positions[a_2] = b_1 else : positions[a_1] = b_1 positions[a_2] = b_2 fig = pylab . figure() ax = mpl_toolkits . mplot3d . axes3d . Axes3D(fig) ax . set_aspect( 'equal' ) list_colors = [ 'b' , 'g' , 'r' , 'c' , 'm' , 'y' , 'k' ] n_colors = len (list_colors) dict_colors = {} i_color = 0 # find and plot permutation cycles: while positions: x, y, z = [], [], [] starting_boson = positions . keys()[ 0 ] boson_old = starting_boson while True : x . append(boson_old[ 0 ]) y . append(boson_old[ 1 ]) z . append(boson_old[ 2 ]) boson_new = positions . pop(boson_old) if boson_new == starting_boson: break else : boson_old = boson_new len_cycle = len (x) if len_cycle > 2 : x . append(x[ 0 ]) y . append(y[ 0 ]) z . append(z[ 0 ]) if len_cycle in dict_colors: color = dict_colors[len_cycle] ax . plot(x, y, z, color + '+-' , lw = 0.75 ) else : color = list_colors[i_color] i_color = (i_color + 1 ) % n_colors dict_colors[len_cycle] = color ax . plot(x, y, z, color + '+-' , label = 'k= %i ' % len_cycle, lw = 0.75 ) # finalize plot pylab . title( '$N= %i $, $T^*= %s $' % (N, T_star)) pylab . legend() ax . set_xlabel( '$x$' , fontsize = 16 ) ax . set_ylabel( '$y$' , fontsize = 16 ) ax . set_zlabel( '$z$' , fontsize = 16 ) ax . set_xlim3d([ - 8 , 8 ]) ax . set_ylim3d([ - 8 , 8 ]) ax . set_zlim3d([ - 8 , 8 ]) #pylab.savefig('snapshot_bosons_3d_N%04i_Tstar%04.2f.png' % (N, T_star)) pylab . show() TUTORIAL Permutation Sample Cycle import random N = 20 stats = [ 0 ] * (N + 1 ) L = range (N) nsteps = 100 for step in range (nsteps): i = random . randint( 0 , N - 1 ) j = random . randint( 0 , N - 1 ) L[i], L[j] = L[j], L[i] if step % 100 == 0 : cycle_dict = {} for k in range (N): cycle_dict[k] = L[k] while cycle_dict != {}: starting_element = cycle_dict . keys()[ 0 ] cycle_length = 0 old_element = starting_element while True : cycle_length += 1 new_element = cycle_dict . pop(old_element) if new_element == starting_element: break else : old_element = new_element stats[cycle_length] += 1 for k in range ( 1 , N + 1 ): print k, stats[k] 1 18 2 1 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 18 0 19 0 20 0 Direct Harmonic Boson import math , random def z (k, beta): return ( 1.0 - math . exp( - k * beta)) ** ( - 3 ) def canonic_recursion (N, beta): Z = [ 1.0 ] for M in range ( 1 , N + 1 ): Z . append( sum (Z[k] * z(M - k, beta) \\ for k in range (M)) / M) return Z def make_pi_list (Z, M): pi_list = [ 0.0 ] + [z(k, beta) * Z[M - k] / Z[M] / M \\ for k in range ( 1 , M + 1 )] pi_cumulative = [ 0.0 ] for k in range ( 1 , M + 1 ): pi_cumulative . append(pi_cumulative[k - 1 ] + pi_list[k]) return pi_cumulative def naive_tower_sample (pi_cumulative): eta = random . uniform( 0.0 , 1.0 ) for k in range ( len (pi_cumulative)): if eta < pi_cumulative[k]: break return k def levy_harmonic_path (dtau, N): beta = N * dtau x_N = random . gauss( 0.0 , 1.0 / math . sqrt( 2.0 * math . tanh(beta / 2.0 ))) x = [x_N] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Upsilon_1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Upsilon_2 = x[k - 1 ] / math . sinh(dtau) + \\ x_N / math . sinh(dtau_prime) x_mean = Upsilon_2 / Upsilon_1 sigma = 1.0 / math . sqrt(Upsilon_1) x . append(random . gauss(x_mean, sigma)) return x ### main program starts here ### N = 8 T_star = 0.1 beta = 1.0 / N ** ( 1.0 / 3.0 ) / T_star n_steps = 1000 Z = canonic_recursion(N, beta) for step in range (n_steps): N_tmp = N x_config = [] y_config = [] z_config = [] while N_tmp > 0 : pi_sum = make_pi_list(Z, N_tmp) k = naive_tower_sample(pi_sum) x_config += levy_harmonic_path(beta, k) y_config += levy_harmonic_path(beta, k) z_config += levy_harmonic_path(beta, k) N_tmp -= k Canonic Harmonic Recursion import math def z (k, beta): return 1.0 / ( 1.0 - math . exp( - k * beta)) ** 3 def canonic_recursion (N, beta): Z = [ 1.0 ] for M in range ( 1 , N + 1 ): Z . append( sum (Z[k] * z(M - k, beta) \\ for k in range (M)) / M) return Z N = 100 beta = 1.0 Z = canonic_recursion(N, beta) print N, Z[ - 1 ] 100 27.328822346 Canonic Recurrsion Movie import math , pylab def z (k, beta): return 1.0 / ( 1.0 - math . exp( - k * beta)) ** 3 def canonic_recursion (N, beta): Z = [ 1.0 ] for M in range ( 1 , N + 1 ): Z . append( sum (Z[k] * z(M - k, beta) \\ for k in range (M)) / M) return Z N = 256 T_star = 0.6 beta = 1.0 / N ** ( 1.0 / 3.0 ) / T_star Z = canonic_recursion(N, beta) pi_k = [(z(k, beta) * Z[N - k] / Z[ - 1 ]) / float (N) for k in range ( 1 , N + 1 )] # graphics output pylab . plot( range ( 1 , N + 1 ), pi_k, 'b-' , lw = 2.5 ) pylab . ylim( 0.0 , 0.01 ) pylab . xlabel( 'cycle length $k$' , fontsize = 16 ) pylab . ylabel( 'cycle probability $\\pi_k$' , fontsize = 16 ) pylab . title( 'Cycle length distribution ($N= %i $, $T^*= %s $)' % (N, T_star), fontsize = 16 ) #pylab.savefig('plot-prob_cycle_length.png') pylab . show()","title":"Bose-Einstein Condensation"},{"location":"Montecarlo/BEC/bec/#bose-einstein-condensation","text":"Permutation Sample % matplotlib inline import random N = 3 statistics = {} L = range (N) nsteps = 10 for step in range (nsteps): i = random . randint( 0 , N - 1 ) j = random . randint( 0 , N - 1 ) L[i], L[j] = L[j], L[i] if tuple (L) in statistics: statistics[ tuple (L)] += 1 else : statistics[ tuple (L)] = 1 print L print range (N) print for item in statistics: print item, statistics[item] [2, 1, 0] [0, 1, 2] [1, 2, 0] [0, 1, 2] [0, 2, 1] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [2, 1, 0] [0, 1, 2] [2, 0, 1] [0, 1, 2] [2, 1, 0] [0, 1, 2] [2, 1, 0] [0, 1, 2] (0, 1, 2) 3 (1, 2, 0) 1 (2, 1, 0) 4 (0, 2, 1) 1 (2, 0, 1) 1 Marcov Harmonic Boson import random , math def levy_harmonic_path (k, beta): xk = tuple ([random . gauss( 0.0 , 1.0 / math . sqrt( 2.0 * math . tanh(k * beta / 2.0 ))) for d in range ( 3 )]) x = [xk] for j in range ( 1 , k): Upsilon_1 = ( 1.0 / math . tanh(beta) + 1.0 / math . tanh((k - j) * beta)) Upsilon_2 = [x[j - 1 ][d] / math . sinh(beta) + xk[d] / math . sinh((k - j) * beta) for d in range ( 3 )] x_mean = [Upsilon_2[d] / Upsilon_1 for d in range ( 3 )] sigma = 1.0 / math . sqrt(Upsilon_1) dummy = [random . gauss(x_mean[d], sigma) for d in range ( 3 )] x . append( tuple (dummy)) return x def rho_harm (x, xp, beta): Upsilon_1 = sum ((x[d] + xp[d]) ** 2 / 4.0 * math . tanh(beta / 2.0 ) for d in range ( 3 )) Upsilon_2 = sum ((x[d] - xp[d]) ** 2 / 4.0 / math . tanh(beta / 2.0 ) for d in range ( 3 )) return math . exp( - Upsilon_1 - Upsilon_2) N = 128 T_star = 0.9 beta = 1.0 / (T_star * N ** ( 1.0 / 3.0 )) nsteps = 1000 positions = {} for j in range (N): a = levy_harmonic_path( 1 , beta) positions[a[ 0 ]] = a[ 0 ] for step in range (nsteps): boson_a = random . choice(positions . keys()) perm_cycle = [] while True : perm_cycle . append(boson_a) boson_b = positions . pop(boson_a) if boson_b == perm_cycle[ 0 ]: break else : boson_a = boson_b k = len (perm_cycle) perm_cycle = levy_harmonic_path(k, beta) positions[perm_cycle[ - 1 ]] = perm_cycle[ 0 ] for j in range ( len (perm_cycle) - 1 ): positions[perm_cycle[j]] = perm_cycle[j + 1 ] a_1 = random . choice(positions . keys()) b_1 = positions . pop(a_1) a_2 = random . choice(positions . keys()) b_2 = positions . pop(a_2) weight_new = rho_harm(a_1, b_2, beta) * rho_harm(a_2, b_1, beta) weight_old = rho_harm(a_1, b_1, beta) * rho_harm(a_2, b_2, beta) if random . uniform( 0.0 , 1.0 ) < weight_new / weight_old: positions[a_1] = b_2 positions[a_2] = b_1 else : positions[a_1] = b_1 positions[a_2] = b_2 Marcov Harmonic Boson Movie import random , math , pylab , mpl_toolkits.mplot3d def levy_harmonic_path (k, beta): xk = tuple ([random . gauss( 0.0 , 1.0 / math . sqrt( 2.0 * math . tanh(k * beta / 2.0 ))) for d in range ( 3 )]) x = [xk] for j in range ( 1 , k): Upsilon_1 = ( 1.0 / math . tanh(beta) + 1.0 / math . tanh((k - j) * beta)) Upsilon_2 = [x[j - 1 ][d] / math . sinh(beta) + xk[d] / math . sinh((k - j) * beta) for d in range ( 3 )] x_mean = [Upsilon_2[d] / Upsilon_1 for d in range ( 3 )] sigma = 1.0 / math . sqrt(Upsilon_1) dummy = [random . gauss(x_mean[d], sigma) for d in range ( 3 )] x . append( tuple (dummy)) return x def rho_harm (x, xp, beta): Upsilon_1 = sum ((x[d] + xp[d]) ** 2 / 4.0 * math . tanh(beta / 2.0 ) for d in range ( 3 )) Upsilon_2 = sum ((x[d] - xp[d]) ** 2 / 4.0 / math . tanh(beta / 2.0 ) for d in range ( 3 )) return math . exp( - Upsilon_1 - Upsilon_2) N = 256 T_star = 0.6 beta = 1.0 / (T_star * N ** ( 1.0 / 3.0 )) nsteps = 1000 positions = {} for j in range (N): a = levy_harmonic_path( 1 , beta) positions[a[ 0 ]] = a[ 0 ] for step in range (nsteps): boson_a = random . choice(positions . keys()) perm_cycle = [] while True : perm_cycle . append(boson_a) boson_b = positions . pop(boson_a) if boson_b == perm_cycle[ 0 ]: break else : boson_a = boson_b k = len (perm_cycle) perm_cycle = levy_harmonic_path(k, beta) positions[perm_cycle[ - 1 ]] = perm_cycle[ 0 ] for j in range ( len (perm_cycle) - 1 ): positions[perm_cycle[j]] = perm_cycle[j + 1 ] a_1 = random . choice(positions . keys()) b_1 = positions . pop(a_1) a_2 = random . choice(positions . keys()) b_2 = positions . pop(a_2) weight_new = rho_harm(a_1, b_2, beta) * rho_harm(a_2, b_1, beta) weight_old = rho_harm(a_1, b_1, beta) * rho_harm(a_2, b_2, beta) if random . uniform( 0.0 , 1.0 ) < weight_new / weight_old: positions[a_1] = b_2 positions[a_2] = b_1 else : positions[a_1] = b_1 positions[a_2] = b_2 fig = pylab . figure() ax = mpl_toolkits . mplot3d . axes3d . Axes3D(fig) ax . set_aspect( 'equal' ) list_colors = [ 'b' , 'g' , 'r' , 'c' , 'm' , 'y' , 'k' ] n_colors = len (list_colors) dict_colors = {} i_color = 0 # find and plot permutation cycles: while positions: x, y, z = [], [], [] starting_boson = positions . keys()[ 0 ] boson_old = starting_boson while True : x . append(boson_old[ 0 ]) y . append(boson_old[ 1 ]) z . append(boson_old[ 2 ]) boson_new = positions . pop(boson_old) if boson_new == starting_boson: break else : boson_old = boson_new len_cycle = len (x) if len_cycle > 2 : x . append(x[ 0 ]) y . append(y[ 0 ]) z . append(z[ 0 ]) if len_cycle in dict_colors: color = dict_colors[len_cycle] ax . plot(x, y, z, color + '+-' , lw = 0.75 ) else : color = list_colors[i_color] i_color = (i_color + 1 ) % n_colors dict_colors[len_cycle] = color ax . plot(x, y, z, color + '+-' , label = 'k= %i ' % len_cycle, lw = 0.75 ) # finalize plot pylab . title( '$N= %i $, $T^*= %s $' % (N, T_star)) pylab . legend() ax . set_xlabel( '$x$' , fontsize = 16 ) ax . set_ylabel( '$y$' , fontsize = 16 ) ax . set_zlabel( '$z$' , fontsize = 16 ) ax . set_xlim3d([ - 8 , 8 ]) ax . set_ylim3d([ - 8 , 8 ]) ax . set_zlim3d([ - 8 , 8 ]) #pylab.savefig('snapshot_bosons_3d_N%04i_Tstar%04.2f.png' % (N, T_star)) pylab . show()","title":"Bose Einstein Condensation"},{"location":"Montecarlo/BEC/bec/#tutorial","text":"Permutation Sample Cycle import random N = 20 stats = [ 0 ] * (N + 1 ) L = range (N) nsteps = 100 for step in range (nsteps): i = random . randint( 0 , N - 1 ) j = random . randint( 0 , N - 1 ) L[i], L[j] = L[j], L[i] if step % 100 == 0 : cycle_dict = {} for k in range (N): cycle_dict[k] = L[k] while cycle_dict != {}: starting_element = cycle_dict . keys()[ 0 ] cycle_length = 0 old_element = starting_element while True : cycle_length += 1 new_element = cycle_dict . pop(old_element) if new_element == starting_element: break else : old_element = new_element stats[cycle_length] += 1 for k in range ( 1 , N + 1 ): print k, stats[k] 1 18 2 1 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 18 0 19 0 20 0 Direct Harmonic Boson import math , random def z (k, beta): return ( 1.0 - math . exp( - k * beta)) ** ( - 3 ) def canonic_recursion (N, beta): Z = [ 1.0 ] for M in range ( 1 , N + 1 ): Z . append( sum (Z[k] * z(M - k, beta) \\ for k in range (M)) / M) return Z def make_pi_list (Z, M): pi_list = [ 0.0 ] + [z(k, beta) * Z[M - k] / Z[M] / M \\ for k in range ( 1 , M + 1 )] pi_cumulative = [ 0.0 ] for k in range ( 1 , M + 1 ): pi_cumulative . append(pi_cumulative[k - 1 ] + pi_list[k]) return pi_cumulative def naive_tower_sample (pi_cumulative): eta = random . uniform( 0.0 , 1.0 ) for k in range ( len (pi_cumulative)): if eta < pi_cumulative[k]: break return k def levy_harmonic_path (dtau, N): beta = N * dtau x_N = random . gauss( 0.0 , 1.0 / math . sqrt( 2.0 * math . tanh(beta / 2.0 ))) x = [x_N] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Upsilon_1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Upsilon_2 = x[k - 1 ] / math . sinh(dtau) + \\ x_N / math . sinh(dtau_prime) x_mean = Upsilon_2 / Upsilon_1 sigma = 1.0 / math . sqrt(Upsilon_1) x . append(random . gauss(x_mean, sigma)) return x ### main program starts here ### N = 8 T_star = 0.1 beta = 1.0 / N ** ( 1.0 / 3.0 ) / T_star n_steps = 1000 Z = canonic_recursion(N, beta) for step in range (n_steps): N_tmp = N x_config = [] y_config = [] z_config = [] while N_tmp > 0 : pi_sum = make_pi_list(Z, N_tmp) k = naive_tower_sample(pi_sum) x_config += levy_harmonic_path(beta, k) y_config += levy_harmonic_path(beta, k) z_config += levy_harmonic_path(beta, k) N_tmp -= k Canonic Harmonic Recursion import math def z (k, beta): return 1.0 / ( 1.0 - math . exp( - k * beta)) ** 3 def canonic_recursion (N, beta): Z = [ 1.0 ] for M in range ( 1 , N + 1 ): Z . append( sum (Z[k] * z(M - k, beta) \\ for k in range (M)) / M) return Z N = 100 beta = 1.0 Z = canonic_recursion(N, beta) print N, Z[ - 1 ] 100 27.328822346 Canonic Recurrsion Movie import math , pylab def z (k, beta): return 1.0 / ( 1.0 - math . exp( - k * beta)) ** 3 def canonic_recursion (N, beta): Z = [ 1.0 ] for M in range ( 1 , N + 1 ): Z . append( sum (Z[k] * z(M - k, beta) \\ for k in range (M)) / M) return Z N = 256 T_star = 0.6 beta = 1.0 / N ** ( 1.0 / 3.0 ) / T_star Z = canonic_recursion(N, beta) pi_k = [(z(k, beta) * Z[N - k] / Z[ - 1 ]) / float (N) for k in range ( 1 , N + 1 )] # graphics output pylab . plot( range ( 1 , N + 1 ), pi_k, 'b-' , lw = 2.5 ) pylab . ylim( 0.0 , 0.01 ) pylab . xlabel( 'cycle length $k$' , fontsize = 16 ) pylab . ylabel( 'cycle probability $\\pi_k$' , fontsize = 16 ) pylab . title( 'Cycle length distribution ($N= %i $, $T^*= %s $)' % (N, T_star), fontsize = 16 ) #pylab.savefig('plot-prob_cycle_length.png') pylab . show()","title":"TUTORIAL"},{"location":"Montecarlo/GettingStarted/intro/","text":"Introduction to Montecarlo Method In this notebook, we will calculate value of pi by implementation of Monte Carlo Simulation import random import matplotlib.pyplot as plt import numpy as np import pylab import seaborn as sns sns . set() % matplotlib inline Lets calculate the value of PI directly: In this method we randomly generate the points and calculate the ratio for value of PI. n_trials = 10000 n_hits = 0 plt . figure(figsize = [ 10 , 10 ]) for iter in range (n_trials): x = random . uniform( - 1.0 , 1.0 ) y = random . uniform( - 1.0 , 1.0 ) if x ** 2 + y ** 2 < 1.0 : plt . scatter(x,y,color = \"blue\" ,marker = '.' ) n_hits += 1 else : plt . scatter(x,y,color = \"red\" ,marker = '.' ) print ( 4.0 * n_hits / float (n_trials)) 3.174 Lets construct the function to run above code multiple time def direct_pi (N): n_hits = 0 for i in range (N): x = random . uniform( - 1.0 , 1.0 ) y = random . uniform( - 1.0 , 1.0 ) if x ** 2 + y ** 2 < 1.0 : n_hits += 1 computed_pi = 4.0 * n_hits / float (n_trials) return computed_pi n_runs = 100 n_trials = 1000 plt . figure(figsize = [ 12 , 3 ]) for run in range (n_runs): pi = direct_pi(n_trials) plt . scatter(run,pi) plt . ylim([ 0 , 4.0 ]) plt . xlabel( \"No of Run\" ) plt . ylabel( \"Value of Pi\" ) plt . show() Marcob chain Calculation of PI: In this method we perform a random walk and accept or reject the move. x, y = 1.0 , 1.0 delta = 0.1 n_trials = 5000 n_hits = 0 plt . figure(figsize = [ 10 , 10 ]) for i in range (n_trials): del_x = random . uniform( - delta, delta) del_y = random . uniform( - delta, delta) '''to make sure they are inside square''' if ( abs (x + del_x) < 1.0 and abs (y + del_y) < 1.0 ): x = x + del_x y = y + del_y '''to make sure they are inside circle''' if x ** 2 + y ** 2 < 1.0 : n_hits += 1 plt . scatter(x,y,color = \"blue\" , marker = '.' ) else : plt . scatter(x,y,color = \"red\" , marker = '.' ) print ( 4.0 * n_hits / float (n_trials)) 3.2256 Lets construct the function to run above code multiple time. def markov_pi (N, delta): x, y = 1.0 , 1.0 n_hits = 0 for i in range (N): del_x, del_y = random . uniform( - delta, delta),\\ random . uniform( - delta, delta) if abs (x + del_x) < 1.0 and abs (y + del_y) < 1.0 : x, y = x + del_x, y + del_y if x ** 2 + y ** 2 < 1.0 : n_hits += 1 computed_pi = 4.0 * n_hits / float (n_trials) return computed_pi n_runs = 100 n_trials = 10000 delta = 0.1 plt . figure(figsize = [ 12 , 3 ]) for run in range (n_runs): pi = markov_pi(n_trials, delta) plt . scatter(run,pi) plt . ylim([ 0 , 4.0 ]) plt . xlabel( \"No of Run\" ) plt . ylabel( \"Value of Pi\" ) plt . show()","title":"Algorithms"},{"location":"Montecarlo/GettingStarted/intro/#introduction-to-montecarlo-method","text":"In this notebook, we will calculate value of pi by implementation of Monte Carlo Simulation import random import matplotlib.pyplot as plt import numpy as np import pylab import seaborn as sns sns . set() % matplotlib inline","title":"Introduction to Montecarlo Method"},{"location":"Montecarlo/GettingStarted/intro/#lets-calculate-the-value-of-pi-directly","text":"In this method we randomly generate the points and calculate the ratio for value of PI. n_trials = 10000 n_hits = 0 plt . figure(figsize = [ 10 , 10 ]) for iter in range (n_trials): x = random . uniform( - 1.0 , 1.0 ) y = random . uniform( - 1.0 , 1.0 ) if x ** 2 + y ** 2 < 1.0 : plt . scatter(x,y,color = \"blue\" ,marker = '.' ) n_hits += 1 else : plt . scatter(x,y,color = \"red\" ,marker = '.' ) print ( 4.0 * n_hits / float (n_trials)) 3.174 Lets construct the function to run above code multiple time def direct_pi (N): n_hits = 0 for i in range (N): x = random . uniform( - 1.0 , 1.0 ) y = random . uniform( - 1.0 , 1.0 ) if x ** 2 + y ** 2 < 1.0 : n_hits += 1 computed_pi = 4.0 * n_hits / float (n_trials) return computed_pi n_runs = 100 n_trials = 1000 plt . figure(figsize = [ 12 , 3 ]) for run in range (n_runs): pi = direct_pi(n_trials) plt . scatter(run,pi) plt . ylim([ 0 , 4.0 ]) plt . xlabel( \"No of Run\" ) plt . ylabel( \"Value of Pi\" ) plt . show()","title":"Lets calculate the value of PI directly:"},{"location":"Montecarlo/GettingStarted/intro/#marcob-chain-calculation-of-pi","text":"In this method we perform a random walk and accept or reject the move. x, y = 1.0 , 1.0 delta = 0.1 n_trials = 5000 n_hits = 0 plt . figure(figsize = [ 10 , 10 ]) for i in range (n_trials): del_x = random . uniform( - delta, delta) del_y = random . uniform( - delta, delta) '''to make sure they are inside square''' if ( abs (x + del_x) < 1.0 and abs (y + del_y) < 1.0 ): x = x + del_x y = y + del_y '''to make sure they are inside circle''' if x ** 2 + y ** 2 < 1.0 : n_hits += 1 plt . scatter(x,y,color = \"blue\" , marker = '.' ) else : plt . scatter(x,y,color = \"red\" , marker = '.' ) print ( 4.0 * n_hits / float (n_trials)) 3.2256 Lets construct the function to run above code multiple time. def markov_pi (N, delta): x, y = 1.0 , 1.0 n_hits = 0 for i in range (N): del_x, del_y = random . uniform( - delta, delta),\\ random . uniform( - delta, delta) if abs (x + del_x) < 1.0 and abs (y + del_y) < 1.0 : x, y = x + del_x, y + del_y if x ** 2 + y ** 2 < 1.0 : n_hits += 1 computed_pi = 4.0 * n_hits / float (n_trials) return computed_pi n_runs = 100 n_trials = 10000 delta = 0.1 plt . figure(figsize = [ 12 , 3 ]) for run in range (n_runs): pi = markov_pi(n_trials, delta) plt . scatter(run,pi) plt . ylim([ 0 , 4.0 ]) plt . xlabel( \"No of Run\" ) plt . ylabel( \"Value of Pi\" ) plt . show()","title":"Marcob chain Calculation of PI:"},{"location":"Montecarlo/HardDisk/hd/","text":"From Classical to Statistical Mechanics Molecular Dynamics of Hard Disk Direct Disc Box import random , math N = 4 sigma = 0.2 condition = False while condition == False : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma))] for k in range ( 1 , N): a = (random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) min_dist = min (math . sqrt((a[ 0 ] - b[ 0 ]) ** 2 + (a[ 1 ] - b[ 1 ]) ** 2 ) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True print L [(0.7040822912665547, 0.2838326710047917), (0.39342373803132735, 0.7421281133983488), (0.22142950612928214, 0.3458410218455974), (0.7925829007636611, 0.7013410752456171)] Direct Disk Box Multirun import random , math def direct_disks_box (N, sigma): condition = False while condition == False : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma))] for k in range ( 1 , N): a = (random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) min_dist = min (math . sqrt((a[ 0 ] - b[ 0 ]) ** 2 + (a[ 1 ] - b[ 1 ]) ** 2 ) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return L N = 4 sigma = 0.2 n_runs = 10 for run in range (n_runs): print run, direct_disks_box(N, sigma) 0 [(0.751356313701969, 0.7908289343521684), (0.24313895825655835, 0.7973141414323697), (0.7507021517199071, 0.2714537639453098), (0.3426034108818664, 0.25674882938107063)] 1 [(0.7001130563019435, 0.712536202933747), (0.7789122711097405, 0.21613491258078213), (0.26983653980009353, 0.2199783600278326), (0.25072808927037593, 0.6851623784867935)] 2 [(0.27105063881736857, 0.6886358310439302), (0.7644440210934729, 0.284338623092072), (0.7010507662892869, 0.6836895516220605), (0.26760130925261805, 0.2011960174940446)] 3 [(0.7117322082996034, 0.7923158146795577), (0.20576363915920695, 0.33938157321671625), (0.6867409813215277, 0.3649824434229453), (0.2923911189377729, 0.7825731272388934)] 4 [(0.6574676789386877, 0.6868976023198012), (0.2380039193149221, 0.21289805532217043), (0.7500703097734738, 0.2596580338864641), (0.2526218011018484, 0.6277752777754828)] 5 [(0.7644607478477052, 0.7887798072013239), (0.3913939422967541, 0.6150405110722064), (0.791845121739368, 0.37567457535107485), (0.27690058656665545, 0.22580973987400982)] 6 [(0.7883698163715596, 0.3078375245763364), (0.20119330613086495, 0.6697044533868605), (0.2766166755457118, 0.22309290996928166), (0.6054862825572884, 0.7994464708554057)] 7 [(0.389813730050234, 0.7708075320063368), (0.6868787305435617, 0.2611610652253845), (0.2654758128109487, 0.24841543305461442), (0.7983355323897738, 0.7423829503625712)] 8 [(0.339797971819223, 0.7785840995102176), (0.22143753469214858, 0.23470027601609306), (0.7785801571980291, 0.774135930262885), (0.7506325168837178, 0.2827089622089741)] 9 [(0.24318601622049738, 0.3458768932480638), (0.2964140949544102, 0.7758479941402523), (0.6929994951070302, 0.2861686259992965), (0.7290840925214166, 0.7150475327560442)] Direct Disk Box Movie % matplotlib inline import random , math , os , pylab output_dir = 'direct_disks_box_movie' def direct_disks_box (N, sigma): condition = False while condition == False : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma))] for k in range ( 1 , N): a = (random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) min_dist = min (math . sqrt((a[ 0 ] - b[ 0 ]) ** 2 + (a[ 1 ] - b[ 1 ]) ** 2 ) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return L img = 0 if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (pos, colors): global img pylab . subplots_adjust(left = 0.10 , right = 0.90 , top = 0.90 , bottom = 0.10 ) pylab . gcf() . set_size_inches( 6 , 6 ) pylab . axis([ 0 , 1 , 0 , 1 ]) pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ]) for (x, y), c in zip (pos, colors): circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) #pylab.savefig(os.path.join(output_dir, '%d.png' % img), transparent=True) #pylab.close() pylab . show() img += 1 N = 4 colors = [ 'r' , 'b' , 'g' , 'orange' ] sigma = 0.2 n_runs = 4 for run in range (n_runs): pos = direct_disks_box(N, sigma) snapshot(pos, colors) Marcov Disk Box import random L = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] sigma = 0.15 sigma_sq = sigma ** 2 delta = 0.1 n_steps = 1000 for steps in range (n_steps): a = random . choice(L) b = [a[ 0 ] + random . uniform( - delta, delta), a[ 1 ] + random . uniform( - delta, delta)] min_dist = min ((b[ 0 ] - c[ 0 ]) ** 2 + (b[ 1 ] - c[ 1 ]) ** 2 for c in L if c != a) box_cond = min (b[ 0 ], b[ 1 ]) < sigma or max (b[ 0 ], b[ 1 ]) > 1.0 - sigma if not (box_cond or min_dist < 4.0 * sigma ** 2 ): a[:] = b print L [[0.45422994214163115, 0.3713914635605748], [0.7844238520523379, 0.4224856102112645], [0.15518208223429647, 0.5396419610447033], [0.7314291546873124, 0.842673491596291]] Marcove Disk Box Movie import random , os , pylab output_dir = 'markov_disks_box_movie' img = 0 if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (pos, colors): global img pylab . subplots_adjust(left = 0.10 , right = 0.90 , top = 0.90 , bottom = 0.10 ) pylab . gcf() . set_size_inches( 6 , 6 ) pylab . axis([ 0 , 1 , 0 , 1 ]) pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ]) for (x, y), c in zip (pos, colors): circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) #pylab.savefig(os.path.join(output_dir, '%d.png' % img), transparent=True) #pylab.close() pylab . show() img += 1 L = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] sigma = 0.15 sigma_sq = sigma ** 2 delta = 0.1 colors = [ 'r' , 'b' , 'g' , 'orange' ] n_steps = 5 for step in range (n_steps): snapshot(L, colors) a = random . choice(L) b = [a[ 0 ] + random . uniform( - delta, delta), a[ 1 ] + random . uniform( - delta, delta)] min_dist = min ((b[ 0 ] - c[ 0 ]) ** 2 + (b[ 1 ] - c[ 1 ]) ** 2 for c in L if c != a) box_cond = min (b[ 0 ], b[ 1 ]) < sigma or max (b[ 0 ], b[ 1 ]) > 1.0 - sigma if not (box_cond or min_dist < 4.0 * sigma ** 2 ): a[:] = b Event Disk Box import math def wall_time (pos_a, vel_a, sigma): if vel_a > 0.0 : del_t = ( 1.0 - sigma - pos_a) / vel_a elif vel_a < 0.0 : del_t = (pos_a - sigma) / abs (vel_a) else : del_t = float ( 'inf' ) return del_t def pair_time (pos_a, vel_a, pos_b, vel_b, sigma): del_x = [pos_b[ 0 ] - pos_a[ 0 ], pos_b[ 1 ] - pos_a[ 1 ]] del_x_sq = del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 del_v = [vel_b[ 0 ] - vel_a[ 0 ], vel_b[ 1 ] - vel_a[ 1 ]] del_v_sq = del_v[ 0 ] ** 2 + del_v[ 1 ] ** 2 scal = del_v[ 0 ] * del_x[ 0 ] + del_v[ 1 ] * del_x[ 1 ] Upsilon = scal ** 2 - del_v_sq * ( del_x_sq - 4.0 * sigma ** 2 ) if Upsilon > 0.0 and scal < 0.0 : del_t = - (scal + math . sqrt(Upsilon)) / del_v_sq else : del_t = float ( 'inf' ) return del_t pos = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] vel = [[ 0.21 , 0.12 ], [ 0.71 , 0.18 ], [ - 0.23 , - 0.79 ], [ 0.78 , 0.1177 ]] singles = [( 0 , 0 ), ( 0 , 1 ), ( 1 , 0 ), ( 1 , 1 ), ( 2 , 0 ), ( 2 , 1 ), ( 3 , 0 ), ( 3 , 1 )] pairs = [( 0 , 1 ), ( 0 , 2 ), ( 0 , 3 ), ( 1 , 2 ), ( 1 , 3 ), ( 2 , 3 )] sigma = 0.15 t = 0.0 n_events = 10 for event in range (n_events): wall_times = [wall_time(pos[k][l], vel[k][l], sigma) for k, l in singles] pair_times = [pair_time(pos[k], vel[k], pos[l], vel[l], sigma) for k, l in pairs] next_event = min (wall_times + pair_times) t += next_event for k, l in singles: pos[k][l] += vel[k][l] * next_event if min (wall_times) < min (pair_times): collision_disk, direction = singles[wall_times . index(next_event)] vel[collision_disk][direction] *= - 1.0 else : a, b = pairs[pair_times . index(next_event)] del_x = [pos[b][ 0 ] - pos[a][ 0 ], pos[b][ 1 ] - pos[a][ 1 ]] abs_x = math . sqrt(del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 ) e_perp = [c / abs_x for c in del_x] del_v = [vel[b][ 0 ] - vel[a][ 0 ], vel[b][ 1 ] - vel[a][ 1 ]] scal = del_v[ 0 ] * e_perp[ 0 ] + del_v[ 1 ] * e_perp[ 1 ] for k in range ( 2 ): vel[a][k] += e_perp[k] * scal vel[b][k] -= e_perp[k] * scal print 'event' , event print 'time' , t print 'pos' , pos print 'vel' , vel event 0 time 0.128205128205 pos [[0.27692307692307694, 0.2653846153846154], [0.841025641025641, 0.27307692307692305], [0.2205128205128205, 0.6487179487179487], [0.85, 0.7650897435897436]] vel [[0.21, 0.12], [0.71, 0.18], [-0.23, -0.79], [-0.78, 0.1177]] event 1 time 0.140845070423 pos [[0.2795774647887324, 0.2669014084507042], [0.85, 0.2753521126760563], [0.21760563380281692, 0.6387323943661972], [0.8401408450704225, 0.7665774647887323]] vel [[0.21, 0.12], [-0.71, 0.18], [-0.23, -0.79], [-0.78, 0.1177]] event 2 time 0.241075114766 pos [[0.30062577410096064, 0.2789290137719775], [0.7788366685157999, 0.2933935206579662], [0.19455272360370984, 0.5595506593344816], [0.7619614104821464, 0.7783745410080145]] vel [[0.4559640224861213, -0.5307103210067202], [-0.71, 0.18], [-0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 3 time 0.334680348563 pos [[0.34330639302873317, 0.229251750095734], [0.7123769525200255, 0.31024246274140194], [0.15, 0.5465124163668252], [0.6889493281205914, 0.7893918770259055]] vel [[0.4559640224861213, -0.5307103210067202], [-0.71, 0.18], [0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 4 time 0.426596320324 pos [[0.38521676924328674, 0.18047099521717305], [0.6471166125702025, 0.3267873376582585], [0.19374869564975986, 0.5337094701659757], [0.6172548701475463, 0.8002103869020945]] vel [[-0.13004345387140676, -0.8580968115619534], [-0.12399252364247193, 0.5073864905552332], [0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 5 time 0.462106294031 pos [[0.38059892961546266, 0.15], [0.6427136413157146, 0.3448046185974856], [0.2106501655740237, 0.528763297327179], [0.5895570906555886, 0.8043899108074835]] vel [[-0.13004345387140676, 0.8580968115619534], [-0.12399252364247193, 0.5073864905552332], [0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 6 time 0.56183325768 pos [[0.36763009081848935, 0.23557538953362597], [0.6303482434177226, 0.39540473269688253], [0.2581166123425427, 0.5148723605735898], [0.5117700590096738, 0.8161277744289247]] vel [[0.2896767021129778, -0.21233369509579214], [-0.12399252364247193, 0.5073864905552332], [0.05624386650173674, 0.9311408276644657], [-0.78, 0.1177]] event 7 time 0.642779758788 pos [[0.3910784063071447, 0.21838771984821145], [0.6203114824652683, 0.43647589381698054], [0.26266935654466417, 0.5902449526121742], [0.44863178814515003, 0.8256551776093791]] vel [[0.2896767021129778, -0.21233369509579214], [-0.12399252364247193, 0.5073864905552332], [-0.6607492297641436, 0.023497791053664008], [-0.06300690373411966, 1.0253430366108016]] event 8 time 0.666522858923 pos [[0.39795622925208957, 0.2133462596635909], [0.6173675155604766, 0.4485228220692043], [0.24698112141847836, 0.5908028630181046], [0.44713580892061633, 0.85]] vel [[0.2896767021129778, -0.21233369509579214], [-0.12399252364247193, 0.5073864905552332], [-0.6607492297641436, 0.023497791053664008], [-0.06300690373411966, -1.0253430366108016]] event 9 time 0.764669954349 pos [[0.4263871561770383, 0.19250632422888558], [0.6051980095104381, 0.4983213323755524], [0.1821305037122126, 0.5931091029589469], [0.4409518643273318, 0.7493655591414552]] vel [[0.2896767021129778, -0.21233369509579214], [0.596499748925584, -0.5938596011324015], [-0.6607492297641436, 0.023497791053664008], [-0.7834991763021756, 0.07590305507683315]] Event Disk Box Movie import os , math , pylab output_dir = \"event_disks_box_movie\" colors = [ 'r' , 'b' , 'g' , 'orange' ] def wall_time (pos_a, vel_a, sigma): if vel_a > 0.0 : del_t = ( 1.0 - sigma - pos_a) / vel_a elif vel_a < 0.0 : del_t = (pos_a - sigma) / abs (vel_a) else : del_t = float ( 'inf' ) return del_t def pair_time (pos_a, vel_a, pos_b, vel_b, sigma): del_x = [pos_b[ 0 ] - pos_a[ 0 ], pos_b[ 1 ] - pos_a[ 1 ]] del_x_sq = del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 del_v = [vel_b[ 0 ] - vel_a[ 0 ], vel_b[ 1 ] - vel_a[ 1 ]] del_v_sq = del_v[ 0 ] ** 2 + del_v[ 1 ] ** 2 scal = del_v[ 0 ] * del_x[ 0 ] + del_v[ 1 ] * del_x[ 1 ] Upsilon = scal ** 2 - del_v_sq * (del_x_sq - 4.0 * sigma ** 2 ) if Upsilon > 0.0 and scal < 0.0 : del_t = - (scal + math . sqrt(Upsilon)) / del_v_sq else : del_t = float ( 'inf' ) return del_t def min_arg (l): return min ( zip (l, range ( len (l)))) def compute_next_event (pos, vel): wall_times = [wall_time(pos[k][l], vel[k][l], sigma) for k, l in singles] pair_times = [pair_time(pos[k], vel[k], pos[l], vel[l], sigma) for k, l in pairs] return min_arg(wall_times + pair_times) def compute_new_velocities (pos, vel, next_event_arg): if next_event_arg < len (singles): collision_disk, direction = singles[next_event_arg] vel[collision_disk][direction] *= - 1.0 else : a, b = pairs[next_event_arg - len (singles)] del_x = [pos[b][ 0 ] - pos[a][ 0 ], pos[b][ 1 ] - pos[a][ 1 ]] abs_x = math . sqrt(del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 ) e_perp = [c / abs_x for c in del_x] del_v = [vel[b][ 0 ] - vel[a][ 0 ], vel[b][ 1 ] - vel[a][ 1 ]] scal = del_v[ 0 ] * e_perp[ 0 ] + del_v[ 1 ] * e_perp[ 1 ] for k in range ( 2 ): vel[a][k] += e_perp[k] * scal vel[b][k] -= e_perp[k] * scal pylab . subplots_adjust(left = 0.10 , right = 0.90 , top = 0.90 , bottom = 0.10 ) pylab . gcf() . set_size_inches( 6 , 6 ) img = 0 if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (t, pos, vel, colors, arrow_scale =. 2 ): global img pylab . cla() pylab . axis([ 0 , 1 , 0 , 1 ]) pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ]) for (x, y), (dx, dy), c in zip (pos, vel, colors): dx *= arrow_scale dy *= arrow_scale circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) pylab . arrow( x, y, dx, dy, fc = \"k\" , ec = \"k\" , head_width = 0.05 , head_length = 0.05 ) pylab . text( . 5 , 1.03 , 't = %.2f ' % t, ha = 'center' ) pylab . savefig(os . path . join(output_dir, ' %d .png' % img)) img += 1 pos = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] vel = [[ 0.21 , 0.12 ], [ 0.71 , 0.18 ], [ - 0.23 , - 0.79 ], [ 0.78 , 0.1177 ]] singles = [( 0 , 0 ), ( 0 , 1 ), ( 1 , 0 ), ( 1 , 1 ), ( 2 , 0 ), ( 2 , 1 ), ( 3 , 0 ), ( 3 , 1 )] pairs = [( 0 , 1 ), ( 0 , 2 ), ( 0 , 3 ), ( 1 , 2 ), ( 1 , 3 ), ( 2 , 3 )] sigma = 0.15 t = 0.0 dt = 0.02 # dt=0 corresponds to event-to-event animation n_steps = 5 next_event, next_event_arg = compute_next_event(pos, vel) snapshot(t, pos, vel, colors) for step in range (n_steps): if dt: next_t = t + dt else : next_t = t + next_event while t + next_event <= next_t: t += next_event for k, l in singles: pos[k][l] += vel[k][l] * next_event compute_new_velocities(pos, vel, next_event_arg) next_event, next_event_arg = compute_next_event(pos, vel) remain_t = next_t - t for k, l in singles: pos[k][l] += vel[k][l] * remain_t t += remain_t next_event -= remain_t snapshot(t, pos, vel, colors) print 'time' ,t print ( 'Producing animation.gif using ImageMagick...' ) os . system( \"convert -delay 1 -dispose Background +page \" + str (output_dir) + \"/*.png -loop 0 \" + str (output_dir) + \"/animation.gif\" ) time 0.02 time 0.04 time 0.06 time 0.08 time 0.1 Producing animation.gif using ImageMagick... 32512 TUTORIAL Direct Discrete import random configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 10000 for run in range (n_runs): while True : red_rod = random . randint( 0 , 4 ) blue_rod = random . randint( 0 , 4 ) if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.1606 c 0.1744 b 0.1651 e 0.1688 d 0.1666 f 0.1645 Direct Disk Any import random configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 10000 for i in range (n_runs): red_rod = random . randint( 0 , 3 ) if red_rod >= 2 : red_rod += 1 while True : blue_rod = random . randint( 0 , 4 ) if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.125 c 0.2535 b 0.1282 e 0.1236 d 0.2448 f 0.1249 Direct Disk Slow import random N = 4 sigma = 0.2 pairs = [(i, j) for i in range (N - 1 ) for j in range (i + 1 , N)] while True : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) for k in range (N)] if min ((L[i][ 0 ] - L[j][ 0 ]) ** 2 + (L[i][ 1 ] - L[j][ 1 ]) ** 2 for i, j in pairs) > 4.0 * sigma ** 2 : break print L [(0.21551840405127012, 0.6946062982572399), (0.7165001545926342, 0.7818232246535084), (0.23604717555981464, 0.20175467827936644), (0.7369665863408736, 0.22746836079162713)] Direct Disk Multy Run import random , math def dist (x,y): d_x = abs (x[ 0 ] - y[ 0 ]) % 1.0 d_x = min (d_x, 1.0 - d_x) d_y = abs (x[ 1 ] - y[ 1 ]) % 1.0 d_y = min (d_y, 1.0 - d_y) return math . sqrt(d_x ** 2 + d_y ** 2 ) def direct_disks (N, sigma): n_iter = 0 condition = False while condition == False : n_iter += 1 L = [(random . random(), random . random())] for k in range ( 1 , N): a = (random . random(), random . random()) min_dist = min (dist(a, b) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return n_iter, L N = 16 eta = 0.26 sigma = math . sqrt(eta / N / math . pi) n_runs = 3 print 'Note that this program might take a while!' for run in range (n_runs): iterations, config = direct_disks(N, sigma) print 'run' ,run print iterations - 1 , 'tabula rasa wipe-outs before producing the following configuration' print config print Note that this program might take a while! run 0 31605 tabula rasa wipe-outs before producing the following configuration [(0.194889385979373, 0.39881902164303773), (0.2422007285687603, 0.7366374459128198), (0.35318282136090084, 0.5379884266619391), (0.5010455241583772, 0.4351768931362382), (0.6651055976532885, 0.4638578576617244), (0.9930426536472047, 0.4807095480519158), (0.17504742382982807, 0.10058142284791849), (0.055224973814334, 0.8728958780045791), (0.8132249354226135, 0.976570654646086), (0.6479652398072496, 0.05414388830919192), (0.01589908172878507, 0.2662968574596569), (0.6838513187488974, 0.19681773278090198), (0.9368744315347303, 0.685040874598465), (0.6148616792388668, 0.8576188696976752), (0.38396787071111793, 0.9725957113091733), (0.7881129382924161, 0.6785640836009906)] run 1 15954 tabula rasa wipe-outs before producing the following configuration [(0.4314049494382257, 0.6098720262344923), (0.017147469087248735, 0.04156012115642216), (0.36056156266147066, 0.848096088241863), (0.8125158065154952, 0.17366599388221793), (0.23732974230881831, 0.7494139151797977), (0.8348176875378838, 0.9989865343591413), (0.9598695317665644, 0.5346727546971781), (0.9745750478535258, 0.9026397096818709), (0.5788447208944535, 0.9892731652141654), (0.43368740080388346, 0.39188323415156523), (0.1026937138183539, 0.4900126255806251), (0.15313471644384324, 0.3225265326989947), (0.24881039713052955, 0.6005423814016275), (0.09841408880804847, 0.6398251433990972), (0.9254533880596515, 0.7439429279989943), (0.30040196508760963, 0.20692775996149626)] run 2 52422 tabula rasa wipe-outs before producing the following configuration [(0.5873980387542752, 0.03679282835548914), (0.11907075962976255, 0.44081971114056717), (0.9080215465908837, 0.671213015105709), (0.09022299677404289, 0.9507269787134838), (0.3001832219134687, 0.9687529174595204), (0.024158935597102804, 0.8117170627395138), (0.8457396014770665, 0.45224114982654495), (0.28763080699756904, 0.523078745591618), (0.8915709907417944, 0.1654529589377659), (0.205399596915937, 0.14035571179162276), (0.9776855981260978, 0.37045935309310907), (0.22316762060964956, 0.3302967536169472), (0.3872637064501423, 0.7600916230737015), (0.7138292384724666, 0.11545586820923892), (0.46404649182910096, 0.8999851793352671), (0.15322468771280318, 0.7070784377536645)] Direct Disk Multirun Movie import random , math , pylab , os def dist (x,y): d_x = abs (x[ 0 ] - y[ 0 ]) % 1.0 d_x = min (d_x, 1.0 - d_x) d_y = abs (x[ 1 ] - y[ 1 ]) % 1.0 d_y = min (d_y, 1.0 - d_y) return math . sqrt(d_x ** 2 + d_y ** 2 ) def direct_disks (N, sigma): n_iter = 0 condition = False while condition == False : n_iter += 1 L = [(random . random(), random . random())] for k in range ( 1 , N): a = (random . random(), random . random()) min_dist = min (dist(a, b) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return n_iter, L img = 0 output_dir = 'direct_disks_multirun_movie' if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (pos, colors, border_color = 'k' ): global img pylab . figure() pylab . axis([ 0 , 1 , 0 , 1 ]) [i . set_linewidth( 2 ) for i in pylab . gca() . spines . itervalues()] [i . set_color(border_color) for i in pylab . gca() . spines . itervalues()] pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ], aspect = 'equal' ) for (x, y), c in zip (pos, colors): circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) #pylab.savefig(output_dir+'/snapshot_%03i.png'%img) #pylab.close() pylab . show() img += 1 def periodicize (config): images = [ - 1.0 , 0.0 , 1.0 ] return [(x + dx, y + dy) for (x,y) in config for dx in images for dy in images] N = 16 eta = 0.28 sigma = math . sqrt(eta / N / math . pi) n_runs = 4 colors = [ 'r' for i in range ( 8 * N)] for run in range (n_runs): iterations, config = direct_disks(N, sigma) print 'run' ,run print iterations - 1 , 'tabula rasa wipe-outs before producing the following configuration' print config print config_per = periodicize(config) snapshot(config_per, colors, border_color = 'k' ) run 0 131155 tabula rasa wipe-outs before producing the following configuration [(0.37751482770484623, 0.09826945819054489), (0.9042803838379859, 0.9899090068252806), (0.6599172275086992, 0.13514484949079997), (0.3069710953434255, 0.9492470432337818), (0.812561619375132, 0.40987724481013443), (0.08056164082415274, 0.9742623716403652), (0.17768767689521647, 0.36507790353189173), (0.7472387120689303, 0.6515254273168409), (0.4823057447690441, 0.966105763619611), (0.8439633788642334, 0.22358147605283396), (0.2773016015309173, 0.5814435581054298), (0.9889618140696187, 0.1438503101976658), (0.14326378711556154, 0.7477166886625792), (0.9583168761426655, 0.7453819253487872), (0.6958450554989644, 0.833667878473739), (0.03867224868418362, 0.45119012797766134)] run 1 151638 tabula rasa wipe-outs before producing the following configuration [(0.06663014301020642, 0.031012554991157848), (0.964969664612716, 0.3118932568228565), (0.5264170452307265, 0.21975704506305127), (0.6756537746594122, 0.4041417433687611), (0.29476393772557075, 0.48140722828952787), (0.04654217216799017, 0.7996306905990145), (0.3608861327100239, 0.977618260879936), (0.6681113244137261, 0.6090611715960019), (0.12110126452367742, 0.22017356776253005), (0.8799686683355867, 0.6697177890430397), (0.5562558075938777, 0.010767930248896995), (0.47925142273497534, 0.6082991245007762), (0.8951272729365909, 0.868123465117719), (0.7441835171796956, 0.20179368489656824), (0.29000010977447666, 0.2067871038708291), (0.10233368264294007, 0.54745216577934)] run 2 40762 tabula rasa wipe-outs before producing the following configuration [(0.3260865108779446, 0.3148486233563623), (0.17803174008736766, 0.871851631193864), (0.8642532654525102, 0.08718797467709805), (0.4535702388344728, 0.1972919882412194), (0.07246890805097073, 0.5355473801360247), (0.3167501018585722, 0.7681798596800488), (0.671929948288115, 0.08427537345070424), (0.8644955101334825, 0.41613572562559775), (0.9021147383601401, 0.23196647448286645), (0.1780243297944175, 0.07236748708775964), (0.9632055830413773, 0.920103872618813), (0.90024339362327, 0.6917231317784356), (0.6185771240906243, 0.5665103724765188), (0.6793688570302557, 0.7331932103505989), (0.5239912054538993, 0.9604405020823239), (0.07573035699193864, 0.21241500055444595)] run 3 1734 tabula rasa wipe-outs before producing the following configuration [(0.2969684910325956, 0.7370119193950877), (0.9483844593486023, 0.6061018303643925), (0.1845637095681364, 0.11755918194051718), (0.9224199053841572, 0.869609425930199), (0.8519294493087842, 0.10902428512765583), (0.5101493777903654, 0.2872301781881832), (0.9875828733480082, 0.04180666162781088), (0.6831331006373645, 0.8465660961464345), (0.6993010504747139, 0.6378153765843604), (0.5672049317965627, 0.5350506678949322), (0.36850545523016154, 0.4642146828212168), (0.39988375455206737, 0.862433823125543), (0.7437881541243506, 0.3123760520673676), (0.6030356510965643, 0.10933875059004539), (0.9864351374492086, 0.2778717125787915), (0.16589795291507614, 0.5442153195383387)] Random Sequential Discrete import random configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 10000 for i in range (n_runs): red_rod = random . randint( 0 , 3 ) if red_rod >= 2 : red_rod += 1 while True : blue_rod = random . randint( 0 , 4 ) if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.1281 c 0.2548 b 0.122 e 0.1238 d 0.2474 f 0.1239 Random Sequential Discrete Movie import random , pylab , os output_dir = 'random_sequential_discrete_movie' if not os . path . exists(output_dir): os . makedirs(output_dir) def show_rods (red_rod, blue_rod, run, trial, frame): fig, ax = pylab . subplots() ax . set_xticks([ 0 , 1 , 2 , 3 , 4 ]) ax . set_yticks([]) height = 1.0 redrect = pylab . Rectangle((red_rod - 1.5 , 0.0 ), 3.0 , 1.1 * height, fc = 'r' ) pylab . gca() . add_patch(redrect) bluerect = pylab . Rectangle((blue_rod - 1.5 , 0.0 ), 3.0 , height, fc = 'b' ) pylab . gca() . add_patch(bluerect) pylab . axis( 'scaled' ) pylab . axis([ - 1.5 , 5.5 , 0.0 , 2.5 * height]) pylab . xlabel( \"x\" ) if abs (red_rod - blue_rod) > 2 : pylab . title( 'run %d , trial %d (ACCEPTED!)' % (run, trial)) else : pylab . title( 'run %d , trial %d (REJECTED!)' % (run, trial)) #pylab.savefig(output_dir+'/random_sequential_discrete_frame%d.png' % (frame)) pylab . show() configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 5 frame = 0 trial = 0 for run in range (n_runs): red_rod = random . randint( 0 , 3 ) if red_rod >= 2 : red_rod += 1 trial = 0 while True : blue_rod = random . randint( 0 , 4 ) show_rods(red_rod, blue_rod, run, trial, frame) trial += 1 frame += 1 if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.4 c 0.2 b 0.0 e 0.2 d 0.2 f 0.0","title":"Hard Disk"},{"location":"Montecarlo/HardDisk/hd/#from-classical-to-statistical-mechanics","text":"","title":"From Classical to Statistical Mechanics"},{"location":"Montecarlo/HardDisk/hd/#molecular-dynamics-of-hard-disk","text":"Direct Disc Box import random , math N = 4 sigma = 0.2 condition = False while condition == False : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma))] for k in range ( 1 , N): a = (random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) min_dist = min (math . sqrt((a[ 0 ] - b[ 0 ]) ** 2 + (a[ 1 ] - b[ 1 ]) ** 2 ) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True print L [(0.7040822912665547, 0.2838326710047917), (0.39342373803132735, 0.7421281133983488), (0.22142950612928214, 0.3458410218455974), (0.7925829007636611, 0.7013410752456171)] Direct Disk Box Multirun import random , math def direct_disks_box (N, sigma): condition = False while condition == False : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma))] for k in range ( 1 , N): a = (random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) min_dist = min (math . sqrt((a[ 0 ] - b[ 0 ]) ** 2 + (a[ 1 ] - b[ 1 ]) ** 2 ) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return L N = 4 sigma = 0.2 n_runs = 10 for run in range (n_runs): print run, direct_disks_box(N, sigma) 0 [(0.751356313701969, 0.7908289343521684), (0.24313895825655835, 0.7973141414323697), (0.7507021517199071, 0.2714537639453098), (0.3426034108818664, 0.25674882938107063)] 1 [(0.7001130563019435, 0.712536202933747), (0.7789122711097405, 0.21613491258078213), (0.26983653980009353, 0.2199783600278326), (0.25072808927037593, 0.6851623784867935)] 2 [(0.27105063881736857, 0.6886358310439302), (0.7644440210934729, 0.284338623092072), (0.7010507662892869, 0.6836895516220605), (0.26760130925261805, 0.2011960174940446)] 3 [(0.7117322082996034, 0.7923158146795577), (0.20576363915920695, 0.33938157321671625), (0.6867409813215277, 0.3649824434229453), (0.2923911189377729, 0.7825731272388934)] 4 [(0.6574676789386877, 0.6868976023198012), (0.2380039193149221, 0.21289805532217043), (0.7500703097734738, 0.2596580338864641), (0.2526218011018484, 0.6277752777754828)] 5 [(0.7644607478477052, 0.7887798072013239), (0.3913939422967541, 0.6150405110722064), (0.791845121739368, 0.37567457535107485), (0.27690058656665545, 0.22580973987400982)] 6 [(0.7883698163715596, 0.3078375245763364), (0.20119330613086495, 0.6697044533868605), (0.2766166755457118, 0.22309290996928166), (0.6054862825572884, 0.7994464708554057)] 7 [(0.389813730050234, 0.7708075320063368), (0.6868787305435617, 0.2611610652253845), (0.2654758128109487, 0.24841543305461442), (0.7983355323897738, 0.7423829503625712)] 8 [(0.339797971819223, 0.7785840995102176), (0.22143753469214858, 0.23470027601609306), (0.7785801571980291, 0.774135930262885), (0.7506325168837178, 0.2827089622089741)] 9 [(0.24318601622049738, 0.3458768932480638), (0.2964140949544102, 0.7758479941402523), (0.6929994951070302, 0.2861686259992965), (0.7290840925214166, 0.7150475327560442)] Direct Disk Box Movie % matplotlib inline import random , math , os , pylab output_dir = 'direct_disks_box_movie' def direct_disks_box (N, sigma): condition = False while condition == False : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma))] for k in range ( 1 , N): a = (random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) min_dist = min (math . sqrt((a[ 0 ] - b[ 0 ]) ** 2 + (a[ 1 ] - b[ 1 ]) ** 2 ) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return L img = 0 if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (pos, colors): global img pylab . subplots_adjust(left = 0.10 , right = 0.90 , top = 0.90 , bottom = 0.10 ) pylab . gcf() . set_size_inches( 6 , 6 ) pylab . axis([ 0 , 1 , 0 , 1 ]) pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ]) for (x, y), c in zip (pos, colors): circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) #pylab.savefig(os.path.join(output_dir, '%d.png' % img), transparent=True) #pylab.close() pylab . show() img += 1 N = 4 colors = [ 'r' , 'b' , 'g' , 'orange' ] sigma = 0.2 n_runs = 4 for run in range (n_runs): pos = direct_disks_box(N, sigma) snapshot(pos, colors) Marcov Disk Box import random L = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] sigma = 0.15 sigma_sq = sigma ** 2 delta = 0.1 n_steps = 1000 for steps in range (n_steps): a = random . choice(L) b = [a[ 0 ] + random . uniform( - delta, delta), a[ 1 ] + random . uniform( - delta, delta)] min_dist = min ((b[ 0 ] - c[ 0 ]) ** 2 + (b[ 1 ] - c[ 1 ]) ** 2 for c in L if c != a) box_cond = min (b[ 0 ], b[ 1 ]) < sigma or max (b[ 0 ], b[ 1 ]) > 1.0 - sigma if not (box_cond or min_dist < 4.0 * sigma ** 2 ): a[:] = b print L [[0.45422994214163115, 0.3713914635605748], [0.7844238520523379, 0.4224856102112645], [0.15518208223429647, 0.5396419610447033], [0.7314291546873124, 0.842673491596291]] Marcove Disk Box Movie import random , os , pylab output_dir = 'markov_disks_box_movie' img = 0 if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (pos, colors): global img pylab . subplots_adjust(left = 0.10 , right = 0.90 , top = 0.90 , bottom = 0.10 ) pylab . gcf() . set_size_inches( 6 , 6 ) pylab . axis([ 0 , 1 , 0 , 1 ]) pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ]) for (x, y), c in zip (pos, colors): circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) #pylab.savefig(os.path.join(output_dir, '%d.png' % img), transparent=True) #pylab.close() pylab . show() img += 1 L = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] sigma = 0.15 sigma_sq = sigma ** 2 delta = 0.1 colors = [ 'r' , 'b' , 'g' , 'orange' ] n_steps = 5 for step in range (n_steps): snapshot(L, colors) a = random . choice(L) b = [a[ 0 ] + random . uniform( - delta, delta), a[ 1 ] + random . uniform( - delta, delta)] min_dist = min ((b[ 0 ] - c[ 0 ]) ** 2 + (b[ 1 ] - c[ 1 ]) ** 2 for c in L if c != a) box_cond = min (b[ 0 ], b[ 1 ]) < sigma or max (b[ 0 ], b[ 1 ]) > 1.0 - sigma if not (box_cond or min_dist < 4.0 * sigma ** 2 ): a[:] = b Event Disk Box import math def wall_time (pos_a, vel_a, sigma): if vel_a > 0.0 : del_t = ( 1.0 - sigma - pos_a) / vel_a elif vel_a < 0.0 : del_t = (pos_a - sigma) / abs (vel_a) else : del_t = float ( 'inf' ) return del_t def pair_time (pos_a, vel_a, pos_b, vel_b, sigma): del_x = [pos_b[ 0 ] - pos_a[ 0 ], pos_b[ 1 ] - pos_a[ 1 ]] del_x_sq = del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 del_v = [vel_b[ 0 ] - vel_a[ 0 ], vel_b[ 1 ] - vel_a[ 1 ]] del_v_sq = del_v[ 0 ] ** 2 + del_v[ 1 ] ** 2 scal = del_v[ 0 ] * del_x[ 0 ] + del_v[ 1 ] * del_x[ 1 ] Upsilon = scal ** 2 - del_v_sq * ( del_x_sq - 4.0 * sigma ** 2 ) if Upsilon > 0.0 and scal < 0.0 : del_t = - (scal + math . sqrt(Upsilon)) / del_v_sq else : del_t = float ( 'inf' ) return del_t pos = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] vel = [[ 0.21 , 0.12 ], [ 0.71 , 0.18 ], [ - 0.23 , - 0.79 ], [ 0.78 , 0.1177 ]] singles = [( 0 , 0 ), ( 0 , 1 ), ( 1 , 0 ), ( 1 , 1 ), ( 2 , 0 ), ( 2 , 1 ), ( 3 , 0 ), ( 3 , 1 )] pairs = [( 0 , 1 ), ( 0 , 2 ), ( 0 , 3 ), ( 1 , 2 ), ( 1 , 3 ), ( 2 , 3 )] sigma = 0.15 t = 0.0 n_events = 10 for event in range (n_events): wall_times = [wall_time(pos[k][l], vel[k][l], sigma) for k, l in singles] pair_times = [pair_time(pos[k], vel[k], pos[l], vel[l], sigma) for k, l in pairs] next_event = min (wall_times + pair_times) t += next_event for k, l in singles: pos[k][l] += vel[k][l] * next_event if min (wall_times) < min (pair_times): collision_disk, direction = singles[wall_times . index(next_event)] vel[collision_disk][direction] *= - 1.0 else : a, b = pairs[pair_times . index(next_event)] del_x = [pos[b][ 0 ] - pos[a][ 0 ], pos[b][ 1 ] - pos[a][ 1 ]] abs_x = math . sqrt(del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 ) e_perp = [c / abs_x for c in del_x] del_v = [vel[b][ 0 ] - vel[a][ 0 ], vel[b][ 1 ] - vel[a][ 1 ]] scal = del_v[ 0 ] * e_perp[ 0 ] + del_v[ 1 ] * e_perp[ 1 ] for k in range ( 2 ): vel[a][k] += e_perp[k] * scal vel[b][k] -= e_perp[k] * scal print 'event' , event print 'time' , t print 'pos' , pos print 'vel' , vel event 0 time 0.128205128205 pos [[0.27692307692307694, 0.2653846153846154], [0.841025641025641, 0.27307692307692305], [0.2205128205128205, 0.6487179487179487], [0.85, 0.7650897435897436]] vel [[0.21, 0.12], [0.71, 0.18], [-0.23, -0.79], [-0.78, 0.1177]] event 1 time 0.140845070423 pos [[0.2795774647887324, 0.2669014084507042], [0.85, 0.2753521126760563], [0.21760563380281692, 0.6387323943661972], [0.8401408450704225, 0.7665774647887323]] vel [[0.21, 0.12], [-0.71, 0.18], [-0.23, -0.79], [-0.78, 0.1177]] event 2 time 0.241075114766 pos [[0.30062577410096064, 0.2789290137719775], [0.7788366685157999, 0.2933935206579662], [0.19455272360370984, 0.5595506593344816], [0.7619614104821464, 0.7783745410080145]] vel [[0.4559640224861213, -0.5307103210067202], [-0.71, 0.18], [-0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 3 time 0.334680348563 pos [[0.34330639302873317, 0.229251750095734], [0.7123769525200255, 0.31024246274140194], [0.15, 0.5465124163668252], [0.6889493281205914, 0.7893918770259055]] vel [[0.4559640224861213, -0.5307103210067202], [-0.71, 0.18], [0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 4 time 0.426596320324 pos [[0.38521676924328674, 0.18047099521717305], [0.6471166125702025, 0.3267873376582585], [0.19374869564975986, 0.5337094701659757], [0.6172548701475463, 0.8002103869020945]] vel [[-0.13004345387140676, -0.8580968115619534], [-0.12399252364247193, 0.5073864905552332], [0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 5 time 0.462106294031 pos [[0.38059892961546266, 0.15], [0.6427136413157146, 0.3448046185974856], [0.2106501655740237, 0.528763297327179], [0.5895570906555886, 0.8043899108074835]] vel [[-0.13004345387140676, 0.8580968115619534], [-0.12399252364247193, 0.5073864905552332], [0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 6 time 0.56183325768 pos [[0.36763009081848935, 0.23557538953362597], [0.6303482434177226, 0.39540473269688253], [0.2581166123425427, 0.5148723605735898], [0.5117700590096738, 0.8161277744289247]] vel [[0.2896767021129778, -0.21233369509579214], [-0.12399252364247193, 0.5073864905552332], [0.05624386650173674, 0.9311408276644657], [-0.78, 0.1177]] event 7 time 0.642779758788 pos [[0.3910784063071447, 0.21838771984821145], [0.6203114824652683, 0.43647589381698054], [0.26266935654466417, 0.5902449526121742], [0.44863178814515003, 0.8256551776093791]] vel [[0.2896767021129778, -0.21233369509579214], [-0.12399252364247193, 0.5073864905552332], [-0.6607492297641436, 0.023497791053664008], [-0.06300690373411966, 1.0253430366108016]] event 8 time 0.666522858923 pos [[0.39795622925208957, 0.2133462596635909], [0.6173675155604766, 0.4485228220692043], [0.24698112141847836, 0.5908028630181046], [0.44713580892061633, 0.85]] vel [[0.2896767021129778, -0.21233369509579214], [-0.12399252364247193, 0.5073864905552332], [-0.6607492297641436, 0.023497791053664008], [-0.06300690373411966, -1.0253430366108016]] event 9 time 0.764669954349 pos [[0.4263871561770383, 0.19250632422888558], [0.6051980095104381, 0.4983213323755524], [0.1821305037122126, 0.5931091029589469], [0.4409518643273318, 0.7493655591414552]] vel [[0.2896767021129778, -0.21233369509579214], [0.596499748925584, -0.5938596011324015], [-0.6607492297641436, 0.023497791053664008], [-0.7834991763021756, 0.07590305507683315]] Event Disk Box Movie import os , math , pylab output_dir = \"event_disks_box_movie\" colors = [ 'r' , 'b' , 'g' , 'orange' ] def wall_time (pos_a, vel_a, sigma): if vel_a > 0.0 : del_t = ( 1.0 - sigma - pos_a) / vel_a elif vel_a < 0.0 : del_t = (pos_a - sigma) / abs (vel_a) else : del_t = float ( 'inf' ) return del_t def pair_time (pos_a, vel_a, pos_b, vel_b, sigma): del_x = [pos_b[ 0 ] - pos_a[ 0 ], pos_b[ 1 ] - pos_a[ 1 ]] del_x_sq = del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 del_v = [vel_b[ 0 ] - vel_a[ 0 ], vel_b[ 1 ] - vel_a[ 1 ]] del_v_sq = del_v[ 0 ] ** 2 + del_v[ 1 ] ** 2 scal = del_v[ 0 ] * del_x[ 0 ] + del_v[ 1 ] * del_x[ 1 ] Upsilon = scal ** 2 - del_v_sq * (del_x_sq - 4.0 * sigma ** 2 ) if Upsilon > 0.0 and scal < 0.0 : del_t = - (scal + math . sqrt(Upsilon)) / del_v_sq else : del_t = float ( 'inf' ) return del_t def min_arg (l): return min ( zip (l, range ( len (l)))) def compute_next_event (pos, vel): wall_times = [wall_time(pos[k][l], vel[k][l], sigma) for k, l in singles] pair_times = [pair_time(pos[k], vel[k], pos[l], vel[l], sigma) for k, l in pairs] return min_arg(wall_times + pair_times) def compute_new_velocities (pos, vel, next_event_arg): if next_event_arg < len (singles): collision_disk, direction = singles[next_event_arg] vel[collision_disk][direction] *= - 1.0 else : a, b = pairs[next_event_arg - len (singles)] del_x = [pos[b][ 0 ] - pos[a][ 0 ], pos[b][ 1 ] - pos[a][ 1 ]] abs_x = math . sqrt(del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 ) e_perp = [c / abs_x for c in del_x] del_v = [vel[b][ 0 ] - vel[a][ 0 ], vel[b][ 1 ] - vel[a][ 1 ]] scal = del_v[ 0 ] * e_perp[ 0 ] + del_v[ 1 ] * e_perp[ 1 ] for k in range ( 2 ): vel[a][k] += e_perp[k] * scal vel[b][k] -= e_perp[k] * scal pylab . subplots_adjust(left = 0.10 , right = 0.90 , top = 0.90 , bottom = 0.10 ) pylab . gcf() . set_size_inches( 6 , 6 ) img = 0 if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (t, pos, vel, colors, arrow_scale =. 2 ): global img pylab . cla() pylab . axis([ 0 , 1 , 0 , 1 ]) pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ]) for (x, y), (dx, dy), c in zip (pos, vel, colors): dx *= arrow_scale dy *= arrow_scale circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) pylab . arrow( x, y, dx, dy, fc = \"k\" , ec = \"k\" , head_width = 0.05 , head_length = 0.05 ) pylab . text( . 5 , 1.03 , 't = %.2f ' % t, ha = 'center' ) pylab . savefig(os . path . join(output_dir, ' %d .png' % img)) img += 1 pos = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] vel = [[ 0.21 , 0.12 ], [ 0.71 , 0.18 ], [ - 0.23 , - 0.79 ], [ 0.78 , 0.1177 ]] singles = [( 0 , 0 ), ( 0 , 1 ), ( 1 , 0 ), ( 1 , 1 ), ( 2 , 0 ), ( 2 , 1 ), ( 3 , 0 ), ( 3 , 1 )] pairs = [( 0 , 1 ), ( 0 , 2 ), ( 0 , 3 ), ( 1 , 2 ), ( 1 , 3 ), ( 2 , 3 )] sigma = 0.15 t = 0.0 dt = 0.02 # dt=0 corresponds to event-to-event animation n_steps = 5 next_event, next_event_arg = compute_next_event(pos, vel) snapshot(t, pos, vel, colors) for step in range (n_steps): if dt: next_t = t + dt else : next_t = t + next_event while t + next_event <= next_t: t += next_event for k, l in singles: pos[k][l] += vel[k][l] * next_event compute_new_velocities(pos, vel, next_event_arg) next_event, next_event_arg = compute_next_event(pos, vel) remain_t = next_t - t for k, l in singles: pos[k][l] += vel[k][l] * remain_t t += remain_t next_event -= remain_t snapshot(t, pos, vel, colors) print 'time' ,t print ( 'Producing animation.gif using ImageMagick...' ) os . system( \"convert -delay 1 -dispose Background +page \" + str (output_dir) + \"/*.png -loop 0 \" + str (output_dir) + \"/animation.gif\" ) time 0.02 time 0.04 time 0.06 time 0.08 time 0.1 Producing animation.gif using ImageMagick... 32512","title":"Molecular Dynamics of Hard Disk"},{"location":"Montecarlo/HardDisk/hd/#tutorial","text":"Direct Discrete import random configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 10000 for run in range (n_runs): while True : red_rod = random . randint( 0 , 4 ) blue_rod = random . randint( 0 , 4 ) if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.1606 c 0.1744 b 0.1651 e 0.1688 d 0.1666 f 0.1645 Direct Disk Any import random configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 10000 for i in range (n_runs): red_rod = random . randint( 0 , 3 ) if red_rod >= 2 : red_rod += 1 while True : blue_rod = random . randint( 0 , 4 ) if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.125 c 0.2535 b 0.1282 e 0.1236 d 0.2448 f 0.1249 Direct Disk Slow import random N = 4 sigma = 0.2 pairs = [(i, j) for i in range (N - 1 ) for j in range (i + 1 , N)] while True : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) for k in range (N)] if min ((L[i][ 0 ] - L[j][ 0 ]) ** 2 + (L[i][ 1 ] - L[j][ 1 ]) ** 2 for i, j in pairs) > 4.0 * sigma ** 2 : break print L [(0.21551840405127012, 0.6946062982572399), (0.7165001545926342, 0.7818232246535084), (0.23604717555981464, 0.20175467827936644), (0.7369665863408736, 0.22746836079162713)] Direct Disk Multy Run import random , math def dist (x,y): d_x = abs (x[ 0 ] - y[ 0 ]) % 1.0 d_x = min (d_x, 1.0 - d_x) d_y = abs (x[ 1 ] - y[ 1 ]) % 1.0 d_y = min (d_y, 1.0 - d_y) return math . sqrt(d_x ** 2 + d_y ** 2 ) def direct_disks (N, sigma): n_iter = 0 condition = False while condition == False : n_iter += 1 L = [(random . random(), random . random())] for k in range ( 1 , N): a = (random . random(), random . random()) min_dist = min (dist(a, b) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return n_iter, L N = 16 eta = 0.26 sigma = math . sqrt(eta / N / math . pi) n_runs = 3 print 'Note that this program might take a while!' for run in range (n_runs): iterations, config = direct_disks(N, sigma) print 'run' ,run print iterations - 1 , 'tabula rasa wipe-outs before producing the following configuration' print config print Note that this program might take a while! run 0 31605 tabula rasa wipe-outs before producing the following configuration [(0.194889385979373, 0.39881902164303773), (0.2422007285687603, 0.7366374459128198), (0.35318282136090084, 0.5379884266619391), (0.5010455241583772, 0.4351768931362382), (0.6651055976532885, 0.4638578576617244), (0.9930426536472047, 0.4807095480519158), (0.17504742382982807, 0.10058142284791849), (0.055224973814334, 0.8728958780045791), (0.8132249354226135, 0.976570654646086), (0.6479652398072496, 0.05414388830919192), (0.01589908172878507, 0.2662968574596569), (0.6838513187488974, 0.19681773278090198), (0.9368744315347303, 0.685040874598465), (0.6148616792388668, 0.8576188696976752), (0.38396787071111793, 0.9725957113091733), (0.7881129382924161, 0.6785640836009906)] run 1 15954 tabula rasa wipe-outs before producing the following configuration [(0.4314049494382257, 0.6098720262344923), (0.017147469087248735, 0.04156012115642216), (0.36056156266147066, 0.848096088241863), (0.8125158065154952, 0.17366599388221793), (0.23732974230881831, 0.7494139151797977), (0.8348176875378838, 0.9989865343591413), (0.9598695317665644, 0.5346727546971781), (0.9745750478535258, 0.9026397096818709), (0.5788447208944535, 0.9892731652141654), (0.43368740080388346, 0.39188323415156523), (0.1026937138183539, 0.4900126255806251), (0.15313471644384324, 0.3225265326989947), (0.24881039713052955, 0.6005423814016275), (0.09841408880804847, 0.6398251433990972), (0.9254533880596515, 0.7439429279989943), (0.30040196508760963, 0.20692775996149626)] run 2 52422 tabula rasa wipe-outs before producing the following configuration [(0.5873980387542752, 0.03679282835548914), (0.11907075962976255, 0.44081971114056717), (0.9080215465908837, 0.671213015105709), (0.09022299677404289, 0.9507269787134838), (0.3001832219134687, 0.9687529174595204), (0.024158935597102804, 0.8117170627395138), (0.8457396014770665, 0.45224114982654495), (0.28763080699756904, 0.523078745591618), (0.8915709907417944, 0.1654529589377659), (0.205399596915937, 0.14035571179162276), (0.9776855981260978, 0.37045935309310907), (0.22316762060964956, 0.3302967536169472), (0.3872637064501423, 0.7600916230737015), (0.7138292384724666, 0.11545586820923892), (0.46404649182910096, 0.8999851793352671), (0.15322468771280318, 0.7070784377536645)] Direct Disk Multirun Movie import random , math , pylab , os def dist (x,y): d_x = abs (x[ 0 ] - y[ 0 ]) % 1.0 d_x = min (d_x, 1.0 - d_x) d_y = abs (x[ 1 ] - y[ 1 ]) % 1.0 d_y = min (d_y, 1.0 - d_y) return math . sqrt(d_x ** 2 + d_y ** 2 ) def direct_disks (N, sigma): n_iter = 0 condition = False while condition == False : n_iter += 1 L = [(random . random(), random . random())] for k in range ( 1 , N): a = (random . random(), random . random()) min_dist = min (dist(a, b) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return n_iter, L img = 0 output_dir = 'direct_disks_multirun_movie' if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (pos, colors, border_color = 'k' ): global img pylab . figure() pylab . axis([ 0 , 1 , 0 , 1 ]) [i . set_linewidth( 2 ) for i in pylab . gca() . spines . itervalues()] [i . set_color(border_color) for i in pylab . gca() . spines . itervalues()] pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ], aspect = 'equal' ) for (x, y), c in zip (pos, colors): circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) #pylab.savefig(output_dir+'/snapshot_%03i.png'%img) #pylab.close() pylab . show() img += 1 def periodicize (config): images = [ - 1.0 , 0.0 , 1.0 ] return [(x + dx, y + dy) for (x,y) in config for dx in images for dy in images] N = 16 eta = 0.28 sigma = math . sqrt(eta / N / math . pi) n_runs = 4 colors = [ 'r' for i in range ( 8 * N)] for run in range (n_runs): iterations, config = direct_disks(N, sigma) print 'run' ,run print iterations - 1 , 'tabula rasa wipe-outs before producing the following configuration' print config print config_per = periodicize(config) snapshot(config_per, colors, border_color = 'k' ) run 0 131155 tabula rasa wipe-outs before producing the following configuration [(0.37751482770484623, 0.09826945819054489), (0.9042803838379859, 0.9899090068252806), (0.6599172275086992, 0.13514484949079997), (0.3069710953434255, 0.9492470432337818), (0.812561619375132, 0.40987724481013443), (0.08056164082415274, 0.9742623716403652), (0.17768767689521647, 0.36507790353189173), (0.7472387120689303, 0.6515254273168409), (0.4823057447690441, 0.966105763619611), (0.8439633788642334, 0.22358147605283396), (0.2773016015309173, 0.5814435581054298), (0.9889618140696187, 0.1438503101976658), (0.14326378711556154, 0.7477166886625792), (0.9583168761426655, 0.7453819253487872), (0.6958450554989644, 0.833667878473739), (0.03867224868418362, 0.45119012797766134)] run 1 151638 tabula rasa wipe-outs before producing the following configuration [(0.06663014301020642, 0.031012554991157848), (0.964969664612716, 0.3118932568228565), (0.5264170452307265, 0.21975704506305127), (0.6756537746594122, 0.4041417433687611), (0.29476393772557075, 0.48140722828952787), (0.04654217216799017, 0.7996306905990145), (0.3608861327100239, 0.977618260879936), (0.6681113244137261, 0.6090611715960019), (0.12110126452367742, 0.22017356776253005), (0.8799686683355867, 0.6697177890430397), (0.5562558075938777, 0.010767930248896995), (0.47925142273497534, 0.6082991245007762), (0.8951272729365909, 0.868123465117719), (0.7441835171796956, 0.20179368489656824), (0.29000010977447666, 0.2067871038708291), (0.10233368264294007, 0.54745216577934)] run 2 40762 tabula rasa wipe-outs before producing the following configuration [(0.3260865108779446, 0.3148486233563623), (0.17803174008736766, 0.871851631193864), (0.8642532654525102, 0.08718797467709805), (0.4535702388344728, 0.1972919882412194), (0.07246890805097073, 0.5355473801360247), (0.3167501018585722, 0.7681798596800488), (0.671929948288115, 0.08427537345070424), (0.8644955101334825, 0.41613572562559775), (0.9021147383601401, 0.23196647448286645), (0.1780243297944175, 0.07236748708775964), (0.9632055830413773, 0.920103872618813), (0.90024339362327, 0.6917231317784356), (0.6185771240906243, 0.5665103724765188), (0.6793688570302557, 0.7331932103505989), (0.5239912054538993, 0.9604405020823239), (0.07573035699193864, 0.21241500055444595)] run 3 1734 tabula rasa wipe-outs before producing the following configuration [(0.2969684910325956, 0.7370119193950877), (0.9483844593486023, 0.6061018303643925), (0.1845637095681364, 0.11755918194051718), (0.9224199053841572, 0.869609425930199), (0.8519294493087842, 0.10902428512765583), (0.5101493777903654, 0.2872301781881832), (0.9875828733480082, 0.04180666162781088), (0.6831331006373645, 0.8465660961464345), (0.6993010504747139, 0.6378153765843604), (0.5672049317965627, 0.5350506678949322), (0.36850545523016154, 0.4642146828212168), (0.39988375455206737, 0.862433823125543), (0.7437881541243506, 0.3123760520673676), (0.6030356510965643, 0.10933875059004539), (0.9864351374492086, 0.2778717125787915), (0.16589795291507614, 0.5442153195383387)] Random Sequential Discrete import random configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 10000 for i in range (n_runs): red_rod = random . randint( 0 , 3 ) if red_rod >= 2 : red_rod += 1 while True : blue_rod = random . randint( 0 , 4 ) if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.1281 c 0.2548 b 0.122 e 0.1238 d 0.2474 f 0.1239 Random Sequential Discrete Movie import random , pylab , os output_dir = 'random_sequential_discrete_movie' if not os . path . exists(output_dir): os . makedirs(output_dir) def show_rods (red_rod, blue_rod, run, trial, frame): fig, ax = pylab . subplots() ax . set_xticks([ 0 , 1 , 2 , 3 , 4 ]) ax . set_yticks([]) height = 1.0 redrect = pylab . Rectangle((red_rod - 1.5 , 0.0 ), 3.0 , 1.1 * height, fc = 'r' ) pylab . gca() . add_patch(redrect) bluerect = pylab . Rectangle((blue_rod - 1.5 , 0.0 ), 3.0 , height, fc = 'b' ) pylab . gca() . add_patch(bluerect) pylab . axis( 'scaled' ) pylab . axis([ - 1.5 , 5.5 , 0.0 , 2.5 * height]) pylab . xlabel( \"x\" ) if abs (red_rod - blue_rod) > 2 : pylab . title( 'run %d , trial %d (ACCEPTED!)' % (run, trial)) else : pylab . title( 'run %d , trial %d (REJECTED!)' % (run, trial)) #pylab.savefig(output_dir+'/random_sequential_discrete_frame%d.png' % (frame)) pylab . show() configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 5 frame = 0 trial = 0 for run in range (n_runs): red_rod = random . randint( 0 , 3 ) if red_rod >= 2 : red_rod += 1 trial = 0 while True : blue_rod = random . randint( 0 , 4 ) show_rods(red_rod, blue_rod, run, trial, frame) trial += 1 frame += 1 if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.4 c 0.2 b 0.0 e 0.2 d 0.2 f 0.0","title":"TUTORIAL"},{"location":"Montecarlo/IdealGas/IdealGas/","text":"Maxwell's distribution of speed. Import import math as math import random as random import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns . set() Global constants m = 3.2 # mass is in unit of Kb Kb = 1.0 Input parameters N = 100 u0 = 150.00 dv = 0.01 Starter def starter (key): u = [ 0.0 for k in range (N)] if key == 0 : return u else : for k in range (N): u[k] = u0 return u Hamiltonian def hamiltonian (u): H = 0.0 for k in range (N): H = H + 0.5 * u[k] ** 2 return H Pick a particle and change def pick_random_particle (): n = random . randint( 0 , N - 1 ) return n Thermalization def thermalize (u,T,nruns): irun = 0 h_stor = [ 0.0 for k in range (nrun)] while irun < nrun: L = len (u) h_old = hamiltonian(u) n = pick_random_particle() ov = u[n] du = random . uniform( - dv,dv) u[n] = u[n] + du h_new = hamiltonian(u) dh = 0.5 * m * (u[n] ** 2 - ov ** 2 ) if dh < 0 : h_stor[irun] = h_new else : frac = math . exp( - dh / (Kb * T)) b = random . uniform( 0.0 , 1.0 ) if b < frac: h_stor[irun] = h_new else : u[n] = u[n] - du h_stor[irun] = h_old if u[n] != ov : irun = irun + 1 return h_stor,u Simulation Test N = 10 u = starter( 1 ) T = 300.0 nrun = 100 H,u = thermalize(u,T,nrun) N = 1000 u = starter( 1 ) T = 300.0 nrun = 10000 H,u = thermalize(u,T,nrun) X = np . arange( 0 , len (H), 1 ) plt . figure(figsize = [ 15 , 4 ]) plt . grid( True ) plt . plot(X,H, \"-\" ) plt . show() Speed Distribution num_bins = 20 plt . figure(figsize = [ 10 , 8 ]) plt . hist(u,num_bins, density = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . grid( True ) plt . show() num_bins = 100 plt . figure(figsize = [ 10 , 8 ]) plt . hist(u,num_bins, density = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . grid( True ) plt . show()","title":"Ideal Gas"},{"location":"Montecarlo/IdealGas/IdealGas/#maxwells-distribution-of-speed","text":"","title":"Maxwell's distribution of speed."},{"location":"Montecarlo/IdealGas/IdealGas/#import","text":"import math as math import random as random import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns . set()","title":"Import"},{"location":"Montecarlo/IdealGas/IdealGas/#global-constants","text":"m = 3.2 # mass is in unit of Kb Kb = 1.0","title":"Global constants"},{"location":"Montecarlo/IdealGas/IdealGas/#input-parameters","text":"N = 100 u0 = 150.00 dv = 0.01","title":"Input parameters"},{"location":"Montecarlo/IdealGas/IdealGas/#starter","text":"def starter (key): u = [ 0.0 for k in range (N)] if key == 0 : return u else : for k in range (N): u[k] = u0 return u","title":"Starter"},{"location":"Montecarlo/IdealGas/IdealGas/#hamiltonian","text":"def hamiltonian (u): H = 0.0 for k in range (N): H = H + 0.5 * u[k] ** 2 return H","title":"Hamiltonian"},{"location":"Montecarlo/IdealGas/IdealGas/#pick-a-particle-and-change","text":"def pick_random_particle (): n = random . randint( 0 , N - 1 ) return n","title":"Pick a particle and change"},{"location":"Montecarlo/IdealGas/IdealGas/#thermalization","text":"def thermalize (u,T,nruns): irun = 0 h_stor = [ 0.0 for k in range (nrun)] while irun < nrun: L = len (u) h_old = hamiltonian(u) n = pick_random_particle() ov = u[n] du = random . uniform( - dv,dv) u[n] = u[n] + du h_new = hamiltonian(u) dh = 0.5 * m * (u[n] ** 2 - ov ** 2 ) if dh < 0 : h_stor[irun] = h_new else : frac = math . exp( - dh / (Kb * T)) b = random . uniform( 0.0 , 1.0 ) if b < frac: h_stor[irun] = h_new else : u[n] = u[n] - du h_stor[irun] = h_old if u[n] != ov : irun = irun + 1 return h_stor,u","title":"Thermalization"},{"location":"Montecarlo/IdealGas/IdealGas/#simulation","text":"","title":"Simulation"},{"location":"Montecarlo/IdealGas/IdealGas/#test","text":"N = 10 u = starter( 1 ) T = 300.0 nrun = 100 H,u = thermalize(u,T,nrun) N = 1000 u = starter( 1 ) T = 300.0 nrun = 10000 H,u = thermalize(u,T,nrun) X = np . arange( 0 , len (H), 1 ) plt . figure(figsize = [ 15 , 4 ]) plt . grid( True ) plt . plot(X,H, \"-\" ) plt . show()","title":"Test"},{"location":"Montecarlo/IdealGas/IdealGas/#speed-distribution","text":"num_bins = 20 plt . figure(figsize = [ 10 , 8 ]) plt . hist(u,num_bins, density = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . grid( True ) plt . show() num_bins = 100 plt . figure(figsize = [ 10 , 8 ]) plt . hist(u,num_bins, density = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . grid( True ) plt . show()","title":"Speed Distribution"},{"location":"Montecarlo/IzingModel/Izing2D/","text":"Ising Model - 2D : Monte Carlo Simulation First of all we import the required libraries: import matplotlib.pyplot as plt import math as math import random as random import pylab as pylab import numpy as np import seaborn as sns sns . set() Global parameters Then we set some global variables: Kb = 1.0 JJ = 1.0 Cold Start and Hot Start Before begining simulation, if we select all spin up or all spin down then it is called cold configuration. def cold_start (L): U = [[ 1.0 for k in range (L)] for l in range (L)] return U We can make a plot of this cold configuration by the help of Uplotter : CU = cold_start( 10 ) sns . heatmap(CU,annot = True ) plt . axis( False ) (0.0, 10.0, 10.0, 0.0) if we select spin randomly up or down then it is called cold configuration def hot_start (L): U = [[ 0.0 for i in range (L)] for j in range (L)] for i in range (L): for j in range (L): t = random . sample([ - 1 , 1 ], 1 ) U[i][j] = t[ 0 ] return U Similarly we can plot thishot configuration as well. HU = hot_start( 10 ) sns . heatmap(HU,annot = True ) plt . axis( False ) (0.0, 10.0, 10.0, 0.0) Hamiltonian Hamiltonian of L by L lattice is given by \\( H = - J \\sum_{i\\neq j} S_{i}S_{j} \\) def Hamiltonian (U): H = 0.0 L = len (U) for i in range (L): for j in range (L): ni = 0 ;nj = 0 ; if i == 0 : ni = L if j == 0 : nj = L H = H - 0.5 * JJ * U[i][j] * (U[i][(j - 1 ) + nj] \\ + U[(i + 1 ) % L][j] \\ + U[i][(j + 1 ) % L] \\ + U[(i - 1 ) + ni][j]) return H One can check what are hamiltonian for hot and cold start: Hamiltonian(CU) -200.0 Hamiltonian(HU) 12.0 Mangnetization One can calculate magnetization by simply taking average over all spins: def magnetization (U): return np . array(U) . sum() / float ( len (U * len (U))) magnetization(HU) 0.04 magnetization(CU) 1.0 Spin Flipper def ld (k,L): if k == 0 : return L else : return 0 def spin_flipper (U,printkey): L = len (U) i = random . randint( 0 , L - 1 ) j = random . randint( 0 , L - 1 ) if printkey == 1 : print ( \"flipped at\" , i,j) U[i][j] = - U[i][j] dH = - 2.0 * JJ * U[i][j] * (U[i][(j - 1 ) + ld(j,L)] \\ + U[(i + 1 ) % L][j] \\ + U[i][(j + 1 ) % L] \\ + U[(i - 1 ) + ld(i,L)][j]) return U,dH,i,j Thermalization def Thermalization (U,T,nrun,printkey) : M = [ 0.0 for k in range (nrun)] irun = 0 while irun < nrun: V = U w = magnetization(U) U,dH,p,q = spin_flipper(U,printkey) if dH < 0 : if printkey == 1 : print (irun, \"E decreased! You are accepted !\" ,dH) M[irun] = magnetization(U) else : if printkey == 1 : print (irun, \"E increased!\" ,dH) frac = math . exp( - dH / (Kb * T)) b = random . uniform( 0.0 , 1.0 ) if printkey == 1 : print ( \"frac =\" ,frac, \"b=\" ,b, \"dH = \" ,dH) if b < frac: if printkey == 1 : print (irun, \" You Lucky!\" ) M[irun] = magnetization(U) else : if printkey == 1 : print (irun, \"Loser!\" ) if printkey == 1 : print ( \"spin restablished at\" ,p,q) U[p][q] = - U[p][q] M[irun] = w for i in range (L): for j in range (L): if U[i][j] != V[i][i]: if printkey == 1 : print ( \"Warning!spin is changed!\" , i,j) if printkey == 2 : print (irun, M[irun]) irun = irun + 1 return M,U Lets print out some measurements of m nrun = 20 T = 1.0 L = 10 U = cold_start(L) M,U = Thermalization(U,T,nrun, 1 ) flipped at 6 1 0 E increased! 8.0 frac = 0.00033546262790251185 b= 0.5671077259055917 dH = 8.0 0 Loser! spin restablished at 6 1 flipped at 5 2 1 E increased! 8.0 frac = 0.00033546262790251185 b= 0.3231620080611951 dH = 8.0 1 Loser! spin restablished at 5 2 flipped at 7 1 2 E increased! 8.0 frac = 0.00033546262790251185 b= 0.11202501799113995 dH = 8.0 2 Loser! spin restablished at 7 1 flipped at 5 1 3 E increased! 8.0 frac = 0.00033546262790251185 b= 0.9403656345766181 dH = 8.0 3 Loser! spin restablished at 5 1 flipped at 0 0 4 E increased! 8.0 frac = 0.00033546262790251185 b= 0.14218890326015643 dH = 8.0 4 Loser! spin restablished at 0 0 flipped at 5 0 5 E increased! 8.0 frac = 0.00033546262790251185 b= 0.0963025212725882 dH = 8.0 5 Loser! spin restablished at 5 0 flipped at 0 8 6 E increased! 8.0 frac = 0.00033546262790251185 b= 0.565791348883872 dH = 8.0 6 Loser! spin restablished at 0 8 flipped at 3 7 7 E increased! 8.0 frac = 0.00033546262790251185 b= 0.3387910454379671 dH = 8.0 7 Loser! spin restablished at 3 7 flipped at 9 1 8 E increased! 8.0 frac = 0.00033546262790251185 b= 0.1936472524177364 dH = 8.0 8 Loser! spin restablished at 9 1 flipped at 7 0 9 E increased! 8.0 frac = 0.00033546262790251185 b= 0.24948905296269597 dH = 8.0 9 Loser! spin restablished at 7 0 flipped at 6 7 10 E increased! 8.0 frac = 0.00033546262790251185 b= 0.518899292783646 dH = 8.0 10 Loser! spin restablished at 6 7 flipped at 8 1 11 E increased! 8.0 frac = 0.00033546262790251185 b= 0.13159925938392314 dH = 8.0 11 Loser! spin restablished at 8 1 flipped at 5 4 12 E increased! 8.0 frac = 0.00033546262790251185 b= 0.11321720447730321 dH = 8.0 12 Loser! spin restablished at 5 4 flipped at 2 5 13 E increased! 8.0 frac = 0.00033546262790251185 b= 0.9225608625932972 dH = 8.0 13 Loser! spin restablished at 2 5 flipped at 4 5 14 E increased! 8.0 frac = 0.00033546262790251185 b= 0.31039416582757795 dH = 8.0 14 Loser! spin restablished at 4 5 flipped at 9 2 15 E increased! 8.0 frac = 0.00033546262790251185 b= 0.8360880711041137 dH = 8.0 15 Loser! spin restablished at 9 2 flipped at 9 8 16 E increased! 8.0 frac = 0.00033546262790251185 b= 0.26428473982836087 dH = 8.0 16 Loser! spin restablished at 9 8 flipped at 7 2 17 E increased! 8.0 frac = 0.00033546262790251185 b= 0.3292714399864062 dH = 8.0 17 Loser! spin restablished at 7 2 flipped at 1 4 18 E increased! 8.0 frac = 0.00033546262790251185 b= 0.1478523271555081 dH = 8.0 18 Loser! spin restablished at 1 4 flipped at 1 3 19 E increased! 8.0 frac = 0.00033546262790251185 b= 0.2466252577141801 dH = 8.0 19 Loser! spin restablished at 1 3 L = 20 nrun = 10000 T = 2.4 U = cold_start(L) M,U = Thermalization(U,T,nrun, 0 ) X = np . arange( 0 , len (M), 1 ) plt . figure(figsize = [ 15 , 6 ]) plt . plot(X,M, \"-\" ) plt . show() We can plot both run with hot and cold start together: L = 20 nrun = 10000 T = 5.0 U1 = cold_start(L) U2 = hot_start(L) M1,U1 = Thermalization(U1,T,nrun, 0 ) M2,U2 = Thermalization(U2,T,nrun, 0 ) X = np . arange( 0 , len (M1), 1 ) plt . figure(figsize = [ 15 , 6 ]) plt . plot(X,M1, \"-\" ) plt . plot(X,M2, \"-\" ) plt . show() Phase Transition L = 32 nrun = 10000 Tn = 100 avm = [] KT = [] for t in range ( 1 ,Tn + 1 ): T = 0.1 * t KT . append(T) U = cold_start(L) M,U = Thermalization(U,T,nrun, 0 ) nM = M[ 1000 :nrun - 1 ] avm . append(np . mean(nM)) plt . figure(figsize = [ 10 , 8 ]) plt . scatter(KT,avm) plt . xlabel( \"Temperature\" ) plt . ylabel( \"Average magnetization\" ) plt . show()","title":"Ising Model"},{"location":"Montecarlo/IzingModel/Izing2D/#ising-model-2d-monte-carlo-simulation","text":"First of all we import the required libraries: import matplotlib.pyplot as plt import math as math import random as random import pylab as pylab import numpy as np import seaborn as sns sns . set()","title":"Ising Model - 2D : Monte Carlo Simulation"},{"location":"Montecarlo/IzingModel/Izing2D/#global-parameters","text":"Then we set some global variables: Kb = 1.0 JJ = 1.0","title":"Global parameters"},{"location":"Montecarlo/IzingModel/Izing2D/#cold-start-and-hot-start","text":"Before begining simulation, if we select all spin up or all spin down then it is called cold configuration. def cold_start (L): U = [[ 1.0 for k in range (L)] for l in range (L)] return U We can make a plot of this cold configuration by the help of Uplotter : CU = cold_start( 10 ) sns . heatmap(CU,annot = True ) plt . axis( False ) (0.0, 10.0, 10.0, 0.0) if we select spin randomly up or down then it is called cold configuration def hot_start (L): U = [[ 0.0 for i in range (L)] for j in range (L)] for i in range (L): for j in range (L): t = random . sample([ - 1 , 1 ], 1 ) U[i][j] = t[ 0 ] return U Similarly we can plot thishot configuration as well. HU = hot_start( 10 ) sns . heatmap(HU,annot = True ) plt . axis( False ) (0.0, 10.0, 10.0, 0.0)","title":"Cold Start and Hot Start"},{"location":"Montecarlo/IzingModel/Izing2D/#hamiltonian","text":"Hamiltonian of L by L lattice is given by \\( H = - J \\sum_{i\\neq j} S_{i}S_{j} \\) def Hamiltonian (U): H = 0.0 L = len (U) for i in range (L): for j in range (L): ni = 0 ;nj = 0 ; if i == 0 : ni = L if j == 0 : nj = L H = H - 0.5 * JJ * U[i][j] * (U[i][(j - 1 ) + nj] \\ + U[(i + 1 ) % L][j] \\ + U[i][(j + 1 ) % L] \\ + U[(i - 1 ) + ni][j]) return H One can check what are hamiltonian for hot and cold start: Hamiltonian(CU) -200.0 Hamiltonian(HU) 12.0","title":"Hamiltonian"},{"location":"Montecarlo/IzingModel/Izing2D/#mangnetization","text":"One can calculate magnetization by simply taking average over all spins: def magnetization (U): return np . array(U) . sum() / float ( len (U * len (U))) magnetization(HU) 0.04 magnetization(CU) 1.0","title":"Mangnetization"},{"location":"Montecarlo/IzingModel/Izing2D/#spin-flipper","text":"def ld (k,L): if k == 0 : return L else : return 0 def spin_flipper (U,printkey): L = len (U) i = random . randint( 0 , L - 1 ) j = random . randint( 0 , L - 1 ) if printkey == 1 : print ( \"flipped at\" , i,j) U[i][j] = - U[i][j] dH = - 2.0 * JJ * U[i][j] * (U[i][(j - 1 ) + ld(j,L)] \\ + U[(i + 1 ) % L][j] \\ + U[i][(j + 1 ) % L] \\ + U[(i - 1 ) + ld(i,L)][j]) return U,dH,i,j","title":"Spin Flipper"},{"location":"Montecarlo/IzingModel/Izing2D/#thermalization","text":"def Thermalization (U,T,nrun,printkey) : M = [ 0.0 for k in range (nrun)] irun = 0 while irun < nrun: V = U w = magnetization(U) U,dH,p,q = spin_flipper(U,printkey) if dH < 0 : if printkey == 1 : print (irun, \"E decreased! You are accepted !\" ,dH) M[irun] = magnetization(U) else : if printkey == 1 : print (irun, \"E increased!\" ,dH) frac = math . exp( - dH / (Kb * T)) b = random . uniform( 0.0 , 1.0 ) if printkey == 1 : print ( \"frac =\" ,frac, \"b=\" ,b, \"dH = \" ,dH) if b < frac: if printkey == 1 : print (irun, \" You Lucky!\" ) M[irun] = magnetization(U) else : if printkey == 1 : print (irun, \"Loser!\" ) if printkey == 1 : print ( \"spin restablished at\" ,p,q) U[p][q] = - U[p][q] M[irun] = w for i in range (L): for j in range (L): if U[i][j] != V[i][i]: if printkey == 1 : print ( \"Warning!spin is changed!\" , i,j) if printkey == 2 : print (irun, M[irun]) irun = irun + 1 return M,U Lets print out some measurements of m nrun = 20 T = 1.0 L = 10 U = cold_start(L) M,U = Thermalization(U,T,nrun, 1 ) flipped at 6 1 0 E increased! 8.0 frac = 0.00033546262790251185 b= 0.5671077259055917 dH = 8.0 0 Loser! spin restablished at 6 1 flipped at 5 2 1 E increased! 8.0 frac = 0.00033546262790251185 b= 0.3231620080611951 dH = 8.0 1 Loser! spin restablished at 5 2 flipped at 7 1 2 E increased! 8.0 frac = 0.00033546262790251185 b= 0.11202501799113995 dH = 8.0 2 Loser! spin restablished at 7 1 flipped at 5 1 3 E increased! 8.0 frac = 0.00033546262790251185 b= 0.9403656345766181 dH = 8.0 3 Loser! spin restablished at 5 1 flipped at 0 0 4 E increased! 8.0 frac = 0.00033546262790251185 b= 0.14218890326015643 dH = 8.0 4 Loser! spin restablished at 0 0 flipped at 5 0 5 E increased! 8.0 frac = 0.00033546262790251185 b= 0.0963025212725882 dH = 8.0 5 Loser! spin restablished at 5 0 flipped at 0 8 6 E increased! 8.0 frac = 0.00033546262790251185 b= 0.565791348883872 dH = 8.0 6 Loser! spin restablished at 0 8 flipped at 3 7 7 E increased! 8.0 frac = 0.00033546262790251185 b= 0.3387910454379671 dH = 8.0 7 Loser! spin restablished at 3 7 flipped at 9 1 8 E increased! 8.0 frac = 0.00033546262790251185 b= 0.1936472524177364 dH = 8.0 8 Loser! spin restablished at 9 1 flipped at 7 0 9 E increased! 8.0 frac = 0.00033546262790251185 b= 0.24948905296269597 dH = 8.0 9 Loser! spin restablished at 7 0 flipped at 6 7 10 E increased! 8.0 frac = 0.00033546262790251185 b= 0.518899292783646 dH = 8.0 10 Loser! spin restablished at 6 7 flipped at 8 1 11 E increased! 8.0 frac = 0.00033546262790251185 b= 0.13159925938392314 dH = 8.0 11 Loser! spin restablished at 8 1 flipped at 5 4 12 E increased! 8.0 frac = 0.00033546262790251185 b= 0.11321720447730321 dH = 8.0 12 Loser! spin restablished at 5 4 flipped at 2 5 13 E increased! 8.0 frac = 0.00033546262790251185 b= 0.9225608625932972 dH = 8.0 13 Loser! spin restablished at 2 5 flipped at 4 5 14 E increased! 8.0 frac = 0.00033546262790251185 b= 0.31039416582757795 dH = 8.0 14 Loser! spin restablished at 4 5 flipped at 9 2 15 E increased! 8.0 frac = 0.00033546262790251185 b= 0.8360880711041137 dH = 8.0 15 Loser! spin restablished at 9 2 flipped at 9 8 16 E increased! 8.0 frac = 0.00033546262790251185 b= 0.26428473982836087 dH = 8.0 16 Loser! spin restablished at 9 8 flipped at 7 2 17 E increased! 8.0 frac = 0.00033546262790251185 b= 0.3292714399864062 dH = 8.0 17 Loser! spin restablished at 7 2 flipped at 1 4 18 E increased! 8.0 frac = 0.00033546262790251185 b= 0.1478523271555081 dH = 8.0 18 Loser! spin restablished at 1 4 flipped at 1 3 19 E increased! 8.0 frac = 0.00033546262790251185 b= 0.2466252577141801 dH = 8.0 19 Loser! spin restablished at 1 3 L = 20 nrun = 10000 T = 2.4 U = cold_start(L) M,U = Thermalization(U,T,nrun, 0 ) X = np . arange( 0 , len (M), 1 ) plt . figure(figsize = [ 15 , 6 ]) plt . plot(X,M, \"-\" ) plt . show() We can plot both run with hot and cold start together: L = 20 nrun = 10000 T = 5.0 U1 = cold_start(L) U2 = hot_start(L) M1,U1 = Thermalization(U1,T,nrun, 0 ) M2,U2 = Thermalization(U2,T,nrun, 0 ) X = np . arange( 0 , len (M1), 1 ) plt . figure(figsize = [ 15 , 6 ]) plt . plot(X,M1, \"-\" ) plt . plot(X,M2, \"-\" ) plt . show()","title":"Thermalization"},{"location":"Montecarlo/IzingModel/Izing2D/#phase-transition","text":"L = 32 nrun = 10000 Tn = 100 avm = [] KT = [] for t in range ( 1 ,Tn + 1 ): T = 0.1 * t KT . append(T) U = cold_start(L) M,U = Thermalization(U,T,nrun, 0 ) nM = M[ 1000 :nrun - 1 ] avm . append(np . mean(nM)) plt . figure(figsize = [ 10 , 8 ]) plt . scatter(KT,avm) plt . xlabel( \"Temperature\" ) plt . ylabel( \"Average magnetization\" ) plt . show()","title":"Phase Transition"},{"location":"Montecarlo/Levy/levy/","text":"Levy Quantum Path Continuous Random Walk % matplotlib inline import math , random beta = 4.0 N = 8 sigma = math . sqrt(beta / N) x = [ 0.0 ] for k in range (N - 1 ): x . append(random . gauss(x[ - 1 ], sigma)) print x [0.0, 1.01509231498381, 0.8954574749069657, 0.4475173962954569, -0.6617069586993383, -0.38473534012694194, -0.6521628289908354, -1.550921896951777] Trivial Free Path import math , random beta = 1.0 N = 8 sigma = math . sqrt(beta / N) xend = 1.0 Upsilon = [ 0.0 ] for k in range (N): Upsilon . append(random . gauss(Upsilon[ - 1 ], sigma)) x = [ 0.0 ] + [Upsilon[k] + (xend - Upsilon[ - 1 ]) * \\ k / float (N) for k in range ( 1 , N + 1 )] print x [0.0, 0.16650886545595994, 0.6100876683233167, 1.2878936165304946, 1.522730604023694, 1.8655448259378942, 1.8779816089586798, 1.4174193447820458, 1.0] Levy Free Path import math , random beta = 1.0 N = 4 dtau = beta / N nsteps = 10 # number of paths to be generated xstart, xend = 0.0 , 1.0 # initial and final points for step in range (nsteps): x = [xstart] for k in range ( 1 , N): # loop over internal slices dtau_prime = (N - k) * dtau x_mean = (dtau_prime * x[k - 1 ] + dtau * xend) / \\ (dtau + dtau_prime) sigma = math . sqrt( 1.0 / ( 1.0 / dtau + 1.0 / dtau_prime)) x . append(random . gauss(x_mean, sigma)) x . append(xend) print x [0.0, 0.5707795321525617, 0.5866019527578654, 0.8089609595648815, 1.0] [0.0, -0.3396754967087857, 0.7235057663520837, 1.1315669585984993, 1.0] [0.0, 0.018063918143963353, 0.16434572728171748, 0.592993315765318, 1.0] [0.0, 0.2246140968885552, 0.966182738296046, 0.746201579459617, 1.0] [0.0, -0.23985854999079953, -0.23870459469931876, 0.14380281472001558, 1.0] [0.0, 0.15962908547527493, 1.137840942610433, 1.3625924641454001, 1.0] [0.0, -1.1579809269318322, -1.0786715345985927, 0.4854709061903433, 1.0] [0.0, 0.1404369341832184, 0.4541880825433704, 0.8673479702904441, 1.0] [0.0, 0.7425438080805121, 0.8693731794283786, 1.3336622912118516, 1.0] [0.0, 0.12440416711297678, 0.2510353241093216, 1.1245847853705508, 1.0] Naive Harmonic Path import math , random def rho_free (x, y, beta): # free off-diagonal density matrix return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) beta = 4.0 N = 8 # number of slices dtau = beta / N delta = 1.0 # maximum displacement of one bead n_steps = 20 # number of Monte Carlo steps x = [ 0.0 ] * N # initial path for step in xrange(n_steps): k = random . randint( 0 , N - 1 ) # random slice knext, kprev = (k + 1 ) % N, (k - 1 ) % N # next/previous slices x_new = x[k] + random . uniform( - delta, delta) # new position at slice k old_weight = (rho_free(x[knext], x[k], dtau) * rho_free(x[k], x[kprev], dtau) * math . exp( - 0.5 * dtau * x[k] ** 2 )) new_weight = (rho_free(x[knext], x_new, dtau) * rho_free(x_new, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_new ** 2 )) if random . random() < new_weight / old_weight: x[k] = x_new print x [0.0, 0.28998171631723735, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] [0.0, 0.28998171631723735, -0.4471023666935825, 0.0, 0.0, 0.0, 0.0, 0.0] [0.0, 0.28998171631723735, -0.4471023666935825, 0.0, -0.6140259897130926, 0.0, 0.0, 0.0] [0.0, 0.28998171631723735, -0.4471023666935825, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, 0.0] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, 0.0] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, 0.0] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, -0.5351955742208034, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, -0.5351955742208034, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.4700080333224783, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.4700080333224783, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] Naive Path Slice import math , random def rho_free (x, y, beta): return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) dtau_prime = 0.1 dtau_dprime = 0.2 x_prime = 0.0 x_dprime = 1.0 delta = 1.0 n_steps = 10 xk = 0.0 for step in xrange(n_steps): xk_new = xk + random . uniform( - delta, delta) old_weight = (rho_free(x_dprime, xk, dtau_dprime) * rho_free(xk, x_prime, dtau_prime)) new_weight = (rho_free(x_dprime, xk_new, dtau_dprime) * rho_free(xk_new, x_prime, dtau_prime)) if random . random() < new_weight / old_weight: xk = xk_new print xk 0.095401252446 0.095401252446 0.512795106019 0.512795106019 0.512795106019 0.512795106019 0.512795106019 0.512795106019 0.901968228505 0.901968228505 Naive Path Slice Movie import math , random , pylab def rho_free (x, y, beta): return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) dtau_prime = 0.1 dtau_dprime = 0.2 x_prime = 0.0 x_dprime = 1.0 delta = 1.0 # maximum displacement of xk n_steps = 1000 # number of Monte Carlo steps data_hist = [] xk = 0.0 # initial value of xk for step in xrange(n_steps): xk_new = xk + random . uniform( - delta, delta) old_weight = (rho_free(x_dprime, xk, dtau_dprime) * rho_free(xk, x_prime, dtau_prime)) new_weight = (rho_free(x_dprime, xk_new, dtau_dprime) * rho_free(xk_new, x_prime, dtau_prime)) if random . random() < new_weight / old_weight: xk = xk_new data_hist . append(xk) def pi_analytic (xk, x_prime, x_dprime, dtau_prime, dtau_dprime): mean = (dtau_dprime * x_prime + dtau_prime * x_dprime) / (dtau_prime + dtau_dprime) sigma = 1.0 / math . sqrt( 1.0 / dtau_prime + 1.0 / dtau_dprime) return math . exp( - (xk - mean) ** 2 / ( 2.0 * sigma ** 2 )) / math . sqrt( 2.0 * math . pi) / sigma pylab . title( 'Distribution on slice k' , fontsize = 18 ) histo, bin_edges, dummy = pylab . hist(data_hist, bins = 100 , normed = True ) bin_centers = 0.5 * (bin_edges[ 1 :] + bin_edges[: - 1 ]) pylab . plot(bin_centers, [pi_analytic(x, x_prime, x_dprime, dtau_prime, dtau_dprime) for x in bin_centers], 'r-' , lw = 3 ) pylab . xlabel( '$x_k$' , fontsize = 18 ) pylab . ylabel( '$\\pi(x_k)$' , fontsize = 18 ) #pylab.savefig('plot-path_slice.png') pylab . show() Levy Harmonic Path import math , random beta = 1.0 N = 4 dtau = beta / N xstart, xend = 0.0 , 1.0 x = [xstart] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Ups1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Ups2 = x[k - 1 ] / math . sinh(dtau) + \\ xend / math . sinh(dtau_prime) x . append(random . gauss(Ups2 / Ups1, \\ 1.0 / math . sqrt(Ups1))) x . append(xend) print x [0.0, -0.3585400331470993, -0.46657041443239394, 0.01352956236855482, 1.0] Levy Harmonic Path 3D import math , random def levy_harmonic_1d (start, end, dtau): x = [start] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Ups1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Ups2 = x[k - 1 ] / math . sinh(dtau) + \\ end / math . sinh(dtau_prime) x . append(random . gauss(Ups2 / Ups1, \\ 1.0 / math . sqrt(Ups1))) x . append(end) return x beta = 1.0 N = 20 dtau = beta / float (N) [xstart, ystart, zstart] = [ 1.0 , - 2.0 , 1.5 ] [xend, yend, zend] = [ - 2.5 , 0.0 , - 0.5 ] x = levy_harmonic_1d(xstart, xend, dtau) y = levy_harmonic_1d(ystart, yend, dtau) z = levy_harmonic_1d(zstart, zend, dtau) for i in range (N + 1 ): print 'slice %2i : ' % i, x[i], y[i], z[i] slice 0: 1.0 -2.0 1.5 slice 1: 0.777748893943 -2.10539607648 1.73826482099 slice 2: 0.763931019379 -2.14387236587 1.54684977036 slice 3: 0.500747263585 -2.08049210773 1.58757506994 slice 4: 0.429361380948 -1.98193292492 1.51647256244 slice 5: 0.156144949185 -2.08472795151 1.24115678993 slice 6: -0.301482536938 -2.31425875183 1.2116215967 slice 7: -0.114110853331 -2.01170186332 1.31953455601 slice 8: -0.495169243534 -1.78954410128 1.26715746611 slice 9: -1.07124864136 -1.84323749154 1.22618560998 slice 10: -1.02146009154 -1.4469573166 1.12287349028 slice 11: -1.2202731479 -1.25130592701 1.17356480665 slice 12: -1.44734039796 -0.769759958407 0.871271945556 slice 13: -1.59945389072 -0.917060277419 0.950203408728 slice 14: -1.59348122639 -0.750802821523 0.624546501494 slice 15: -1.79081758311 -0.666414256381 0.444743391328 slice 16: -1.99247299059 -0.44958639971 0.362047069815 slice 17: -1.75822763813 -0.389265378081 0.0467617492471 slice 18: -2.35917386101 -0.396104505937 0.367460418148 slice 19: -2.39839736996 -0.0739252507074 -0.239433962495 slice 20: -2.5 0.0 -0.5 Levy Harmonic Path Movie import math , random , pylab beta = 2.0 N = 10 dtau = beta / N nsteps = 5 xstart, xend = 2.0 , 1.0 for step in range (nsteps): x = [xstart] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Ups1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Ups2 = x[k - 1 ] / math . sinh(dtau) + \\ xend / math . sinh(dtau_prime) x . append(random . gauss(Ups2 / Ups1, \\ 1.0 / math . sqrt(Ups1))) x . append(xend) # graphics pylab . plot(x, [j * dtau for j in range (N + 1 )], 'bo-' ) pylab . xlabel( '$x$' , fontsize = 18 ) pylab . ylabel( '$ \\\\ tau$' , fontsize = 18 ) pylab . title( 'Harmonic path %i ' % step) pylab . xlim( - 2.0 , 4.0 ) pylab . show() #pylab.close() TUTORIAL Naive Single Particle Emax = 5 States = [] for E_x in range (Emax): for E_y in range (Emax): for E_z in range (Emax): States . append(((E_x + E_y + E_z), (E_x, E_y, E_z))) States . sort() for k in range ( 5 ): print ' %3d ' % k, States[k][ 0 ], States[k][ 1 ] 0 0 (0, 0, 0) 1 1 (0, 0, 1) 2 1 (0, 1, 0) 3 1 (1, 0, 0) 4 2 (0, 0, 2) Naive Boson Trap import math Energy = [ 0.0 ] + [ 1.0 ] * 3 + [ 2.0 ] * 6 + [ 3.0 ] * 10 + [ 4.0 ] * 15 beta = 1.0 n_states = 0 Z = 0.0 N0_mean = 0.0 E_mean = 0.0 for s_0 in range ( 35 ): for s_1 in range (s_0, 35 ): for s_2 in range (s_1, 35 ): for s_3 in range (s_2, 35 ): for s_4 in range (s_3, 35 ): n_states += 1 state = [s_0, s_1, s_2, s_3, s_4] E = sum (Energy[s] for s in state) Z += math . exp( - beta * E) E_mean += E * math . exp( - beta * E) N0_mean += state . count( 0 ) * \\ math . exp( - beta * E) print n_states, Z, E_mean / Z / 5.0 , N0_mean / Z / 5.0 575757 17.3732972183 1.03133265311 0.446969501933","title":"Quantum Monte Carlo"},{"location":"Montecarlo/Levy/levy/#levy-quantum-path","text":"Continuous Random Walk % matplotlib inline import math , random beta = 4.0 N = 8 sigma = math . sqrt(beta / N) x = [ 0.0 ] for k in range (N - 1 ): x . append(random . gauss(x[ - 1 ], sigma)) print x [0.0, 1.01509231498381, 0.8954574749069657, 0.4475173962954569, -0.6617069586993383, -0.38473534012694194, -0.6521628289908354, -1.550921896951777] Trivial Free Path import math , random beta = 1.0 N = 8 sigma = math . sqrt(beta / N) xend = 1.0 Upsilon = [ 0.0 ] for k in range (N): Upsilon . append(random . gauss(Upsilon[ - 1 ], sigma)) x = [ 0.0 ] + [Upsilon[k] + (xend - Upsilon[ - 1 ]) * \\ k / float (N) for k in range ( 1 , N + 1 )] print x [0.0, 0.16650886545595994, 0.6100876683233167, 1.2878936165304946, 1.522730604023694, 1.8655448259378942, 1.8779816089586798, 1.4174193447820458, 1.0] Levy Free Path import math , random beta = 1.0 N = 4 dtau = beta / N nsteps = 10 # number of paths to be generated xstart, xend = 0.0 , 1.0 # initial and final points for step in range (nsteps): x = [xstart] for k in range ( 1 , N): # loop over internal slices dtau_prime = (N - k) * dtau x_mean = (dtau_prime * x[k - 1 ] + dtau * xend) / \\ (dtau + dtau_prime) sigma = math . sqrt( 1.0 / ( 1.0 / dtau + 1.0 / dtau_prime)) x . append(random . gauss(x_mean, sigma)) x . append(xend) print x [0.0, 0.5707795321525617, 0.5866019527578654, 0.8089609595648815, 1.0] [0.0, -0.3396754967087857, 0.7235057663520837, 1.1315669585984993, 1.0] [0.0, 0.018063918143963353, 0.16434572728171748, 0.592993315765318, 1.0] [0.0, 0.2246140968885552, 0.966182738296046, 0.746201579459617, 1.0] [0.0, -0.23985854999079953, -0.23870459469931876, 0.14380281472001558, 1.0] [0.0, 0.15962908547527493, 1.137840942610433, 1.3625924641454001, 1.0] [0.0, -1.1579809269318322, -1.0786715345985927, 0.4854709061903433, 1.0] [0.0, 0.1404369341832184, 0.4541880825433704, 0.8673479702904441, 1.0] [0.0, 0.7425438080805121, 0.8693731794283786, 1.3336622912118516, 1.0] [0.0, 0.12440416711297678, 0.2510353241093216, 1.1245847853705508, 1.0] Naive Harmonic Path import math , random def rho_free (x, y, beta): # free off-diagonal density matrix return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) beta = 4.0 N = 8 # number of slices dtau = beta / N delta = 1.0 # maximum displacement of one bead n_steps = 20 # number of Monte Carlo steps x = [ 0.0 ] * N # initial path for step in xrange(n_steps): k = random . randint( 0 , N - 1 ) # random slice knext, kprev = (k + 1 ) % N, (k - 1 ) % N # next/previous slices x_new = x[k] + random . uniform( - delta, delta) # new position at slice k old_weight = (rho_free(x[knext], x[k], dtau) * rho_free(x[k], x[kprev], dtau) * math . exp( - 0.5 * dtau * x[k] ** 2 )) new_weight = (rho_free(x[knext], x_new, dtau) * rho_free(x_new, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_new ** 2 )) if random . random() < new_weight / old_weight: x[k] = x_new print x [0.0, 0.28998171631723735, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] [0.0, 0.28998171631723735, -0.4471023666935825, 0.0, 0.0, 0.0, 0.0, 0.0] [0.0, 0.28998171631723735, -0.4471023666935825, 0.0, -0.6140259897130926, 0.0, 0.0, 0.0] [0.0, 0.28998171631723735, -0.4471023666935825, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, 0.0] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, 0.0] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, 0.0] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, -0.5351955742208034, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, -0.5351955742208034, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.4700080333224783, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.4700080333224783, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] Naive Path Slice import math , random def rho_free (x, y, beta): return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) dtau_prime = 0.1 dtau_dprime = 0.2 x_prime = 0.0 x_dprime = 1.0 delta = 1.0 n_steps = 10 xk = 0.0 for step in xrange(n_steps): xk_new = xk + random . uniform( - delta, delta) old_weight = (rho_free(x_dprime, xk, dtau_dprime) * rho_free(xk, x_prime, dtau_prime)) new_weight = (rho_free(x_dprime, xk_new, dtau_dprime) * rho_free(xk_new, x_prime, dtau_prime)) if random . random() < new_weight / old_weight: xk = xk_new print xk 0.095401252446 0.095401252446 0.512795106019 0.512795106019 0.512795106019 0.512795106019 0.512795106019 0.512795106019 0.901968228505 0.901968228505 Naive Path Slice Movie import math , random , pylab def rho_free (x, y, beta): return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) dtau_prime = 0.1 dtau_dprime = 0.2 x_prime = 0.0 x_dprime = 1.0 delta = 1.0 # maximum displacement of xk n_steps = 1000 # number of Monte Carlo steps data_hist = [] xk = 0.0 # initial value of xk for step in xrange(n_steps): xk_new = xk + random . uniform( - delta, delta) old_weight = (rho_free(x_dprime, xk, dtau_dprime) * rho_free(xk, x_prime, dtau_prime)) new_weight = (rho_free(x_dprime, xk_new, dtau_dprime) * rho_free(xk_new, x_prime, dtau_prime)) if random . random() < new_weight / old_weight: xk = xk_new data_hist . append(xk) def pi_analytic (xk, x_prime, x_dprime, dtau_prime, dtau_dprime): mean = (dtau_dprime * x_prime + dtau_prime * x_dprime) / (dtau_prime + dtau_dprime) sigma = 1.0 / math . sqrt( 1.0 / dtau_prime + 1.0 / dtau_dprime) return math . exp( - (xk - mean) ** 2 / ( 2.0 * sigma ** 2 )) / math . sqrt( 2.0 * math . pi) / sigma pylab . title( 'Distribution on slice k' , fontsize = 18 ) histo, bin_edges, dummy = pylab . hist(data_hist, bins = 100 , normed = True ) bin_centers = 0.5 * (bin_edges[ 1 :] + bin_edges[: - 1 ]) pylab . plot(bin_centers, [pi_analytic(x, x_prime, x_dprime, dtau_prime, dtau_dprime) for x in bin_centers], 'r-' , lw = 3 ) pylab . xlabel( '$x_k$' , fontsize = 18 ) pylab . ylabel( '$\\pi(x_k)$' , fontsize = 18 ) #pylab.savefig('plot-path_slice.png') pylab . show() Levy Harmonic Path import math , random beta = 1.0 N = 4 dtau = beta / N xstart, xend = 0.0 , 1.0 x = [xstart] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Ups1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Ups2 = x[k - 1 ] / math . sinh(dtau) + \\ xend / math . sinh(dtau_prime) x . append(random . gauss(Ups2 / Ups1, \\ 1.0 / math . sqrt(Ups1))) x . append(xend) print x [0.0, -0.3585400331470993, -0.46657041443239394, 0.01352956236855482, 1.0] Levy Harmonic Path 3D import math , random def levy_harmonic_1d (start, end, dtau): x = [start] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Ups1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Ups2 = x[k - 1 ] / math . sinh(dtau) + \\ end / math . sinh(dtau_prime) x . append(random . gauss(Ups2 / Ups1, \\ 1.0 / math . sqrt(Ups1))) x . append(end) return x beta = 1.0 N = 20 dtau = beta / float (N) [xstart, ystart, zstart] = [ 1.0 , - 2.0 , 1.5 ] [xend, yend, zend] = [ - 2.5 , 0.0 , - 0.5 ] x = levy_harmonic_1d(xstart, xend, dtau) y = levy_harmonic_1d(ystart, yend, dtau) z = levy_harmonic_1d(zstart, zend, dtau) for i in range (N + 1 ): print 'slice %2i : ' % i, x[i], y[i], z[i] slice 0: 1.0 -2.0 1.5 slice 1: 0.777748893943 -2.10539607648 1.73826482099 slice 2: 0.763931019379 -2.14387236587 1.54684977036 slice 3: 0.500747263585 -2.08049210773 1.58757506994 slice 4: 0.429361380948 -1.98193292492 1.51647256244 slice 5: 0.156144949185 -2.08472795151 1.24115678993 slice 6: -0.301482536938 -2.31425875183 1.2116215967 slice 7: -0.114110853331 -2.01170186332 1.31953455601 slice 8: -0.495169243534 -1.78954410128 1.26715746611 slice 9: -1.07124864136 -1.84323749154 1.22618560998 slice 10: -1.02146009154 -1.4469573166 1.12287349028 slice 11: -1.2202731479 -1.25130592701 1.17356480665 slice 12: -1.44734039796 -0.769759958407 0.871271945556 slice 13: -1.59945389072 -0.917060277419 0.950203408728 slice 14: -1.59348122639 -0.750802821523 0.624546501494 slice 15: -1.79081758311 -0.666414256381 0.444743391328 slice 16: -1.99247299059 -0.44958639971 0.362047069815 slice 17: -1.75822763813 -0.389265378081 0.0467617492471 slice 18: -2.35917386101 -0.396104505937 0.367460418148 slice 19: -2.39839736996 -0.0739252507074 -0.239433962495 slice 20: -2.5 0.0 -0.5 Levy Harmonic Path Movie import math , random , pylab beta = 2.0 N = 10 dtau = beta / N nsteps = 5 xstart, xend = 2.0 , 1.0 for step in range (nsteps): x = [xstart] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Ups1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Ups2 = x[k - 1 ] / math . sinh(dtau) + \\ xend / math . sinh(dtau_prime) x . append(random . gauss(Ups2 / Ups1, \\ 1.0 / math . sqrt(Ups1))) x . append(xend) # graphics pylab . plot(x, [j * dtau for j in range (N + 1 )], 'bo-' ) pylab . xlabel( '$x$' , fontsize = 18 ) pylab . ylabel( '$ \\\\ tau$' , fontsize = 18 ) pylab . title( 'Harmonic path %i ' % step) pylab . xlim( - 2.0 , 4.0 ) pylab . show() #pylab.close()","title":"Levy Quantum Path"},{"location":"Montecarlo/Levy/levy/#tutorial","text":"Naive Single Particle Emax = 5 States = [] for E_x in range (Emax): for E_y in range (Emax): for E_z in range (Emax): States . append(((E_x + E_y + E_z), (E_x, E_y, E_z))) States . sort() for k in range ( 5 ): print ' %3d ' % k, States[k][ 0 ], States[k][ 1 ] 0 0 (0, 0, 0) 1 1 (0, 0, 1) 2 1 (0, 1, 0) 3 1 (1, 0, 0) 4 2 (0, 0, 2) Naive Boson Trap import math Energy = [ 0.0 ] + [ 1.0 ] * 3 + [ 2.0 ] * 6 + [ 3.0 ] * 10 + [ 4.0 ] * 15 beta = 1.0 n_states = 0 Z = 0.0 N0_mean = 0.0 E_mean = 0.0 for s_0 in range ( 35 ): for s_1 in range (s_0, 35 ): for s_2 in range (s_1, 35 ): for s_3 in range (s_2, 35 ): for s_4 in range (s_3, 35 ): n_states += 1 state = [s_0, s_1, s_2, s_3, s_4] E = sum (Energy[s] for s in state) Z += math . exp( - beta * E) E_mean += E * math . exp( - beta * E) N0_mean += state . count( 0 ) * \\ math . exp( - beta * E) print n_states, Z, E_mean / Z / 5.0 , N0_mean / Z / 5.0 575757 17.3732972183 1.03133265311 0.446969501933","title":"TUTORIAL"},{"location":"Montecarlo/Lotto/lotto/","text":"Lotto Dynamics in Integer Space We find a proper model to represent the dynamics of the system in positive integer space [1 to 69] using random number generator. With this model we run Hybrid Montecarlo(HMC) algorithm to thermalize the system to determine most probable values of quantities like: average absolute difference, root mean square absolute difference and most probable absolute difference, which are helpful to determine the most probable vectors in sample space. Import some libraries import random as random import matplotlib.pyplot as plt import numpy as np from numpy import linalg as LA import math as math import pandas % matplotlib inline Maximum no in range of lottery Max = 69 This function generates 5 random samples between 1 to 65. def sample_generator (Max): x = np . sort(random . sample( range ( 1 ,Max), 5 ) ) return x 1.1. Construction of a Toy Model For example, considering range of sample equal to 50, among millions of sample one gets: mean of first no : 5 mean of second no :15 mean of third no :25 mean of fourth no:35 mean of fifth no:45 We consider these mean values as equilibrium point of each oscillator. Oscillators oscillate in integer Space. Each sample of lottery is some state of oscillator. There will be total of (50x49x48x47x46/5!) states. We can choose best modle of oscillator by making a study of correlation cofficients among digits in each sample. Here we have proposed 3 model where model I and II are special case of Model III. 1.1.1. Model Selection with Proper Action Let us define a skewsymmetric distance matrix by taking difference between digits in sample as the matrix elements. There is one distance matrix per sample. $$D_{ij} = (x_{i}-x_{j})$$ ie. \\( D = \\left( \\begin{array}{ccc} 0 & \\color{blue}{(x_{1}-x_{2})} & (x_{1}-x_{3})& (x_{1}-x_{4}) & (x_{1}-x_{5}) \\\\ (x_{2}-x_{1}) & 0 & \\color{blue}{(x_{2}-x_{3})}& (x_{2}-x_{4}) & (x_{2}-x_{5}) \\\\ (x_{3}-x_{1}) & (x_{3}-x_{2}) & 0& \\color{blue}{(x_{3}-x_{4})} & (x_{3}-x_{5}) \\\\ (x_{4}-x_{1}) & (x_{4}-x_{2}) & (x_{4}-x_{3})& 0 & \\color{blue}{(x_{4}-x_{5})} \\\\ \\color{blue}{(x_{5}-x_{1})} & (x_{5}-x_{2}) & (x_{5}-x_{3})& (x_{5}-x_{4}) & 0 \\\\ \\end{array} \\right) \\) Taking (N = 5) oscillators with flexibility between seperation of numbers as spring constant (K=1). Simple model of Action can be defined by taking single updiagonal terms only as: Model-I (Linear) $$ L = \\frac{1}{2}K[(x_1 -x_2)^2 +(x_2 -x_3)^2 + (x_3 -x_4)^2 + (x_4 -x_5)^2 ] $$ Model-II (Linear &Periodic) $$ L = \\frac{1}{2}K[(x_1 -x_2)^2 +(x_2 -x_3)^2 + (x_3 -x_4)^2 + (x_4 -x_5)^2 + (x_5 -x_1)^2 ] $$ Considering effect of all terms in distance matrix one can define new model of Action as: Model - III (Quadratic & Periodic) $$L = Tr(D^{\\dagger}KD)$$ $$\\color{red}{Warning:}$$ Since each digit are not equally correlated to eachother, this form of action should be corrected by choosing appropriate spring constant for crossed terms like $x_{3}x_{4}$. K is another matrix(or tensor) of spring constants which can be determined by finding correlation cofficients between digits within several samples. 1.1.2. Study of Distance Matrix We can make skew symmetric matrix into traceless symmetric matrix by taking absolute value of each elements. def distance_matrix (x): D = [[ 0.0 for k in range ( 5 )] for l in range ( 5 )] for k in range ( 5 ): for l in range ( 5 ): D[k][l] = abs (x[k] - x[l]) return D Lets have a look of distance matrix: distance_matrix(sample_generator(Max)) [[0, 9, 24, 39, 44], [9, 0, 15, 30, 35], [24, 15, 0, 15, 20], [39, 30, 15, 0, 5], [44, 35, 20, 5, 0]] We can generate a small bucket of 9 distance matices to visualize distribution of distances. M = [np . array([[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ]]) for k in range ( 9 )] for k in range ( 9 ): M[k] = np . array(distance_matrix(x = sample_generator(Max))) for k in range ( 9 ): plt . subplot( 3 , 3 ,k + 1 ) plt . imshow(M[ 0 ], interpolation = 'nearest' , cmap = plt . cm . ocean, extent = ( 0.5 , 10.5 , 0.5 , 10.5 )) plt . colorbar() plt . show() 1.1.2.1 Enasmble of Distance matrices wstor_III = [] for k in range ( 10000 ): x = sample_generator(Max) A = distance_matrix(x) w, v = LA . eig(A) #print max(w) #for l in range(5): #wstor.append(abs(w[l])) wstor_III . append( max (w)) plt . scatter(k, max (w)) Principle component of eigen values helps us to predict better model by dominancy of principle direction. Principle Component Analysis - Model -III num_bins = 100 plt . grid() plt . title( \"Plot of feequency of principle component in eigen values\" ) plt . hist(wstor_III,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show() Principle Component Analysis - Model - II In model - II , distance matrix becomes diagonal matrix and hence eigen values are diagonal elements themselves. We can plot distribution of largest difference. wstor_II = [] for k in range ( 10000 ): x = sample_generator(Max) A = distance_matrix(x) w = max (A[ 0 ][ 1 ],A[ 1 ][ 2 ],A[ 2 ][ 3 ],A[ 3 ][ 4 ],A[ 4 ][ 0 ]) wstor_II . append(w) plt . scatter(k,w) num_bins = 100 plt . grid() plt . title( \"Plot of feequency of principle component in eigen values\" ) plt . hist(wstor_II,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show() $$\\color{blue}{Conclusion}$$ : Most of the distance matrices have principle component around 100. Principle compont depends on all distances. Therefore other distances can not be ignored in action. New action should be defined in term of Distance matrix. 1.1.3. Statistical Analysis & Determination of Spring Constants 1.1.3.1. Study of Variance-Covariance Matrix of samples Study of Variance-Covariance help us to determine the spring constant(K) in our model which is ultimately related to the correlation coffecient. We construct Variance-Covariance Matirx by using 100 samples in the following steps: 1 . Lets construct a bag of Nbag = 1000 samples. Nbag = 1000 SampleBag = [sample_generator(Max) for k in range (Nbag)] 2 . Vectorization of 100 samples : where first digit from each sample goes to first column vector of Vec matrix etc. def vactorization (SampleBag): Vec = [[ 0 for k in range (Nbag)] for l in range ( 5 )] for l in range ( 5 ): for k in range (Nbag): Vec[l][k] = SampleBag[k][l] return np . array(Vec) SB = vactorization(SampleBag) p = 1 for l in range ( 5 ): for r in range ( 5 ): plt . subplot( 5 , 5 ,p) plt . scatter(SB[l],SB[r]) p = p + 1 plt . show() 3 . Normalization brings each column vector to have mean equal to zero which helps to visualize variance-covariance of samples. def normalization (Vec): mn = [ 0 for k in range ( 5 )] vr = [ 0 for k in range ( 5 )] rng = [ 0 for k in range ( 5 )] numVec = [[ 0 for k in range (Nbag)] for l in range ( 5 )] #Find mean and range (Maximum-minimum) of each vector for l in range ( 5 ): mn[l] = np . mean(Vec[l]) vr[l] = np . var(Vec[l]) for k in range (Nbag): numVec[l][k] = (SampleBag[k][l] - mn[l]) / (math . sqrt(vr[l] / float (Nbag))) numVec = np . array(numVec) return numVec 1.1.3.2.a. Variance-Covariance of Raw samples Vec = vactorization(SampleBag) VCM_raw = np . cov(Vec) plt . title( \"Variance-Covariance of raw sample\" ) plt . imshow(VCM_raw, interpolation = 'nearest' ,\\ cmap = plt . cm . hot, extent = ( 0.5 , 10.5 , 0.5 , 10.5 )) plt . colorbar() plt . show() 1.1.3.2.b. Variance-Covariance of Normalized samples : Crrelation cofficients Vec = vactorization(SampleBag) numVec = normalization(Vec) VCM_normalized = np . cov(numVec) plt . title( \"Variance-Covariance of normalized sample\" ) plt . imshow(VCM_normalized, interpolation = 'nearest' ,\\ cmap = plt . cm . hot, extent = ( 0.5 , 10.5 , 0.5 , 10.5 )) plt . colorbar() plt . show() 1.1.3.3. Spring Constants Matrix of spring constants is a symmetric tensor which can be given by square root of normalized correlation cofficients. K = np . sqrt(VCM_normalized / max (VCM_normalized[ 0 ])) K array([[ 1. , 0.79287801, 0.66542652, 0.56166262, 0.45306335], [ 0.79287801, 1. , 0.84281867, 0.69757696, 0.57453966], [ 0.66542652, 0.84281867, 1. , 0.83777405, 0.68199933], [ 0.56166262, 0.69757696, 0.83777405, 1. , 0.80502696], [ 0.45306335, 0.57453966, 0.68199933, 0.80502696, 1. ]]) $\\color{blue}{\\text{Improved Action}}: \\boxed{L = D^{\\dagger}KD}$ with K-matrix found above. 1.2 Montecarlo Simulation One can calculate the most probable difference vector using Hybrid Monrtecarlo Algorithm. Total energy of the system of (N=100) coupled oscillator in integer space can be expressed as: $$H = \\sum_{i=1}^{N} D^{\\dagger}KD $$ Define some useful function for thermalization def action (D): '''D = distance matrix''' '''K = spring constant tensor''' h = np . dot(D,np . dot(K,D)) htr = np . trace(h) return htr def hot_start (): '''N = total no of coupled oscillators in the system ''' '''U = bag of N oscillators''' U = [] for k in range (N): x = sample_generator(Max) U . append(x) return U def cold_start (): '''N = total no of coupled oscillators in the system ''' '''U = bag of N oscillators''' U = [] for k in range (N): x = [ 1 , 1 , 1 , 1 , 1 ] U . append(x) return U def hamiltonian (U): '''H = total hamiltonian''' H = 0 for k in range (N): D = distance_matrix(U[k]) h = action(D) H = H + h return H def pick_random_particle (printkey): n = random . randint( 0 , N - 1 ) if printkey == 1 : print \"oscillator picked at\" ,n return n def value_shifter (u,dx): u = u + dx for k in range ( len (u)): if u[k] < 0 : u[k] = Max + u[k] elif u[k] > 69 : u[k] = u[k] % Max u = np . sort(u) return u dv = 10 Kb = 1.0 T = 100 N = 20 1.2.1 Thermalization def thermalize (U,T,nruns,printkey): irun = 0 h_stor = [ 0.0 for k in range (nrun)] U_stor = [] count = 0 while irun < nrun: h_old = hamiltonian(U) n = pick_random_particle(printkey) ov = U[n] dx = random . sample( range ( - dv,dv), 5 ) U[n] = value_shifter(U[n],dx) h_new = hamiltonian(U) dh = h_new - h_old if printkey == 1 : print \"=========\" , irun, \"==============\" if dh < 0 : count = count + 1 if printkey == 1 : print irun, \"Energy decreased! It is accepted!\" ,dh if printkey == 3 : print \"change made at\" ,n,dx, \"Participant\" ,U[n] if printkey == 1 : print irun, \"old conf. = \" , ov, \"replaced by\" ,U[n] h_stor[irun] = h_new U_stor . append(U) else : if printkey == 1 : print irun, \"Energy increased!\" ,dh frac = math . exp( - dh / (Kb * T)) b = random . uniform( 0.0 , 1.0 ) if printkey == 1 : print \"frac =\" ,frac, \"b =\" ,b if b < frac: if printkey == 1 : print irun, \"You Lucky\" h_stor[irun] = h_new U_stor . append(U) else : if printkey == 1 : print irun, \"Loser\" if printkey == 1 : print \"config. restablished at\" ,\\ n, \":\" ,U[n], \"by\" ,U[n] - dx, \"which is old\" ,ov U[n] = U[n] - dx h_stor[irun] = h_old if U[n][ 0 ] != ov[ 0 ] : if printkey == 1 : print \"Warning! config changed at\" ,n,\\ \":\" , ov, \" replaced by\" , U[n] if printkey == 1 : print \"---------------info-closed----------------\" if printkey == 1 : print \"\" if printkey == 2 : print irun, h_stor[irun] irun = irun + 1 success = (count / float (nrun)) * 100 if printkey == 1 : print \"================================\" print \"Success=\" ,success, \"%\" return h_stor,U_stor Test mode U = hot_start() #U = cold_start() nrun = 5 H_stor,U_stor = thermalize(U,T,nrun, 1 ) oscillator picked at 4 ================= 0 ==================== 0 Energy increased! 14490.7437085 frac = 1.16815288879e-63 b = 0.635801285104 0 Loser config. restablished at 4 : [ 4 30 51 55 57] by [ 9 25 42 48 59] which is old [ 9 25 46 50 53] ---------------info-closed---------------- oscillator picked at 4 ================= 1 ==================== 1 Energy decreased! It is accepted! -7019.6507091 1 old conf. = [ 9 25 42 48 59] replaced by [ 7 32 41 50 52] Warning! config changed at 4 : [ 9 25 42 48 59] replaced by [ 7 32 41 50 52] ---------------info-closed---------------- oscillator picked at 15 ================= 2 ==================== 2 Energy increased! 3885.6261383 frac = 1.33333750064e-17 b = 0.413681262571 2 Loser config. restablished at 15 : [30 44 56 61 62] by [38 42 52 67 65] which is old [38 42 57 62 65] ---------------info-closed---------------- oscillator picked at 12 ================= 3 ==================== 3 Energy decreased! It is accepted! -351.113417797 3 old conf. = [20 26 43 44 46] replaced by [14 19 35 35 41] Warning! config changed at 12 : [20 26 43 44 46] replaced by [14 19 35 35 41] ---------------info-closed---------------- oscillator picked at 4 ================= 4 ==================== 4 Energy decreased! It is accepted! -788.430394958 4 old conf. = [ 7 32 41 50 52] replaced by [16 27 45 50 60] Warning! config changed at 4 : [ 7 32 41 50 52] replaced by [16 27 45 50 60] ---------------info-closed---------------- =========================================== Success= 60.0 % Thermal mode U = hot_start() #U = cold_start() nrun = 10000 H_stor,U_stor = thermalize(U,T,nrun, 0 ) Success= 39.32 % X = np . arange( 0 , len (H_stor), 1 ) plt . figure( 1 ) plt . grid() plt . plot(X,H_stor, \"-\" ) plt . show() num_bins = 50 plt . grid() plt . hist(H_stor,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . title( \"histogram of Energy\" ) plt . show() This provides sufficient evidence for system in thermal equilibrium. Measurement of average absolute difference def abs_diff (x): diff = abs (x[ 0 ] - x[ 1 ]) + abs (x[ 1 ] - x[ 2 ]) + abs (x[ 2 ]\\ - x[ 3 ]) + abs (x[ 3 ] - x[ 4 ]) + abs (x[ 4 ] - x[ 0 ]) return diff ln = len (U_stor) total_abs_diff = 0 Diff = [] for k in range (ln): U = U_stor[k] for l in range (N): x = U[l] diff = abs_diff(x) Diff . append(diff) total_abs_diff = total_abs_diff + diff average_abs_diff = total_abs_diff / float (ln * N) average_abs_diff 65.200000000000003 num_bins = 50 plt . grid() plt . hist(Diff,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . title( \"histogram of absolute difference\" ) plt . show() Measurement of root mean square absolute difference def rms_diff (x): diff = math . sqrt( abs (x[ 0 ] - x[ 1 ]) ** 2 + abs (x[ 1 ] - x[ 2 ]) ** 2 \\ + abs (x[ 2 ] - x[ 3 ]) ** 2 + abs (x[ 3 ] - x[ 4 ]) ** 2 + abs (x[ 4 ] - x[ 0 ]) ** 2 ) return diff ln = len (U_stor) total_rms_diff = 0 rms_Diff = [] for k in range (ln): U = U_stor[k] for l in range (N): x = U[l] diff = rms_diff(x) rms_Diff . append(diff) total_rms_diff = total_abs_diff + diff rms_diff = total_rms_diff / float (ln * N) rms_diff 65.200247173536098 num_bins = 50 plt . grid() plt . hist(rms_Diff,num_bins, normed = 1.0 , \\ facecolor = 'green' , alpha = 0.5 ) plt . title( \"histogram of rms difference\" ) plt . show() 1.3. Interpretation 1.3.1. Most Probable Samples using Model -III : constrained by rms absolute difference 1.3.1.2. Generation of many samples and their actions def simulation_III (N_sample,Max): Lstor = [] Xstor = [] k = 1 while k < N_sample: x = sample_generator(Max) D = distance_matrix(x) atn = action(D) Xstor . append(x) Lstor . append(atn) k = k + 1 return Xstor,Lstor 1.3.1.3. Histogram Plot of frequencies N_sample = 100000 Xstor,Lstor = simulation_III(N_sample,Max) num_bins = 50 plt . grid() plt . hist(Lstor,num_bins, normed = 1.0 , \\ facecolor = 'green' , alpha = 0.5 ) plt . show() 1.3.1.4. Generate some sample sample_required = 100 count = 1 while count < sample_required: x = sample_generator(Max) rmsdiff = math . sqrt( abs (x[ 0 ] - x[ 1 ]) ** 2 + abs (x[ 1 ] - \\ x[ 2 ]) ** 2 + abs (x[ 2 ] - x[ 3 ]) ** 2 + abs (x[ 3 ] - x[ 4 ]) ** 2 + abs (x[ 4 ] - x[ 0 ]) ** 2 ) D = distance_matrix(x) act = action(D) if act > 20000 and act < 40000 : '''rms_diff constraint''' if rmsdiff < 70 and rmsdiff > 50 : count = count + 1 print \"rms test passed!\" ,x,act rms test passed! [22 31 34 36 63] 23213.3113095 rms test passed! [ 7 13 35 39 50] 33691.0412054 rms test passed! [18 46 51 61 62] 31851.0262931 rms test passed! [ 1 5 24 25 48] 35954.8593645 rms test passed! [17 37 47 52 68] 37716.8213328 rms test passed! [ 4 40 46 48 56] 39837.2864565 rms test passed! [17 33 45 46 68] 36706.1095915 rms test passed! [ 7 19 29 30 60] 39387.868137 rms test passed! [21 46 58 62 67] 34223.4073232 rms test passed! [14 23 27 39 60] 32757.3684971 rms test passed! [23 25 37 54 68] 38547.9912041 rms test passed! [ 9 35 36 38 64] 37754.3796817 rms test passed! [ 1 10 12 21 51] 36992.1945171 rms test passed! [ 7 12 20 40 52] 37750.4521181 rms test passed! [ 4 11 21 24 47] 27705.7997514 rms test passed! [27 35 38 66 68] 34682.9450353 rms test passed! [ 6 21 24 41 55] 37746.4051962 rms test passed! [ 8 17 19 20 57] 33609.5413481 rms test passed! [18 37 53 60 63] 35902.0551094 rms test passed! [12 25 30 53 57] 37347.9295182 Take these samples and buy lottery! Enjoy! 1.3.2. Most Probable Samples using Model -I : without any constraint from thermalization 1.3.2.1. Calculation of action in each sample def action_I (x): act = 0.5 * ((x[ 0 ] - x[ 1 ]) ** 2 + (x[ 1 ] - x[ 2 ]) ** 2 + (x[ 2 ] - x[ 3 ]) ** 2 + (x[ 3 ] - x[ 4 ]) ** 2 ) return act 1.3.2.2. Generation of many (N_samples) samples and their actions def simulation_I (N_sample,Max): Lstor = [] Xstor = [] k = 1 while k < N_sample: x = sample_generator(Max) atn = action_I(x) Xstor . append(x) Lstor . append(atn) k = k + 1 return Xstor,Lstor 1.3.2.3. Histogram Plot of frequencies N_sample = 10000 Xstor,Lstor = simulation_I(N_sample,Max) plt . grid() plt . hist(Lstor,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show() 1.3.2.4. Generate some sample sample_required = 100 k = 1 while k < sample_required: x = sample_generator(Max) act = action_I(x) if act > 250 and act < 350 : print x,act k = k + 1 [14 27 29 43 56] 269.0 [11 21 42 48 54] 306.5 [ 3 6 9 13 35] 259.0 [ 6 20 33 37 51] 288.5 [ 8 24 27 34 52] 319.0 [10 18 22 34 55] 332.5 [ 2 14 19 34 49] 309.5 [10 23 31 35 52] 269.0 [17 37 49 59 63] 330.0 [ 8 29 43 50 52] 345.0 [ 3 10 15 30 50] 349.5 [ 7 12 22 40 52] 296.5 [ 8 12 28 42 57] 346.5 [16 19 31 35 58] 349.0 [14 36 50 51 53] 342.5 [ 1 7 18 28 49] 349.0 [21 32 34 54 55] 263.0 [15 31 45 53 56] 262.5 [20 26 42 53 64] 267.0 [ 5 13 31 33 45] 268.0 [ 5 9 20 22 42] 270.5 [ 2 19 32 37 46] 282.0 Take these samples and buy lottery ! Enjoy !","title":"Lotto Dynamics in Integer Space"},{"location":"Montecarlo/Lotto/lotto/#lotto-dynamics-in-integer-space","text":"We find a proper model to represent the dynamics of the system in positive integer space [1 to 69] using random number generator. With this model we run Hybrid Montecarlo(HMC) algorithm to thermalize the system to determine most probable values of quantities like: average absolute difference, root mean square absolute difference and most probable absolute difference, which are helpful to determine the most probable vectors in sample space. Import some libraries import random as random import matplotlib.pyplot as plt import numpy as np from numpy import linalg as LA import math as math import pandas % matplotlib inline Maximum no in range of lottery Max = 69 This function generates 5 random samples between 1 to 65. def sample_generator (Max): x = np . sort(random . sample( range ( 1 ,Max), 5 ) ) return x","title":"Lotto Dynamics in Integer Space"},{"location":"Montecarlo/Lotto/lotto/#11-construction-of-a-toy-model","text":"For example, considering range of sample equal to 50, among millions of sample one gets: mean of first no : 5 mean of second no :15 mean of third no :25 mean of fourth no:35 mean of fifth no:45 We consider these mean values as equilibrium point of each oscillator. Oscillators oscillate in integer Space. Each sample of lottery is some state of oscillator. There will be total of (50x49x48x47x46/5!) states. We can choose best modle of oscillator by making a study of correlation cofficients among digits in each sample. Here we have proposed 3 model where model I and II are special case of Model III.","title":"1.1.  Construction of a Toy Model"},{"location":"Montecarlo/Lotto/lotto/#111-model-selection-with-proper-action","text":"Let us define a skewsymmetric distance matrix by taking difference between digits in sample as the matrix elements. There is one distance matrix per sample. $$D_{ij} = (x_{i}-x_{j})$$ ie. \\( D = \\left( \\begin{array}{ccc} 0 & \\color{blue}{(x_{1}-x_{2})} & (x_{1}-x_{3})& (x_{1}-x_{4}) & (x_{1}-x_{5}) \\\\ (x_{2}-x_{1}) & 0 & \\color{blue}{(x_{2}-x_{3})}& (x_{2}-x_{4}) & (x_{2}-x_{5}) \\\\ (x_{3}-x_{1}) & (x_{3}-x_{2}) & 0& \\color{blue}{(x_{3}-x_{4})} & (x_{3}-x_{5}) \\\\ (x_{4}-x_{1}) & (x_{4}-x_{2}) & (x_{4}-x_{3})& 0 & \\color{blue}{(x_{4}-x_{5})} \\\\ \\color{blue}{(x_{5}-x_{1})} & (x_{5}-x_{2}) & (x_{5}-x_{3})& (x_{5}-x_{4}) & 0 \\\\ \\end{array} \\right) \\) Taking (N = 5) oscillators with flexibility between seperation of numbers as spring constant (K=1). Simple model of Action can be defined by taking single updiagonal terms only as:","title":"1.1.1.   Model Selection with Proper Action"},{"location":"Montecarlo/Lotto/lotto/#model-i-linear","text":"$$ L = \\frac{1}{2}K[(x_1 -x_2)^2 +(x_2 -x_3)^2 + (x_3 -x_4)^2 + (x_4 -x_5)^2 ] $$","title":"Model-I (Linear)"},{"location":"Montecarlo/Lotto/lotto/#model-ii-linear-periodic","text":"$$ L = \\frac{1}{2}K[(x_1 -x_2)^2 +(x_2 -x_3)^2 + (x_3 -x_4)^2 + (x_4 -x_5)^2 + (x_5 -x_1)^2 ] $$ Considering effect of all terms in distance matrix one can define new model of Action as:","title":"Model-II (Linear &amp;Periodic)"},{"location":"Montecarlo/Lotto/lotto/#model-iii-quadratic-periodic","text":"$$L = Tr(D^{\\dagger}KD)$$ $$\\color{red}{Warning:}$$ Since each digit are not equally correlated to eachother, this form of action should be corrected by choosing appropriate spring constant for crossed terms like $x_{3}x_{4}$. K is another matrix(or tensor) of spring constants which can be determined by finding correlation cofficients between digits within several samples.","title":"Model - III (Quadratic &amp; Periodic)"},{"location":"Montecarlo/Lotto/lotto/#112-study-of-distance-matrix","text":"We can make skew symmetric matrix into traceless symmetric matrix by taking absolute value of each elements. def distance_matrix (x): D = [[ 0.0 for k in range ( 5 )] for l in range ( 5 )] for k in range ( 5 ): for l in range ( 5 ): D[k][l] = abs (x[k] - x[l]) return D Lets have a look of distance matrix: distance_matrix(sample_generator(Max)) [[0, 9, 24, 39, 44], [9, 0, 15, 30, 35], [24, 15, 0, 15, 20], [39, 30, 15, 0, 5], [44, 35, 20, 5, 0]] We can generate a small bucket of 9 distance matices to visualize distribution of distances. M = [np . array([[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ]]) for k in range ( 9 )] for k in range ( 9 ): M[k] = np . array(distance_matrix(x = sample_generator(Max))) for k in range ( 9 ): plt . subplot( 3 , 3 ,k + 1 ) plt . imshow(M[ 0 ], interpolation = 'nearest' , cmap = plt . cm . ocean, extent = ( 0.5 , 10.5 , 0.5 , 10.5 )) plt . colorbar() plt . show()","title":"1.1.2. Study of Distance Matrix"},{"location":"Montecarlo/Lotto/lotto/#1121-enasmble-of-distance-matrices","text":"wstor_III = [] for k in range ( 10000 ): x = sample_generator(Max) A = distance_matrix(x) w, v = LA . eig(A) #print max(w) #for l in range(5): #wstor.append(abs(w[l])) wstor_III . append( max (w)) plt . scatter(k, max (w)) Principle component of eigen values helps us to predict better model by dominancy of principle direction.","title":"1.1.2.1 Enasmble of Distance matrices"},{"location":"Montecarlo/Lotto/lotto/#principle-component-analysis-model-iii","text":"num_bins = 100 plt . grid() plt . title( \"Plot of feequency of principle component in eigen values\" ) plt . hist(wstor_III,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show()","title":"Principle Component Analysis - Model -III"},{"location":"Montecarlo/Lotto/lotto/#principle-component-analysis-model-ii","text":"In model - II , distance matrix becomes diagonal matrix and hence eigen values are diagonal elements themselves. We can plot distribution of largest difference. wstor_II = [] for k in range ( 10000 ): x = sample_generator(Max) A = distance_matrix(x) w = max (A[ 0 ][ 1 ],A[ 1 ][ 2 ],A[ 2 ][ 3 ],A[ 3 ][ 4 ],A[ 4 ][ 0 ]) wstor_II . append(w) plt . scatter(k,w) num_bins = 100 plt . grid() plt . title( \"Plot of feequency of principle component in eigen values\" ) plt . hist(wstor_II,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show() $$\\color{blue}{Conclusion}$$ : Most of the distance matrices have principle component around 100. Principle compont depends on all distances. Therefore other distances can not be ignored in action. New action should be defined in term of Distance matrix.","title":"Principle Component Analysis - Model - II"},{"location":"Montecarlo/Lotto/lotto/#113-statistical-analysis-determination-of-spring-constants","text":"","title":"1.1.3. Statistical Analysis &amp; Determination of Spring Constants"},{"location":"Montecarlo/Lotto/lotto/#1131-study-of-variance-covariance-matrix-of-samples","text":"Study of Variance-Covariance help us to determine the spring constant(K) in our model which is ultimately related to the correlation coffecient. We construct Variance-Covariance Matirx by using 100 samples in the following steps: 1 . Lets construct a bag of Nbag = 1000 samples. Nbag = 1000 SampleBag = [sample_generator(Max) for k in range (Nbag)] 2 . Vectorization of 100 samples : where first digit from each sample goes to first column vector of Vec matrix etc. def vactorization (SampleBag): Vec = [[ 0 for k in range (Nbag)] for l in range ( 5 )] for l in range ( 5 ): for k in range (Nbag): Vec[l][k] = SampleBag[k][l] return np . array(Vec) SB = vactorization(SampleBag) p = 1 for l in range ( 5 ): for r in range ( 5 ): plt . subplot( 5 , 5 ,p) plt . scatter(SB[l],SB[r]) p = p + 1 plt . show() 3 . Normalization brings each column vector to have mean equal to zero which helps to visualize variance-covariance of samples. def normalization (Vec): mn = [ 0 for k in range ( 5 )] vr = [ 0 for k in range ( 5 )] rng = [ 0 for k in range ( 5 )] numVec = [[ 0 for k in range (Nbag)] for l in range ( 5 )] #Find mean and range (Maximum-minimum) of each vector for l in range ( 5 ): mn[l] = np . mean(Vec[l]) vr[l] = np . var(Vec[l]) for k in range (Nbag): numVec[l][k] = (SampleBag[k][l] - mn[l]) / (math . sqrt(vr[l] / float (Nbag))) numVec = np . array(numVec) return numVec","title":"1.1.3.1.  Study of Variance-Covariance  Matrix of samples"},{"location":"Montecarlo/Lotto/lotto/#1132a-variance-covariance-of-raw-samples","text":"Vec = vactorization(SampleBag) VCM_raw = np . cov(Vec) plt . title( \"Variance-Covariance of raw sample\" ) plt . imshow(VCM_raw, interpolation = 'nearest' ,\\ cmap = plt . cm . hot, extent = ( 0.5 , 10.5 , 0.5 , 10.5 )) plt . colorbar() plt . show()","title":"1.1.3.2.a. Variance-Covariance of Raw samples"},{"location":"Montecarlo/Lotto/lotto/#1132b-variance-covariance-of-normalized-samples-crrelation-cofficients","text":"Vec = vactorization(SampleBag) numVec = normalization(Vec) VCM_normalized = np . cov(numVec) plt . title( \"Variance-Covariance of normalized sample\" ) plt . imshow(VCM_normalized, interpolation = 'nearest' ,\\ cmap = plt . cm . hot, extent = ( 0.5 , 10.5 , 0.5 , 10.5 )) plt . colorbar() plt . show()","title":"1.1.3.2.b. Variance-Covariance of Normalized samples : Crrelation cofficients"},{"location":"Montecarlo/Lotto/lotto/#1133-spring-constants","text":"Matrix of spring constants is a symmetric tensor which can be given by square root of normalized correlation cofficients. K = np . sqrt(VCM_normalized / max (VCM_normalized[ 0 ])) K array([[ 1. , 0.79287801, 0.66542652, 0.56166262, 0.45306335], [ 0.79287801, 1. , 0.84281867, 0.69757696, 0.57453966], [ 0.66542652, 0.84281867, 1. , 0.83777405, 0.68199933], [ 0.56166262, 0.69757696, 0.83777405, 1. , 0.80502696], [ 0.45306335, 0.57453966, 0.68199933, 0.80502696, 1. ]]) $\\color{blue}{\\text{Improved Action}}: \\boxed{L = D^{\\dagger}KD}$ with K-matrix found above.","title":"1.1.3.3. Spring Constants"},{"location":"Montecarlo/Lotto/lotto/#12-montecarlo-simulation","text":"One can calculate the most probable difference vector using Hybrid Monrtecarlo Algorithm. Total energy of the system of (N=100) coupled oscillator in integer space can be expressed as: $$H = \\sum_{i=1}^{N} D^{\\dagger}KD $$ Define some useful function for thermalization def action (D): '''D = distance matrix''' '''K = spring constant tensor''' h = np . dot(D,np . dot(K,D)) htr = np . trace(h) return htr def hot_start (): '''N = total no of coupled oscillators in the system ''' '''U = bag of N oscillators''' U = [] for k in range (N): x = sample_generator(Max) U . append(x) return U def cold_start (): '''N = total no of coupled oscillators in the system ''' '''U = bag of N oscillators''' U = [] for k in range (N): x = [ 1 , 1 , 1 , 1 , 1 ] U . append(x) return U def hamiltonian (U): '''H = total hamiltonian''' H = 0 for k in range (N): D = distance_matrix(U[k]) h = action(D) H = H + h return H def pick_random_particle (printkey): n = random . randint( 0 , N - 1 ) if printkey == 1 : print \"oscillator picked at\" ,n return n def value_shifter (u,dx): u = u + dx for k in range ( len (u)): if u[k] < 0 : u[k] = Max + u[k] elif u[k] > 69 : u[k] = u[k] % Max u = np . sort(u) return u dv = 10 Kb = 1.0 T = 100 N = 20","title":"1.2 Montecarlo Simulation"},{"location":"Montecarlo/Lotto/lotto/#121-thermalization","text":"def thermalize (U,T,nruns,printkey): irun = 0 h_stor = [ 0.0 for k in range (nrun)] U_stor = [] count = 0 while irun < nrun: h_old = hamiltonian(U) n = pick_random_particle(printkey) ov = U[n] dx = random . sample( range ( - dv,dv), 5 ) U[n] = value_shifter(U[n],dx) h_new = hamiltonian(U) dh = h_new - h_old if printkey == 1 : print \"=========\" , irun, \"==============\" if dh < 0 : count = count + 1 if printkey == 1 : print irun, \"Energy decreased! It is accepted!\" ,dh if printkey == 3 : print \"change made at\" ,n,dx, \"Participant\" ,U[n] if printkey == 1 : print irun, \"old conf. = \" , ov, \"replaced by\" ,U[n] h_stor[irun] = h_new U_stor . append(U) else : if printkey == 1 : print irun, \"Energy increased!\" ,dh frac = math . exp( - dh / (Kb * T)) b = random . uniform( 0.0 , 1.0 ) if printkey == 1 : print \"frac =\" ,frac, \"b =\" ,b if b < frac: if printkey == 1 : print irun, \"You Lucky\" h_stor[irun] = h_new U_stor . append(U) else : if printkey == 1 : print irun, \"Loser\" if printkey == 1 : print \"config. restablished at\" ,\\ n, \":\" ,U[n], \"by\" ,U[n] - dx, \"which is old\" ,ov U[n] = U[n] - dx h_stor[irun] = h_old if U[n][ 0 ] != ov[ 0 ] : if printkey == 1 : print \"Warning! config changed at\" ,n,\\ \":\" , ov, \" replaced by\" , U[n] if printkey == 1 : print \"---------------info-closed----------------\" if printkey == 1 : print \"\" if printkey == 2 : print irun, h_stor[irun] irun = irun + 1 success = (count / float (nrun)) * 100 if printkey == 1 : print \"================================\" print \"Success=\" ,success, \"%\" return h_stor,U_stor","title":"1.2.1 Thermalization"},{"location":"Montecarlo/Lotto/lotto/#test-mode","text":"U = hot_start() #U = cold_start() nrun = 5 H_stor,U_stor = thermalize(U,T,nrun, 1 ) oscillator picked at 4 ================= 0 ==================== 0 Energy increased! 14490.7437085 frac = 1.16815288879e-63 b = 0.635801285104 0 Loser config. restablished at 4 : [ 4 30 51 55 57] by [ 9 25 42 48 59] which is old [ 9 25 46 50 53] ---------------info-closed---------------- oscillator picked at 4 ================= 1 ==================== 1 Energy decreased! It is accepted! -7019.6507091 1 old conf. = [ 9 25 42 48 59] replaced by [ 7 32 41 50 52] Warning! config changed at 4 : [ 9 25 42 48 59] replaced by [ 7 32 41 50 52] ---------------info-closed---------------- oscillator picked at 15 ================= 2 ==================== 2 Energy increased! 3885.6261383 frac = 1.33333750064e-17 b = 0.413681262571 2 Loser config. restablished at 15 : [30 44 56 61 62] by [38 42 52 67 65] which is old [38 42 57 62 65] ---------------info-closed---------------- oscillator picked at 12 ================= 3 ==================== 3 Energy decreased! It is accepted! -351.113417797 3 old conf. = [20 26 43 44 46] replaced by [14 19 35 35 41] Warning! config changed at 12 : [20 26 43 44 46] replaced by [14 19 35 35 41] ---------------info-closed---------------- oscillator picked at 4 ================= 4 ==================== 4 Energy decreased! It is accepted! -788.430394958 4 old conf. = [ 7 32 41 50 52] replaced by [16 27 45 50 60] Warning! config changed at 4 : [ 7 32 41 50 52] replaced by [16 27 45 50 60] ---------------info-closed---------------- =========================================== Success= 60.0 %","title":"Test mode"},{"location":"Montecarlo/Lotto/lotto/#thermal-mode","text":"U = hot_start() #U = cold_start() nrun = 10000 H_stor,U_stor = thermalize(U,T,nrun, 0 ) Success= 39.32 % X = np . arange( 0 , len (H_stor), 1 ) plt . figure( 1 ) plt . grid() plt . plot(X,H_stor, \"-\" ) plt . show() num_bins = 50 plt . grid() plt . hist(H_stor,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . title( \"histogram of Energy\" ) plt . show() This provides sufficient evidence for system in thermal equilibrium.","title":"Thermal mode"},{"location":"Montecarlo/Lotto/lotto/#measurement-of-average-absolute-difference","text":"def abs_diff (x): diff = abs (x[ 0 ] - x[ 1 ]) + abs (x[ 1 ] - x[ 2 ]) + abs (x[ 2 ]\\ - x[ 3 ]) + abs (x[ 3 ] - x[ 4 ]) + abs (x[ 4 ] - x[ 0 ]) return diff ln = len (U_stor) total_abs_diff = 0 Diff = [] for k in range (ln): U = U_stor[k] for l in range (N): x = U[l] diff = abs_diff(x) Diff . append(diff) total_abs_diff = total_abs_diff + diff average_abs_diff = total_abs_diff / float (ln * N) average_abs_diff 65.200000000000003 num_bins = 50 plt . grid() plt . hist(Diff,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . title( \"histogram of absolute difference\" ) plt . show()","title":"Measurement of average  absolute difference"},{"location":"Montecarlo/Lotto/lotto/#measurement-of-root-mean-square-absolute-difference","text":"def rms_diff (x): diff = math . sqrt( abs (x[ 0 ] - x[ 1 ]) ** 2 + abs (x[ 1 ] - x[ 2 ]) ** 2 \\ + abs (x[ 2 ] - x[ 3 ]) ** 2 + abs (x[ 3 ] - x[ 4 ]) ** 2 + abs (x[ 4 ] - x[ 0 ]) ** 2 ) return diff ln = len (U_stor) total_rms_diff = 0 rms_Diff = [] for k in range (ln): U = U_stor[k] for l in range (N): x = U[l] diff = rms_diff(x) rms_Diff . append(diff) total_rms_diff = total_abs_diff + diff rms_diff = total_rms_diff / float (ln * N) rms_diff 65.200247173536098 num_bins = 50 plt . grid() plt . hist(rms_Diff,num_bins, normed = 1.0 , \\ facecolor = 'green' , alpha = 0.5 ) plt . title( \"histogram of rms difference\" ) plt . show()","title":"Measurement of root mean square absolute difference"},{"location":"Montecarlo/Lotto/lotto/#13-interpretation","text":"","title":"1.3. Interpretation"},{"location":"Montecarlo/Lotto/lotto/#131-most-probable-samples-using-model-iii-constrained-by-rms-absolute-difference","text":"","title":"1.3.1. Most Probable Samples using Model -III : constrained by rms absolute difference"},{"location":"Montecarlo/Lotto/lotto/#1312-generation-of-many-samples-and-their-actions","text":"def simulation_III (N_sample,Max): Lstor = [] Xstor = [] k = 1 while k < N_sample: x = sample_generator(Max) D = distance_matrix(x) atn = action(D) Xstor . append(x) Lstor . append(atn) k = k + 1 return Xstor,Lstor","title":"1.3.1.2. Generation of many  samples and their actions"},{"location":"Montecarlo/Lotto/lotto/#1313-histogram-plot-of-frequencies","text":"N_sample = 100000 Xstor,Lstor = simulation_III(N_sample,Max) num_bins = 50 plt . grid() plt . hist(Lstor,num_bins, normed = 1.0 , \\ facecolor = 'green' , alpha = 0.5 ) plt . show()","title":"1.3.1.3. Histogram Plot of frequencies"},{"location":"Montecarlo/Lotto/lotto/#1314-generate-some-sample","text":"sample_required = 100 count = 1 while count < sample_required: x = sample_generator(Max) rmsdiff = math . sqrt( abs (x[ 0 ] - x[ 1 ]) ** 2 + abs (x[ 1 ] - \\ x[ 2 ]) ** 2 + abs (x[ 2 ] - x[ 3 ]) ** 2 + abs (x[ 3 ] - x[ 4 ]) ** 2 + abs (x[ 4 ] - x[ 0 ]) ** 2 ) D = distance_matrix(x) act = action(D) if act > 20000 and act < 40000 : '''rms_diff constraint''' if rmsdiff < 70 and rmsdiff > 50 : count = count + 1 print \"rms test passed!\" ,x,act rms test passed! [22 31 34 36 63] 23213.3113095 rms test passed! [ 7 13 35 39 50] 33691.0412054 rms test passed! [18 46 51 61 62] 31851.0262931 rms test passed! [ 1 5 24 25 48] 35954.8593645 rms test passed! [17 37 47 52 68] 37716.8213328 rms test passed! [ 4 40 46 48 56] 39837.2864565 rms test passed! [17 33 45 46 68] 36706.1095915 rms test passed! [ 7 19 29 30 60] 39387.868137 rms test passed! [21 46 58 62 67] 34223.4073232 rms test passed! [14 23 27 39 60] 32757.3684971 rms test passed! [23 25 37 54 68] 38547.9912041 rms test passed! [ 9 35 36 38 64] 37754.3796817 rms test passed! [ 1 10 12 21 51] 36992.1945171 rms test passed! [ 7 12 20 40 52] 37750.4521181 rms test passed! [ 4 11 21 24 47] 27705.7997514 rms test passed! [27 35 38 66 68] 34682.9450353 rms test passed! [ 6 21 24 41 55] 37746.4051962 rms test passed! [ 8 17 19 20 57] 33609.5413481 rms test passed! [18 37 53 60 63] 35902.0551094 rms test passed! [12 25 30 53 57] 37347.9295182 Take these samples and buy lottery! Enjoy!","title":"1.3.1.4.  Generate some sample"},{"location":"Montecarlo/Lotto/lotto/#132-most-probable-samples-using-model-i-without-any-constraint-from-thermalization","text":"","title":"1.3.2. Most Probable Samples using Model -I : without any constraint from thermalization"},{"location":"Montecarlo/Lotto/lotto/#1321-calculation-of-action-in-each-sample","text":"def action_I (x): act = 0.5 * ((x[ 0 ] - x[ 1 ]) ** 2 + (x[ 1 ] - x[ 2 ]) ** 2 + (x[ 2 ] - x[ 3 ]) ** 2 + (x[ 3 ] - x[ 4 ]) ** 2 ) return act","title":"1.3.2.1. Calculation of action in each sample"},{"location":"Montecarlo/Lotto/lotto/#1322-generation-of-many-n_samples-samples-and-their-actions","text":"def simulation_I (N_sample,Max): Lstor = [] Xstor = [] k = 1 while k < N_sample: x = sample_generator(Max) atn = action_I(x) Xstor . append(x) Lstor . append(atn) k = k + 1 return Xstor,Lstor","title":"1.3.2.2. Generation of many (N_samples) samples and their actions"},{"location":"Montecarlo/Lotto/lotto/#1323-histogram-plot-of-frequencies","text":"N_sample = 10000 Xstor,Lstor = simulation_I(N_sample,Max) plt . grid() plt . hist(Lstor,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show()","title":"1.3.2.3. Histogram Plot of frequencies"},{"location":"Montecarlo/Lotto/lotto/#1324-generate-some-sample","text":"sample_required = 100 k = 1 while k < sample_required: x = sample_generator(Max) act = action_I(x) if act > 250 and act < 350 : print x,act k = k + 1 [14 27 29 43 56] 269.0 [11 21 42 48 54] 306.5 [ 3 6 9 13 35] 259.0 [ 6 20 33 37 51] 288.5 [ 8 24 27 34 52] 319.0 [10 18 22 34 55] 332.5 [ 2 14 19 34 49] 309.5 [10 23 31 35 52] 269.0 [17 37 49 59 63] 330.0 [ 8 29 43 50 52] 345.0 [ 3 10 15 30 50] 349.5 [ 7 12 22 40 52] 296.5 [ 8 12 28 42 57] 346.5 [16 19 31 35 58] 349.0 [14 36 50 51 53] 342.5 [ 1 7 18 28 49] 349.0 [21 32 34 54 55] 263.0 [15 31 45 53 56] 262.5 [20 26 42 53 64] 267.0 [ 5 13 31 33 45] 268.0 [ 5 9 20 22 42] 270.5 [ 2 19 32 37 46] 282.0 Take these samples and buy lottery ! Enjoy !","title":"1.3.2.4.  Generate some sample"},{"location":"Montecarlo/Oscillator/Oscillator/","text":"Harmonic Oscillator using HMC Import the Library '''import section''' import numpy as np import matplotlib.pyplot as plt import math as math import random as random import seaborn as sns sns . set() We want to apply HMC to collection of 100 independent Harmonic Oscillator to get equilibrium configuration. Hamiltonian Hamiltonian of Harmonic Oscillator in 1D is: \\( H = \\frac{1}{2} p^{2} + \\frac{1}{2}q^{2}\\) with \\( m = 1,k = 1\\) This function calculates the total Hamiltonian of the configuration def hamiltonian (x,p,np): '''x,p: x and p are list of position and momentum''' '''np : number of particles in the system ''' H = 0.0 for k in range (np): H = H + ((x[k] * x[k]) / 2.0 + (p[k] * p[k]) / 2.0 ) return H Generating Random Momentum In order to generate random momentum we use \"random.gauss\" def drawp (np): '''this function returns a list of random numbers''' t = [ 0.0 for k in range (np)] for k in range (np): r = random . gauss( 0.0 , 1.0 ) t[k] = r return (t) One can check whether the generated numbers are normally distributed or not by doing: N = 100000 p = [ 0.0 for k in range (N)] p = drawp(N) num_bins = 100 plt . figure(figsize = [ 10 , 6 ]) plt . hist(p,num_bins, density = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show() Leap Frog We will use leap frog approximation to evolve the system according to time. def leap_frog (N,dt,ix,ip,np): ''' N : number of steps to evolve dt: fraction of time ie T = dt*N ix,ip : initial position and momentum np : number of the particles in the system ''' ''' Returns x,p : final position and momentum''' x = ix p = ip k = 0 while k < N: if k == 0 : for i in range (np): p[i] = p[i] - ((dt / 2.0 ) * x[i]) elif k > 0 : if k < N - 1 : for i in range (np): x[i] = x[i] + (dt * p[i]) p[i] = p[i] - (dt * x[i]) #S1 = hamiltonian(x,p,np) #print \"k =\",k,\"S1=\",S1 elif k == N - 1 : for i in range (np): p[i] = (p[i] - (dt / 2.0 ) * x[i]) k = k + 1 return x,p HMC Here we run the HMC - simulation def HMC (np,N,dt,steps,x0): ''' np : number of particles in the system N = number of steps in Leap - Frog dt = fraction of time in Leap - Frog steps: total steps in HMC ''' xt = [ 0.0 for k in range (np)] pt = [ 0.0 for k in range (np)] p0 = drawp(np) H = [ 0.0 for k in range (steps)] S0 = hamiltonian(x0,p0,np) #print (\"=======>\", 0,\"S0=\", S0) chain = 1 total_frac = 0.0 while chain < steps: s_stor = [ 0.0 ] xt,pt = leap_frog(N,dt,x0,p0,np) S1 = hamiltonian(xt,pt,np) frac = math . exp( - (S1 - S0)) #print frac a = min ( 1 ,frac) b = random . uniform( 0.0 , 1.0 ) if b < a: #print(\"=======>\", chain, \"S1=\",S1,frac,a,b) H[chain] = S1 x0 = xt p0 = drawp(np) S0 = hamiltonian(x0,p0,np) else : H[chain] = S0 p0 = drawp(np) chain = chain + 1 return H Seting Constants np = 1000 N = 1000 dt = 0.001 steps = 100 Call HMC x0 = [ 1.0 for k in range (np)] x0 = [random . uniform( 0.0 , 1.0 ) for k in range (np)] H = HMC(np,N,dt,steps,x0) Plot t = [ 1.0 * k for k in range (steps)] plt . figure(figsize = [ 15 , 4 ]) plt . scatter(t,H) plt . show()","title":"Harmonic Oscillator"},{"location":"Montecarlo/Oscillator/Oscillator/#harmonic-oscillator-using-hmc","text":"","title":"Harmonic Oscillator using HMC"},{"location":"Montecarlo/Oscillator/Oscillator/#import-the-library","text":"'''import section''' import numpy as np import matplotlib.pyplot as plt import math as math import random as random import seaborn as sns sns . set() We want to apply HMC to collection of 100 independent Harmonic Oscillator to get equilibrium configuration.","title":"Import the Library"},{"location":"Montecarlo/Oscillator/Oscillator/#hamiltonian","text":"Hamiltonian of Harmonic Oscillator in 1D is: \\( H = \\frac{1}{2} p^{2} + \\frac{1}{2}q^{2}\\) with \\( m = 1,k = 1\\) This function calculates the total Hamiltonian of the configuration def hamiltonian (x,p,np): '''x,p: x and p are list of position and momentum''' '''np : number of particles in the system ''' H = 0.0 for k in range (np): H = H + ((x[k] * x[k]) / 2.0 + (p[k] * p[k]) / 2.0 ) return H","title":"Hamiltonian"},{"location":"Montecarlo/Oscillator/Oscillator/#generating-random-momentum","text":"In order to generate random momentum we use \"random.gauss\" def drawp (np): '''this function returns a list of random numbers''' t = [ 0.0 for k in range (np)] for k in range (np): r = random . gauss( 0.0 , 1.0 ) t[k] = r return (t) One can check whether the generated numbers are normally distributed or not by doing: N = 100000 p = [ 0.0 for k in range (N)] p = drawp(N) num_bins = 100 plt . figure(figsize = [ 10 , 6 ]) plt . hist(p,num_bins, density = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show()","title":"Generating Random Momentum"},{"location":"Montecarlo/Oscillator/Oscillator/#leap-frog","text":"We will use leap frog approximation to evolve the system according to time. def leap_frog (N,dt,ix,ip,np): ''' N : number of steps to evolve dt: fraction of time ie T = dt*N ix,ip : initial position and momentum np : number of the particles in the system ''' ''' Returns x,p : final position and momentum''' x = ix p = ip k = 0 while k < N: if k == 0 : for i in range (np): p[i] = p[i] - ((dt / 2.0 ) * x[i]) elif k > 0 : if k < N - 1 : for i in range (np): x[i] = x[i] + (dt * p[i]) p[i] = p[i] - (dt * x[i]) #S1 = hamiltonian(x,p,np) #print \"k =\",k,\"S1=\",S1 elif k == N - 1 : for i in range (np): p[i] = (p[i] - (dt / 2.0 ) * x[i]) k = k + 1 return x,p","title":"Leap Frog"},{"location":"Montecarlo/Oscillator/Oscillator/#hmc","text":"Here we run the HMC - simulation def HMC (np,N,dt,steps,x0): ''' np : number of particles in the system N = number of steps in Leap - Frog dt = fraction of time in Leap - Frog steps: total steps in HMC ''' xt = [ 0.0 for k in range (np)] pt = [ 0.0 for k in range (np)] p0 = drawp(np) H = [ 0.0 for k in range (steps)] S0 = hamiltonian(x0,p0,np) #print (\"=======>\", 0,\"S0=\", S0) chain = 1 total_frac = 0.0 while chain < steps: s_stor = [ 0.0 ] xt,pt = leap_frog(N,dt,x0,p0,np) S1 = hamiltonian(xt,pt,np) frac = math . exp( - (S1 - S0)) #print frac a = min ( 1 ,frac) b = random . uniform( 0.0 , 1.0 ) if b < a: #print(\"=======>\", chain, \"S1=\",S1,frac,a,b) H[chain] = S1 x0 = xt p0 = drawp(np) S0 = hamiltonian(x0,p0,np) else : H[chain] = S0 p0 = drawp(np) chain = chain + 1 return H","title":"HMC"},{"location":"Montecarlo/Oscillator/Oscillator/#seting-constants","text":"np = 1000 N = 1000 dt = 0.001 steps = 100 Call HMC x0 = [ 1.0 for k in range (np)] x0 = [random . uniform( 0.0 , 1.0 ) for k in range (np)] H = HMC(np,N,dt,steps,x0)","title":"Seting Constants"},{"location":"Montecarlo/Oscillator/Oscillator/#plot","text":"t = [ 1.0 * k for k in range (steps)] plt . figure(figsize = [ 15 , 4 ]) plt . scatter(t,H) plt . show()","title":"Plot"},{"location":"Montecarlo/Percolation/percol/","text":"Percolation Percolation from pylab import * from scipy.ndimage import measurements L = 100 r = rand(L,L) p = 0.4 z = r < p imshow(z, origin='lower', interpolation='nearest') colorbar() title(\"Matrix\") show() lw, num = measurements.label(z) imshow(lw, origin='lower', interpolation='nearest') colorbar() title(\"Labeled clusters\") show() b = arange(lw.max() + 1) shuffle(b) shuffledLw = b[lw] imshow(shuffledLw, origin='lower', interpolation='nearest') colorbar() title(\"Labeled clusters\") show() area = measurements.sum(z, lw, index=arange(lw.max() + 1)) areaImg = area[lw] im3 = imshow(areaImg, origin='lower', interpolation='nearest') colorbar() title(\"Clusters by area\") show() sliced = measurements.find_objects(areaImg == areaImg.max()) if(len(sliced) > 0): sliceX = sliced[0][1] sliceY = sliced[0][0] plotxlim=im3.axes.get_xlim() plotylim=im3.axes.get_ylim() plot([sliceX.start, sliceX.start, sliceX.stop, sliceX.stop, sliceX.start], \\ [sliceY.start, sliceY.stop, sliceY.stop, sliceY.start, sliceY.start], \\ color=\"red\") xlim(plotxlim) ylim(plotylim) show() Final from pylab import * from scipy.ndimage import measurements L = 100 r = rand(L,L) p = 0.4 z = r<p figure(figsize=(16,5)) subplot(1,3,1) imshow(z, origin='lower', interpolation='nearest') colorbar() title(\"Matrix\") # Show image of labeled clusters (shuffled) lw, num = measurements.label(z) subplot(1,3,2) b = arange(lw.max() + 1) # create an array of values from 0 to lw.max() + 1 shuffle(b) # shuffle this array shuffledLw = b[lw] # replace all values with values from b imshow(shuffledLw, origin='lower', interpolation='nearest') # show image clusters as labeled by a shuffled lw colorbar() title(\"Labeled clusters\") # Calculate areas subplot(1,3,3) area = measurements.sum(z, lw, index=arange(lw.max() + 1)) areaImg = area[lw] im3 = imshow(areaImg, origin='lower', interpolation='nearest') colorbar() title(\"Clusters by area\") # Bounding box sliced = measurements.find_objects(areaImg == areaImg.max()) if(len(sliced) > 0): sliceX = sliced[0][1] sliceY = sliced[0][0] plotxlim=im3.axes.get_xlim() plotylim=im3.axes.get_ylim() plot([sliceX.start, sliceX.start, sliceX.stop, sliceX.stop, sliceX.start], \\ [sliceY.start, sliceY.stop, sliceY.stop, sliceY.start, sliceY.start], \\ color=\"red\") xlim(plotxlim) ylim(plotylim) show()","title":"Percolation"},{"location":"Montecarlo/Percolation/percol/#percolation","text":"","title":"Percolation"},{"location":"Montecarlo/Percolation/percol/#percolation_1","text":"from pylab import * from scipy.ndimage import measurements L = 100 r = rand(L,L) p = 0.4 z = r < p imshow(z, origin='lower', interpolation='nearest') colorbar() title(\"Matrix\") show() lw, num = measurements.label(z) imshow(lw, origin='lower', interpolation='nearest') colorbar() title(\"Labeled clusters\") show() b = arange(lw.max() + 1) shuffle(b) shuffledLw = b[lw] imshow(shuffledLw, origin='lower', interpolation='nearest') colorbar() title(\"Labeled clusters\") show() area = measurements.sum(z, lw, index=arange(lw.max() + 1)) areaImg = area[lw] im3 = imshow(areaImg, origin='lower', interpolation='nearest') colorbar() title(\"Clusters by area\") show() sliced = measurements.find_objects(areaImg == areaImg.max()) if(len(sliced) > 0): sliceX = sliced[0][1] sliceY = sliced[0][0] plotxlim=im3.axes.get_xlim() plotylim=im3.axes.get_ylim() plot([sliceX.start, sliceX.start, sliceX.stop, sliceX.stop, sliceX.start], \\ [sliceY.start, sliceY.stop, sliceY.stop, sliceY.start, sliceY.start], \\ color=\"red\") xlim(plotxlim) ylim(plotylim) show()","title":"Percolation"},{"location":"Montecarlo/Percolation/percol/#final","text":"from pylab import * from scipy.ndimage import measurements L = 100 r = rand(L,L) p = 0.4 z = r<p figure(figsize=(16,5)) subplot(1,3,1) imshow(z, origin='lower', interpolation='nearest') colorbar() title(\"Matrix\") # Show image of labeled clusters (shuffled) lw, num = measurements.label(z) subplot(1,3,2) b = arange(lw.max() + 1) # create an array of values from 0 to lw.max() + 1 shuffle(b) # shuffle this array shuffledLw = b[lw] # replace all values with values from b imshow(shuffledLw, origin='lower', interpolation='nearest') # show image clusters as labeled by a shuffled lw colorbar() title(\"Labeled clusters\") # Calculate areas subplot(1,3,3) area = measurements.sum(z, lw, index=arange(lw.max() + 1)) areaImg = area[lw] im3 = imshow(areaImg, origin='lower', interpolation='nearest') colorbar() title(\"Clusters by area\") # Bounding box sliced = measurements.find_objects(areaImg == areaImg.max()) if(len(sliced) > 0): sliceX = sliced[0][1] sliceY = sliced[0][0] plotxlim=im3.axes.get_xlim() plotylim=im3.axes.get_ylim() plot([sliceX.start, sliceX.start, sliceX.stop, sliceX.stop, sliceX.start], \\ [sliceY.start, sliceY.stop, sliceY.stop, sliceY.start, sliceY.start], \\ color=\"red\") xlim(plotxlim) ylim(plotylim) show()","title":"Final"},{"location":"PathIntegral/Intro/Intro/","text":"Density Matrix and Path Integral Naive Harmonic Path import math , random def rho_free (x, y, beta): # free off-diagonal density matrix return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) beta = 4.0 N = 8 # number of slices dtau = beta / N delta = 1.0 # maximum displacement on one slice n_steps = 10 # number of Monte Carlo steps x = [ 0.0 ] * N # initial path for step in range (n_steps): k = random . randint( 0 , N - 1 ) # random slice knext, kprev = (k + 1 ) % N, (k - 1 ) % N # next/previous slices x_new = x[k] + random . uniform( - delta, delta) # new position at slice k old_weight = (rho_free(x[knext], x[k], dtau) * rho_free(x[k], x[kprev], dtau) * math . exp( - 0.5 * dtau * x[k] ** 2 )) new_weight = (rho_free(x[knext], x_new, dtau) * rho_free(x_new, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_new ** 2 )) if random . uniform( 0.0 , 1.0 ) < new_weight / old_weight: x[k] = x_new print x [0.0, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.0, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [-0.1902541007130032, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, -0.2691021744359521, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, -0.2691021744359521, -0.05409984381515698, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, -0.2691021744359521, -0.05409984381515698, 0.0] Naive Harmonic Path Movie % matplotlib inline import math , random , pylab , os def rho_free (x, y, beta): # free off-diagonal density matrix return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) output_dir = 'snapshots_naive_harmonic_path' if not os . path . exists(output_dir): os . makedirs(output_dir) def show_path (x, k, x_old, Accepted, step): path = x + [x[ 0 ]] y_axis = range ( len (x) + 1 ) if Accepted: old_path = x[:] old_path[k] = x_old old_path = old_path + [old_path[ 0 ]] pylab . plot(old_path, y_axis, 'ro--' , label = 'old path' ) pylab . plot(path, y_axis, 'bo-' , label = 'new path' ) pylab . legend() pylab . xlim( - 5.0 , 5.0 ) pylab . xlabel( '$x$' , fontsize = 14 ) pylab . ylabel( '$ \\\\ tau$' , fontsize = 14 ) pylab . title( 'Naive path integral Monte Carlo, step %i ' % step) #pylab.savefig(output_dir + '/snapshot_%05i.png' % step) #pylab.clf() pylab . show() beta = 4.0 N = 8 # number of slices dtau = beta / N delta = 1.0 # maximum displacement on one slice n_steps = 4 # number of Monte Carlo steps x = [random . uniform( - 1.0 , 1.0 ) for k in range (N)] # initial path show_path(x, 0 , 0.0 , False , 0 ) for step in range (n_steps): print 'step' ,step k = random . randint( 0 , N - 1 ) # randomly choose slice knext, kprev = (k + 1 ) % N, (k - 1 ) % N # next/previous slices x_old = x[k] x_new = x[k] + random . uniform( - delta, delta) # new position at slice k old_weight = (rho_free(x[knext], x_old, dtau) * rho_free(x_old, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_old ** 2 )) new_weight = (rho_free(x[knext], x_new, dtau) * rho_free(x_new, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_new ** 2 )) if random . uniform( 0.0 , 1.0 ) < new_weight / old_weight: x[k] = x_new Accepted = True else : Accepted = False show_path(x, k, x_old, Accepted, step + 1 ) step 0 step 1 step 2 step 3 Matrix Square Harmonic import math , numpy # Free off-diagonal density matrix def rho_free (x, xp, beta): return (math . exp( - (x - xp) ** 2 / ( 2.0 * beta)) / math . sqrt( 2.0 * math . pi * beta)) # Harmonic density matrix in the Trotter approximation (returns the full matrix) def rho_harmonic_trotter (grid, beta): return numpy . array([[rho_free(x, xp, beta) * \\ numpy . exp( - 0.5 * beta * 0.5 * (x ** 2 + xp ** 2 )) \\ for x in grid] for xp in grid]) x_max = 5.0 # the x range is [-x_max,+x_max] nx = 100 dx = 2.0 * x_max / (nx - 1 ) x = [i * dx for i in range ( - (nx - 1 ) / 2 , nx / 2 + 1 )] beta_tmp = 2.0 ** ( - 5 ) # initial value of beta (power of 2) beta = 2.0 ** 4 # actual value of beta (power of 2) rho = rho_harmonic_trotter(x, beta_tmp) # density matrix at initial beta while beta_tmp < beta: rho = numpy . dot(rho, rho) rho *= dx beta_tmp *= 2.0 print 'beta: %s -> %s ' % (beta_tmp / 2.0 , beta_tmp) beta: 0.03125 -> 0.0625 beta: 0.0625 -> 0.125 beta: 0.125 -> 0.25 beta: 0.25 -> 0.5 beta: 0.5 -> 1.0 beta: 1.0 -> 2.0 beta: 2.0 -> 4.0 beta: 4.0 -> 8.0 beta: 8.0 -> 16.0 Matrix Square Harmonic Movie import math , numpy , pylab # Free off-diagonal density matrix def rho_free (x, xp, beta): return (math . exp( - (x - xp) ** 2 / ( 2.0 * beta)) / math . sqrt( 2.0 * math . pi * beta)) # Harmonic density matrix in the Trotter approximation (returns the full matrix) def rho_harmonic_trotter (grid, beta): return numpy . array([[rho_free(x, xp, beta) * \\ numpy . exp( - 0.5 * beta * 0.5 * (x ** 2 + xp ** 2 )) \\ for x in grid] for xp in grid]) x_max = 5.0 # the x range is [-x_max,+x_max] nx = 100 dx = 2.0 * x_max / (nx - 1 ) x = [i * dx for i in range ( - (nx - 1 ) / 2 , nx / 2 + 1 )] beta_tmp = 2.0 ** ( - 8 ) # initial value of beta (power of 2) beta = 2.0 ** 2 # actual value of beta (power of 2) rho = rho_harmonic_trotter(x, beta_tmp) # density matrix at initial beta while beta_tmp < beta: rho = numpy . dot(rho, rho) rho *= dx beta_tmp *= 2.0 # graphics output pylab . imshow(rho, extent = [ - x_max, x_max, - x_max, x_max], origin = 'lower' ) pylab . colorbar() pylab . title( '$ \\\\ beta = 2^{ %i }$' % math . log(beta, 2 )) pylab . xlabel( '$x$' , fontsize = 18 ) pylab . ylabel( '$x \\' $' , fontsize = 18 ) #pylab.savefig('plot-harmonic-rho.png') pylab . show() Harmonic Wave Function import math n_states = 4 grid_x = [i * 0.2 for i in range ( - 25 , 26 )] psi = {} for x in grid_x: psi[x] = [math . exp( - x ** 2 / 2.0 ) / math . pi ** 0.25 ] # ground state psi[x] . append(math . sqrt( 2.0 ) * x * psi[x][ 0 ]) # first excited state # other excited states (through recursion): for n in range ( 2 , n_states): psi[x] . append(math . sqrt( 2.0 / n) * x * psi[x][n - 1 ] - math . sqrt((n - 1.0 ) / n) * psi[x][n - 2 ]) for n in range (n_states): print 'level %i :' % n, [psi[x][n] for x in grid_x] level 0: [2.7991843929095964e-06, 7.458304327999357e-06, 1.9093120491923166e-05, 4.696149856362874e-05, 0.00011097756752308872, 0.0002519745490309146, 0.0005496754903223565, 0.0011520843816137305, 0.002320013042709098, 0.004488743450746296, 0.008344251073246413, 0.014903153092645628, 0.025573912975171406, 0.042164254297199076, 0.06679129832888486, 0.10165378830641791, 0.14864676809808386, 0.2088409186844682, 0.2819057534684933, 0.3656120532774727, 0.4555806720113325, 0.5454290908346697, 0.6273927923216392, 0.6933762682841502, 0.7362522621713508, 0.7511255444649425, 0.7362522621713508, 0.6933762682841502, 0.6273927923216392, 0.5454290908346697, 0.4555806720113325, 0.3656120532774727, 0.2819057534684933, 0.2088409186844682, 0.14864676809808386, 0.10165378830641791, 0.06679129832888486, 0.042164254297199076, 0.025573912975171406, 0.014903153092645628, 0.008344251073246413, 0.004488743450746296, 0.002320013042709098, 0.0011520843816137305, 0.0005496754903223565, 0.0002519745490309146, 0.00011097756752308872, 4.696149856362874e-05, 1.9093120491923166e-05, 7.458304327999357e-06, 2.7991843929095964e-06] level 1: [-1.979322266017925e-05, -5.06286486382207e-05, -0.00012420804975942648, -0.000292219787983413, -0.0006591731206633777, -0.0014253832984494556, -0.0029539624266082393, -0.00586545608691489, -0.011155379293597705, -0.020313733971388224, -0.035401659106893996, -0.05901347543207756, -0.09403413388833536, -0.1431102246586728, -0.20780575187947614, -0.2875203321790795, -0.3783928958050294, -0.4725530553312507, -0.5581449158126092, -0.620464229174492, -0.6442883651134752, -0.6170825740569735, -0.5323604375018335, -0.3922328489740365, -0.20824358689811923, 0.0, 0.20824358689811923, 0.3922328489740365, 0.5323604375018335, 0.6170825740569735, 0.6442883651134752, 0.620464229174492, 0.5581449158126092, 0.4725530553312507, 0.3783928958050294, 0.2875203321790795, 0.20780575187947614, 0.1431102246586728, 0.09403413388833536, 0.05901347543207756, 0.035401659106893996, 0.020313733971388224, 0.011155379293597705, 0.00586545608691489, 0.0029539624266082393, 0.0014253832984494556, 0.0006591731206633777, 0.000292219787983413, 0.00012420804975942648, 5.06286486382207e-05, 1.979322266017925e-05] level 2: [9.698679103487833e-05, 0.0002377436958969781, 0.0005578561539195112, 0.001252560273037993, 0.0026900541162310225, 0.0055233602814916405, 0.010836377954452331, 0.020300995234155426, 0.036287792643291364, 0.061829927775412914, 0.10030470080286633, 0.15469961059694617, 0.2264052608234536, 0.31364990904359125, 0.4099440741622393, 0.5031605813133891, 0.5759980747254336, 0.6084120587389853, 0.5820654122045782, 0.48603031285335224, 0.3221441825567376, 0.10798945045997044, -0.12421743541709435, -0.3333979216279309, -0.4789602498656741, -0.5311259660135985, -0.4789602498656741, -0.3333979216279309, -0.12421743541709435, 0.10798945045997044, 0.3221441825567376, 0.48603031285335224, 0.5820654122045782, 0.6084120587389853, 0.5759980747254336, 0.5031605813133891, 0.4099440741622393, 0.31364990904359125, 0.2264052608234536, 0.15469961059694617, 0.10030470080286633, 0.061829927775412914, 0.036287792643291364, 0.020300995234155426, 0.010836377954452331, 0.0055233602814916405, 0.0026900541162310225, 0.001252560273037993, 0.0005578561539195112, 0.0002377436958969781, 9.698679103487833e-05] level 3: [-0.0003797858177480724, -0.0008904230727075194, -0.0019938277067416796, -0.004261332735734368, -0.008686751352074272, -0.01687539855058424, -0.031209988866398874, -0.05488337067267696, -0.09162979026487528, -0.14496246447491137, -0.2167900021496088, -0.3054884678261664, -0.4038551667423139, -0.4977767788921179, -0.5667067709284037, -0.5868984204285561, -0.5375843198695371, -0.40898823122401184, -0.209632771094667, 0.030396415302535507, 0.26302962362333343, 0.4333073982061352, 0.4955243438272363, 0.42914408535388815, 0.24824405798556262, -0.0, -0.24824405798556262, -0.42914408535388815, -0.4955243438272363, -0.4333073982061352, -0.26302962362333343, -0.030396415302535507, 0.209632771094667, 0.40898823122401184, 0.5375843198695371, 0.5868984204285561, 0.5667067709284037, 0.4977767788921179, 0.4038551667423139, 0.3054884678261664, 0.2167900021496088, 0.14496246447491137, 0.09162979026487528, 0.05488337067267696, 0.031209988866398874, 0.01687539855058424, 0.008686751352074272, 0.004261332735734368, 0.0019938277067416796, 0.0008904230727075194, 0.0003797858177480724] Harmonic Wave Function Movie import math , pylab n_states = 50 grid_x = [i * 0.1 for i in range ( - 50 , 51 )] psi = {} for x in grid_x: psi[x] = [math . exp( - x ** 2 / 2.0 ) / math . pi ** 0.25 ] # ground state psi[x] . append(math . sqrt( 2.0 ) * x * psi[x][ 0 ]) # first excited state # other excited states (through recursion): for n in range ( 2 , n_states): psi[x] . append(math . sqrt( 2.0 / n) * x * psi[x][n - 1 ] - math . sqrt((n - 1.0 ) / n) * psi[x][n - 2 ]) # graphics output for n in range (n_states): shifted_psi = [psi[x][n] + n for x in grid_x] # vertical shift pylab . plot(grid_x, shifted_psi) pylab . title( 'Harmonic oscillator wavefunctions' ) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$\\psi_n(x)$ (shifted)' , fontsize = 16 ) pylab . xlim( - 5.0 , 5.0 ) #pylab.savefig('plot-harmonic_wavefunction.png') pylab . show() Harmonic Wave Function Check import math def orthonormality_check (n, m): integral_n_m = sum (psi[n][i] * psi[m][i] for i in range (nx)) * dx return integral_n_m nx = 10 L = 10.0 dx = L / (nx - 1 ) x = [ - L / 2.0 + i * dx for i in range (nx)] n_states = 4 psi = [[math . exp( - x[i] ** 2 / 2.0 ) / math . pi ** 0.25 for i in range (nx)]] psi . append([math . sqrt( 2.0 ) * x[i] * psi[ 0 ][i] for i in range (nx)]) for n in range ( 2 , n_states): psi . append([math . sqrt( 2.0 / n) * x[i] * psi[n - 1 ][i] - \\ math . sqrt((n - 1.0 ) / n) * psi[n - 2 ][i] for i in range (nx)]) n = n_states - 1 print 'checking energy level' , n H_psi = [ 0.0 ] + [( - 0.5 * (psi[n][i + 1 ] - 2.0 * psi[n][i] + psi[n][i - 1 ]) / dx ** 2 + 0.5 * x[i] ** 2 * psi[n][i]) for i in range ( 1 , nx - 1 )] for i in range ( 1 , nx - 1 ): print n, x[i], H_psi[i] / psi[n][i] checking energy level 3 3 -3.88888888889 3.00668022555 3 -2.77777777778 4.04737813751 3 -1.66666666667 2.35349806276 3 -0.555555555556 1.7484816623 3 0.555555555556 1.7484816623 3 1.66666666667 2.35349806276 3 2.77777777778 4.04737813751 3 3.88888888889 3.00668022555 Harmonic Wave Function Check Movie import math , pylab nx = 300 # nx is even, to avoid division by zero L = 10.0 dx = L / (nx - 1 ) x = [ - L / 2.0 + i * dx for i in range (nx)] # construct wavefunctions: n_states = 4 psi = [[math . exp( - x[i] ** 2 / 2.0 ) / math . pi ** 0.25 for i in range (nx)]] # ground state psi . append([math . sqrt( 2.0 ) * x[i] * psi[ 0 ][i] for i in range (nx)]) # first excited state for n in range ( 2 , n_states): psi . append([math . sqrt( 2.0 / n) * x[i] * psi[n - 1 ][i] - \\ math . sqrt((n - 1.0 ) / n) * psi[n - 2 ][i] for i in range (nx)]) # local energy check: H_psi_over_psi = [] for n in range (n_states): H_psi = [( - 0.5 * (psi[n][i + 1 ] - 2.0 * psi[n][i] + psi[n][i - 1 ]) / dx ** 2 + 0.5 * x[i] ** 2 * psi[n][i]) for i in range ( 1 , nx - 1 )] H_psi_over_psi . append([H_psi[i] / psi[n][i + 1 ] for i in range (nx - 2 )]) # graphics output: for n in range (n_states): pylab . plot(x[ 1 : - 1 ], [n + 0.5 for i in x[ 1 : - 1 ]], 'k--' , lw = 1.5 ) pylab . plot(x[ 1 : - 1 ], H_psi_over_psi[n], '-' , lw = 1.5 ) pylab . xlabel( '$x$' , fontsize = 18 ) pylab . ylabel( '$H \\psi_ %i (x)/\\psi_ %i (x)$' % (n, n), fontsize = 18 ) pylab . xlim(x[ 0 ], x[ - 1 ]) pylab . ylim(n, n + 1 ) pylab . title( 'Schroedinger equation check (local energy)' ) #pylab.savefig('plot-check_schroedinger_energy-%i.png' % n) pylab . show() TUTORIAL Free Periodic Complex Exp import math , cmath ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho_complex = [] for i in range (nx): rho_complex . append([ sum ( math . exp( - 2.0 * beta * (math . pi * n / L) ** 2 ) * cmath . exp( 1 j * 2.0 * n * math . pi * (x[i] - x[j]) / L) / L for n in range ( - (ntot - 1 ) / 2 , (ntot + 1 ) / 2 )) for j in range (nx)]) rho_real = [[rho_complex[i][j] . real for i in range (nx)] for j in range (nx)] Free Periodic Complex Movie import math , cmath , pylab ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho_complex = [] for i in range (nx): rho_complex . append([ sum ( math . exp( - 2.0 * beta * (math . pi * n / L) ** 2 ) * cmath . exp( 1 j * 2.0 * n * math . pi * (x[i] - x[j]) / L) / L for n in range ( - (ntot - 1 ) / 2 , (ntot + 1 ) / 2 )) for j in range (nx)]) rho_real = [[rho_complex[i][j] . real for i in range (nx)] for j in range (nx)] # graphics output pylab . imshow(rho_real, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (complex exp)' % beta) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) #pylab.savefig('plot-periodic-complex.png') pylab . show() Periodic Sine Cosine import math # simmetric wavefunctions def psi_s (x, L, n): return math . sqrt( 2.0 / L) * math . cos( 2.0 * n * math . pi * x / L) # antysimmetric wavefunctions def psi_a (x, L, n): return math . sqrt( 2.0 / L) * math . sin( 2.0 * n * math . pi * x / L) ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho = [] for i in range (nx): rho . append([ 1.0 / L + sum ( math . exp( - beta * 2.0 * (math . pi * n / L) ** 2 ) * (psi_s(x[i], L, n) * psi_s(x[j], L, n) + psi_a(x[i], L, n) * psi_a(x[j], L, n) ) for n in range ( 1 , (ntot + 1 ) / 2 )) for j in range (nx)]) Periodic Sine Cosine Movie import math , pylab # simmetric wavefunctions def psi_s (x, L, n): return math . sqrt( 2.0 / L) * math . cos( 2.0 * n * math . pi * x / L) # antysimmetric wavefunctions def psi_a (x, L, n): return math . sqrt( 2.0 / L) * math . sin( 2.0 * n * math . pi * x / L) ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho = [] for i in range (nx): rho . append([ 1.0 / L + sum ( math . exp( - beta * 2.0 * (math . pi * n / L) ** 2 ) * (psi_s(x[i], L, n) * psi_s(x[j], L, n) + psi_a(x[i], L, n) * psi_a(x[j], L, n) ) for n in range ( 1 , (ntot + 1 ) / 2 )) for j in range (nx)]) # graphics output pylab . imshow(rho, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (sine/cosine)' % beta) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) #pylab.savefig('plot-periodic-sine_cosine.png') pylab . show() Quantum Time Evolution import numpy , pylab , os def fourier_x_to_p (phi_x, dx): phi_p = [(phi_x * numpy . exp( - 1 j * p * grid_x)) . sum() * dx for p in grid_p] return numpy . array(phi_p) def fourier_p_to_x (phi_p, dp): phi_x = [(phi_p * numpy . exp( 1 j * x * grid_p)) . sum() for x in grid_x] return numpy . array(phi_x) / ( 2.0 * numpy . pi) def time_step_evolution (psi0, potential, grid_x, grid_p, dx, dp, delta_t): psi0 = numpy . exp( - 1 j * potential * delta_t / 2.0 ) * psi0 psi0 = fourier_x_to_p(psi0, dx) psi0 = numpy . exp( - 1 j * grid_p ** 2 * delta_t / 2.0 ) * psi0 psi0 = fourier_p_to_x(psi0, dp) psi0 = numpy . exp( - 1 j * potential * delta_t / 2.0 ) * psi0 psi0 /= (numpy . absolute(psi0 ** 2 ) . sum() * dx) return psi0 def funct_potential (x): if x < - 8.0 : return (x + 8.0 ) ** 2 elif x <= - 1.0 : return 0.0 elif x < 1.0 : return numpy . exp( - 1.0 / ( 1.0 - x ** 2 )) / numpy . exp( - 1.0 ) else : return 0.0 output_dir = 'snapshots_time_evolution' if not os . path . exists(output_dir): os . makedirs(output_dir) def show (x, psi, pot, time, timestep): pylab . plot(x, psi, 'g' , linewidth = 2.0 , label = '$|\\psi(x)|^2$' ) pylab . xlim( - 10 , 15 ) pylab . ylim( - 0.1 , 1.15 ) pylab . plot(x, pot, 'k' , linewidth = 2.0 , label = '$V(x)$' ) pylab . xlabel( '$x$' , fontsize = 20 ) pylab . title( 'time = %s ' % time) pylab . legend(loc = 1 ) #pylab.savefig(output_dir + '/snapshot_%05i.png' % timestep) timestep += 1 #pylab.clf() pylab . show() steps = 800 x_min = - 12.0 x_max = 40.0 grid_x = numpy . linspace(x_min, x_max, steps) grid_p = numpy . linspace(x_min, x_max, steps) dx = grid_x[ 1 ] - grid_x[ 0 ] dp = grid_p[ 1 ] - grid_p[ 0 ] delta_t = 0.1 t_max = 1.0 potential = [funct_potential(x) for x in grid_x] potential = numpy . array(potential) # initial state: x0 = - 8.0 sigma = . 5 psi = numpy . exp( - (grid_x - x0) ** 2 / ( 2.0 * sigma ** 2 ) ) psi /= numpy . sqrt( sigma * numpy . sqrt( numpy . pi ) ) # time evolution time = 0.0 timestep = 0 while time < t_max: if timestep % 4 == 0 : show(grid_x, numpy . absolute(psi) ** 2.0 , potential, time, timestep) print time time += delta_t timestep += 1 psi = time_step_evolution(psi, potential, grid_x, grid_p, dx, dp, delta_t) 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 Harmonic Totter import math , pylab # density matrix for a free particle (exact) def funct_rho_free (x, xp, beta): return (math . exp( - (x - xp) ** 2 / ( 2.0 * beta)) / math . sqrt( 2.0 * math . pi * beta)) beta = 0.1 nx = 300 L = 10.0 x = [ - L / 2.0 + i * L / float (nx - 1 ) for i in range (nx)] rho_free, rho_harm = [], [] for i in range (nx): rho_free . append([funct_rho_free(x[i], x[j], beta) for j in range (nx)]) rho_harm . append([rho_free[i][j] * math . exp( - beta * x[i] ** 2 / 4.0 - beta * x[j] ** 2 / 4.0 ) for j in range (nx)]) # graphics output (free particle) pylab . imshow(rho_free, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (free)' % beta) #pylab.savefig('plot-trotter-free.png') #pylab.clf() pylab . show() # graphics output (harmonic potential) pylab . imshow(rho_harm, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (harmonic)' % beta) #pylab.savefig('plot-trotter-harmonic.png') pylab . show()","title":"Path Integral"},{"location":"PathIntegral/Intro/Intro/#density-matrix-and-path-integral","text":"Naive Harmonic Path import math , random def rho_free (x, y, beta): # free off-diagonal density matrix return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) beta = 4.0 N = 8 # number of slices dtau = beta / N delta = 1.0 # maximum displacement on one slice n_steps = 10 # number of Monte Carlo steps x = [ 0.0 ] * N # initial path for step in range (n_steps): k = random . randint( 0 , N - 1 ) # random slice knext, kprev = (k + 1 ) % N, (k - 1 ) % N # next/previous slices x_new = x[k] + random . uniform( - delta, delta) # new position at slice k old_weight = (rho_free(x[knext], x[k], dtau) * rho_free(x[k], x[kprev], dtau) * math . exp( - 0.5 * dtau * x[k] ** 2 )) new_weight = (rho_free(x[knext], x_new, dtau) * rho_free(x_new, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_new ** 2 )) if random . uniform( 0.0 , 1.0 ) < new_weight / old_weight: x[k] = x_new print x [0.0, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.0, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [-0.1902541007130032, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, -0.2691021744359521, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, -0.2691021744359521, -0.05409984381515698, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, -0.2691021744359521, -0.05409984381515698, 0.0] Naive Harmonic Path Movie % matplotlib inline import math , random , pylab , os def rho_free (x, y, beta): # free off-diagonal density matrix return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) output_dir = 'snapshots_naive_harmonic_path' if not os . path . exists(output_dir): os . makedirs(output_dir) def show_path (x, k, x_old, Accepted, step): path = x + [x[ 0 ]] y_axis = range ( len (x) + 1 ) if Accepted: old_path = x[:] old_path[k] = x_old old_path = old_path + [old_path[ 0 ]] pylab . plot(old_path, y_axis, 'ro--' , label = 'old path' ) pylab . plot(path, y_axis, 'bo-' , label = 'new path' ) pylab . legend() pylab . xlim( - 5.0 , 5.0 ) pylab . xlabel( '$x$' , fontsize = 14 ) pylab . ylabel( '$ \\\\ tau$' , fontsize = 14 ) pylab . title( 'Naive path integral Monte Carlo, step %i ' % step) #pylab.savefig(output_dir + '/snapshot_%05i.png' % step) #pylab.clf() pylab . show() beta = 4.0 N = 8 # number of slices dtau = beta / N delta = 1.0 # maximum displacement on one slice n_steps = 4 # number of Monte Carlo steps x = [random . uniform( - 1.0 , 1.0 ) for k in range (N)] # initial path show_path(x, 0 , 0.0 , False , 0 ) for step in range (n_steps): print 'step' ,step k = random . randint( 0 , N - 1 ) # randomly choose slice knext, kprev = (k + 1 ) % N, (k - 1 ) % N # next/previous slices x_old = x[k] x_new = x[k] + random . uniform( - delta, delta) # new position at slice k old_weight = (rho_free(x[knext], x_old, dtau) * rho_free(x_old, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_old ** 2 )) new_weight = (rho_free(x[knext], x_new, dtau) * rho_free(x_new, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_new ** 2 )) if random . uniform( 0.0 , 1.0 ) < new_weight / old_weight: x[k] = x_new Accepted = True else : Accepted = False show_path(x, k, x_old, Accepted, step + 1 ) step 0 step 1 step 2 step 3 Matrix Square Harmonic import math , numpy # Free off-diagonal density matrix def rho_free (x, xp, beta): return (math . exp( - (x - xp) ** 2 / ( 2.0 * beta)) / math . sqrt( 2.0 * math . pi * beta)) # Harmonic density matrix in the Trotter approximation (returns the full matrix) def rho_harmonic_trotter (grid, beta): return numpy . array([[rho_free(x, xp, beta) * \\ numpy . exp( - 0.5 * beta * 0.5 * (x ** 2 + xp ** 2 )) \\ for x in grid] for xp in grid]) x_max = 5.0 # the x range is [-x_max,+x_max] nx = 100 dx = 2.0 * x_max / (nx - 1 ) x = [i * dx for i in range ( - (nx - 1 ) / 2 , nx / 2 + 1 )] beta_tmp = 2.0 ** ( - 5 ) # initial value of beta (power of 2) beta = 2.0 ** 4 # actual value of beta (power of 2) rho = rho_harmonic_trotter(x, beta_tmp) # density matrix at initial beta while beta_tmp < beta: rho = numpy . dot(rho, rho) rho *= dx beta_tmp *= 2.0 print 'beta: %s -> %s ' % (beta_tmp / 2.0 , beta_tmp) beta: 0.03125 -> 0.0625 beta: 0.0625 -> 0.125 beta: 0.125 -> 0.25 beta: 0.25 -> 0.5 beta: 0.5 -> 1.0 beta: 1.0 -> 2.0 beta: 2.0 -> 4.0 beta: 4.0 -> 8.0 beta: 8.0 -> 16.0 Matrix Square Harmonic Movie import math , numpy , pylab # Free off-diagonal density matrix def rho_free (x, xp, beta): return (math . exp( - (x - xp) ** 2 / ( 2.0 * beta)) / math . sqrt( 2.0 * math . pi * beta)) # Harmonic density matrix in the Trotter approximation (returns the full matrix) def rho_harmonic_trotter (grid, beta): return numpy . array([[rho_free(x, xp, beta) * \\ numpy . exp( - 0.5 * beta * 0.5 * (x ** 2 + xp ** 2 )) \\ for x in grid] for xp in grid]) x_max = 5.0 # the x range is [-x_max,+x_max] nx = 100 dx = 2.0 * x_max / (nx - 1 ) x = [i * dx for i in range ( - (nx - 1 ) / 2 , nx / 2 + 1 )] beta_tmp = 2.0 ** ( - 8 ) # initial value of beta (power of 2) beta = 2.0 ** 2 # actual value of beta (power of 2) rho = rho_harmonic_trotter(x, beta_tmp) # density matrix at initial beta while beta_tmp < beta: rho = numpy . dot(rho, rho) rho *= dx beta_tmp *= 2.0 # graphics output pylab . imshow(rho, extent = [ - x_max, x_max, - x_max, x_max], origin = 'lower' ) pylab . colorbar() pylab . title( '$ \\\\ beta = 2^{ %i }$' % math . log(beta, 2 )) pylab . xlabel( '$x$' , fontsize = 18 ) pylab . ylabel( '$x \\' $' , fontsize = 18 ) #pylab.savefig('plot-harmonic-rho.png') pylab . show() Harmonic Wave Function import math n_states = 4 grid_x = [i * 0.2 for i in range ( - 25 , 26 )] psi = {} for x in grid_x: psi[x] = [math . exp( - x ** 2 / 2.0 ) / math . pi ** 0.25 ] # ground state psi[x] . append(math . sqrt( 2.0 ) * x * psi[x][ 0 ]) # first excited state # other excited states (through recursion): for n in range ( 2 , n_states): psi[x] . append(math . sqrt( 2.0 / n) * x * psi[x][n - 1 ] - math . sqrt((n - 1.0 ) / n) * psi[x][n - 2 ]) for n in range (n_states): print 'level %i :' % n, [psi[x][n] for x in grid_x] level 0: [2.7991843929095964e-06, 7.458304327999357e-06, 1.9093120491923166e-05, 4.696149856362874e-05, 0.00011097756752308872, 0.0002519745490309146, 0.0005496754903223565, 0.0011520843816137305, 0.002320013042709098, 0.004488743450746296, 0.008344251073246413, 0.014903153092645628, 0.025573912975171406, 0.042164254297199076, 0.06679129832888486, 0.10165378830641791, 0.14864676809808386, 0.2088409186844682, 0.2819057534684933, 0.3656120532774727, 0.4555806720113325, 0.5454290908346697, 0.6273927923216392, 0.6933762682841502, 0.7362522621713508, 0.7511255444649425, 0.7362522621713508, 0.6933762682841502, 0.6273927923216392, 0.5454290908346697, 0.4555806720113325, 0.3656120532774727, 0.2819057534684933, 0.2088409186844682, 0.14864676809808386, 0.10165378830641791, 0.06679129832888486, 0.042164254297199076, 0.025573912975171406, 0.014903153092645628, 0.008344251073246413, 0.004488743450746296, 0.002320013042709098, 0.0011520843816137305, 0.0005496754903223565, 0.0002519745490309146, 0.00011097756752308872, 4.696149856362874e-05, 1.9093120491923166e-05, 7.458304327999357e-06, 2.7991843929095964e-06] level 1: [-1.979322266017925e-05, -5.06286486382207e-05, -0.00012420804975942648, -0.000292219787983413, -0.0006591731206633777, -0.0014253832984494556, -0.0029539624266082393, -0.00586545608691489, -0.011155379293597705, -0.020313733971388224, -0.035401659106893996, -0.05901347543207756, -0.09403413388833536, -0.1431102246586728, -0.20780575187947614, -0.2875203321790795, -0.3783928958050294, -0.4725530553312507, -0.5581449158126092, -0.620464229174492, -0.6442883651134752, -0.6170825740569735, -0.5323604375018335, -0.3922328489740365, -0.20824358689811923, 0.0, 0.20824358689811923, 0.3922328489740365, 0.5323604375018335, 0.6170825740569735, 0.6442883651134752, 0.620464229174492, 0.5581449158126092, 0.4725530553312507, 0.3783928958050294, 0.2875203321790795, 0.20780575187947614, 0.1431102246586728, 0.09403413388833536, 0.05901347543207756, 0.035401659106893996, 0.020313733971388224, 0.011155379293597705, 0.00586545608691489, 0.0029539624266082393, 0.0014253832984494556, 0.0006591731206633777, 0.000292219787983413, 0.00012420804975942648, 5.06286486382207e-05, 1.979322266017925e-05] level 2: [9.698679103487833e-05, 0.0002377436958969781, 0.0005578561539195112, 0.001252560273037993, 0.0026900541162310225, 0.0055233602814916405, 0.010836377954452331, 0.020300995234155426, 0.036287792643291364, 0.061829927775412914, 0.10030470080286633, 0.15469961059694617, 0.2264052608234536, 0.31364990904359125, 0.4099440741622393, 0.5031605813133891, 0.5759980747254336, 0.6084120587389853, 0.5820654122045782, 0.48603031285335224, 0.3221441825567376, 0.10798945045997044, -0.12421743541709435, -0.3333979216279309, -0.4789602498656741, -0.5311259660135985, -0.4789602498656741, -0.3333979216279309, -0.12421743541709435, 0.10798945045997044, 0.3221441825567376, 0.48603031285335224, 0.5820654122045782, 0.6084120587389853, 0.5759980747254336, 0.5031605813133891, 0.4099440741622393, 0.31364990904359125, 0.2264052608234536, 0.15469961059694617, 0.10030470080286633, 0.061829927775412914, 0.036287792643291364, 0.020300995234155426, 0.010836377954452331, 0.0055233602814916405, 0.0026900541162310225, 0.001252560273037993, 0.0005578561539195112, 0.0002377436958969781, 9.698679103487833e-05] level 3: [-0.0003797858177480724, -0.0008904230727075194, -0.0019938277067416796, -0.004261332735734368, -0.008686751352074272, -0.01687539855058424, -0.031209988866398874, -0.05488337067267696, -0.09162979026487528, -0.14496246447491137, -0.2167900021496088, -0.3054884678261664, -0.4038551667423139, -0.4977767788921179, -0.5667067709284037, -0.5868984204285561, -0.5375843198695371, -0.40898823122401184, -0.209632771094667, 0.030396415302535507, 0.26302962362333343, 0.4333073982061352, 0.4955243438272363, 0.42914408535388815, 0.24824405798556262, -0.0, -0.24824405798556262, -0.42914408535388815, -0.4955243438272363, -0.4333073982061352, -0.26302962362333343, -0.030396415302535507, 0.209632771094667, 0.40898823122401184, 0.5375843198695371, 0.5868984204285561, 0.5667067709284037, 0.4977767788921179, 0.4038551667423139, 0.3054884678261664, 0.2167900021496088, 0.14496246447491137, 0.09162979026487528, 0.05488337067267696, 0.031209988866398874, 0.01687539855058424, 0.008686751352074272, 0.004261332735734368, 0.0019938277067416796, 0.0008904230727075194, 0.0003797858177480724] Harmonic Wave Function Movie import math , pylab n_states = 50 grid_x = [i * 0.1 for i in range ( - 50 , 51 )] psi = {} for x in grid_x: psi[x] = [math . exp( - x ** 2 / 2.0 ) / math . pi ** 0.25 ] # ground state psi[x] . append(math . sqrt( 2.0 ) * x * psi[x][ 0 ]) # first excited state # other excited states (through recursion): for n in range ( 2 , n_states): psi[x] . append(math . sqrt( 2.0 / n) * x * psi[x][n - 1 ] - math . sqrt((n - 1.0 ) / n) * psi[x][n - 2 ]) # graphics output for n in range (n_states): shifted_psi = [psi[x][n] + n for x in grid_x] # vertical shift pylab . plot(grid_x, shifted_psi) pylab . title( 'Harmonic oscillator wavefunctions' ) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$\\psi_n(x)$ (shifted)' , fontsize = 16 ) pylab . xlim( - 5.0 , 5.0 ) #pylab.savefig('plot-harmonic_wavefunction.png') pylab . show() Harmonic Wave Function Check import math def orthonormality_check (n, m): integral_n_m = sum (psi[n][i] * psi[m][i] for i in range (nx)) * dx return integral_n_m nx = 10 L = 10.0 dx = L / (nx - 1 ) x = [ - L / 2.0 + i * dx for i in range (nx)] n_states = 4 psi = [[math . exp( - x[i] ** 2 / 2.0 ) / math . pi ** 0.25 for i in range (nx)]] psi . append([math . sqrt( 2.0 ) * x[i] * psi[ 0 ][i] for i in range (nx)]) for n in range ( 2 , n_states): psi . append([math . sqrt( 2.0 / n) * x[i] * psi[n - 1 ][i] - \\ math . sqrt((n - 1.0 ) / n) * psi[n - 2 ][i] for i in range (nx)]) n = n_states - 1 print 'checking energy level' , n H_psi = [ 0.0 ] + [( - 0.5 * (psi[n][i + 1 ] - 2.0 * psi[n][i] + psi[n][i - 1 ]) / dx ** 2 + 0.5 * x[i] ** 2 * psi[n][i]) for i in range ( 1 , nx - 1 )] for i in range ( 1 , nx - 1 ): print n, x[i], H_psi[i] / psi[n][i] checking energy level 3 3 -3.88888888889 3.00668022555 3 -2.77777777778 4.04737813751 3 -1.66666666667 2.35349806276 3 -0.555555555556 1.7484816623 3 0.555555555556 1.7484816623 3 1.66666666667 2.35349806276 3 2.77777777778 4.04737813751 3 3.88888888889 3.00668022555 Harmonic Wave Function Check Movie import math , pylab nx = 300 # nx is even, to avoid division by zero L = 10.0 dx = L / (nx - 1 ) x = [ - L / 2.0 + i * dx for i in range (nx)] # construct wavefunctions: n_states = 4 psi = [[math . exp( - x[i] ** 2 / 2.0 ) / math . pi ** 0.25 for i in range (nx)]] # ground state psi . append([math . sqrt( 2.0 ) * x[i] * psi[ 0 ][i] for i in range (nx)]) # first excited state for n in range ( 2 , n_states): psi . append([math . sqrt( 2.0 / n) * x[i] * psi[n - 1 ][i] - \\ math . sqrt((n - 1.0 ) / n) * psi[n - 2 ][i] for i in range (nx)]) # local energy check: H_psi_over_psi = [] for n in range (n_states): H_psi = [( - 0.5 * (psi[n][i + 1 ] - 2.0 * psi[n][i] + psi[n][i - 1 ]) / dx ** 2 + 0.5 * x[i] ** 2 * psi[n][i]) for i in range ( 1 , nx - 1 )] H_psi_over_psi . append([H_psi[i] / psi[n][i + 1 ] for i in range (nx - 2 )]) # graphics output: for n in range (n_states): pylab . plot(x[ 1 : - 1 ], [n + 0.5 for i in x[ 1 : - 1 ]], 'k--' , lw = 1.5 ) pylab . plot(x[ 1 : - 1 ], H_psi_over_psi[n], '-' , lw = 1.5 ) pylab . xlabel( '$x$' , fontsize = 18 ) pylab . ylabel( '$H \\psi_ %i (x)/\\psi_ %i (x)$' % (n, n), fontsize = 18 ) pylab . xlim(x[ 0 ], x[ - 1 ]) pylab . ylim(n, n + 1 ) pylab . title( 'Schroedinger equation check (local energy)' ) #pylab.savefig('plot-check_schroedinger_energy-%i.png' % n) pylab . show()","title":"Density Matrix and Path Integral"},{"location":"PathIntegral/Intro/Intro/#tutorial","text":"Free Periodic Complex Exp import math , cmath ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho_complex = [] for i in range (nx): rho_complex . append([ sum ( math . exp( - 2.0 * beta * (math . pi * n / L) ** 2 ) * cmath . exp( 1 j * 2.0 * n * math . pi * (x[i] - x[j]) / L) / L for n in range ( - (ntot - 1 ) / 2 , (ntot + 1 ) / 2 )) for j in range (nx)]) rho_real = [[rho_complex[i][j] . real for i in range (nx)] for j in range (nx)] Free Periodic Complex Movie import math , cmath , pylab ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho_complex = [] for i in range (nx): rho_complex . append([ sum ( math . exp( - 2.0 * beta * (math . pi * n / L) ** 2 ) * cmath . exp( 1 j * 2.0 * n * math . pi * (x[i] - x[j]) / L) / L for n in range ( - (ntot - 1 ) / 2 , (ntot + 1 ) / 2 )) for j in range (nx)]) rho_real = [[rho_complex[i][j] . real for i in range (nx)] for j in range (nx)] # graphics output pylab . imshow(rho_real, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (complex exp)' % beta) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) #pylab.savefig('plot-periodic-complex.png') pylab . show() Periodic Sine Cosine import math # simmetric wavefunctions def psi_s (x, L, n): return math . sqrt( 2.0 / L) * math . cos( 2.0 * n * math . pi * x / L) # antysimmetric wavefunctions def psi_a (x, L, n): return math . sqrt( 2.0 / L) * math . sin( 2.0 * n * math . pi * x / L) ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho = [] for i in range (nx): rho . append([ 1.0 / L + sum ( math . exp( - beta * 2.0 * (math . pi * n / L) ** 2 ) * (psi_s(x[i], L, n) * psi_s(x[j], L, n) + psi_a(x[i], L, n) * psi_a(x[j], L, n) ) for n in range ( 1 , (ntot + 1 ) / 2 )) for j in range (nx)]) Periodic Sine Cosine Movie import math , pylab # simmetric wavefunctions def psi_s (x, L, n): return math . sqrt( 2.0 / L) * math . cos( 2.0 * n * math . pi * x / L) # antysimmetric wavefunctions def psi_a (x, L, n): return math . sqrt( 2.0 / L) * math . sin( 2.0 * n * math . pi * x / L) ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho = [] for i in range (nx): rho . append([ 1.0 / L + sum ( math . exp( - beta * 2.0 * (math . pi * n / L) ** 2 ) * (psi_s(x[i], L, n) * psi_s(x[j], L, n) + psi_a(x[i], L, n) * psi_a(x[j], L, n) ) for n in range ( 1 , (ntot + 1 ) / 2 )) for j in range (nx)]) # graphics output pylab . imshow(rho, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (sine/cosine)' % beta) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) #pylab.savefig('plot-periodic-sine_cosine.png') pylab . show() Quantum Time Evolution import numpy , pylab , os def fourier_x_to_p (phi_x, dx): phi_p = [(phi_x * numpy . exp( - 1 j * p * grid_x)) . sum() * dx for p in grid_p] return numpy . array(phi_p) def fourier_p_to_x (phi_p, dp): phi_x = [(phi_p * numpy . exp( 1 j * x * grid_p)) . sum() for x in grid_x] return numpy . array(phi_x) / ( 2.0 * numpy . pi) def time_step_evolution (psi0, potential, grid_x, grid_p, dx, dp, delta_t): psi0 = numpy . exp( - 1 j * potential * delta_t / 2.0 ) * psi0 psi0 = fourier_x_to_p(psi0, dx) psi0 = numpy . exp( - 1 j * grid_p ** 2 * delta_t / 2.0 ) * psi0 psi0 = fourier_p_to_x(psi0, dp) psi0 = numpy . exp( - 1 j * potential * delta_t / 2.0 ) * psi0 psi0 /= (numpy . absolute(psi0 ** 2 ) . sum() * dx) return psi0 def funct_potential (x): if x < - 8.0 : return (x + 8.0 ) ** 2 elif x <= - 1.0 : return 0.0 elif x < 1.0 : return numpy . exp( - 1.0 / ( 1.0 - x ** 2 )) / numpy . exp( - 1.0 ) else : return 0.0 output_dir = 'snapshots_time_evolution' if not os . path . exists(output_dir): os . makedirs(output_dir) def show (x, psi, pot, time, timestep): pylab . plot(x, psi, 'g' , linewidth = 2.0 , label = '$|\\psi(x)|^2$' ) pylab . xlim( - 10 , 15 ) pylab . ylim( - 0.1 , 1.15 ) pylab . plot(x, pot, 'k' , linewidth = 2.0 , label = '$V(x)$' ) pylab . xlabel( '$x$' , fontsize = 20 ) pylab . title( 'time = %s ' % time) pylab . legend(loc = 1 ) #pylab.savefig(output_dir + '/snapshot_%05i.png' % timestep) timestep += 1 #pylab.clf() pylab . show() steps = 800 x_min = - 12.0 x_max = 40.0 grid_x = numpy . linspace(x_min, x_max, steps) grid_p = numpy . linspace(x_min, x_max, steps) dx = grid_x[ 1 ] - grid_x[ 0 ] dp = grid_p[ 1 ] - grid_p[ 0 ] delta_t = 0.1 t_max = 1.0 potential = [funct_potential(x) for x in grid_x] potential = numpy . array(potential) # initial state: x0 = - 8.0 sigma = . 5 psi = numpy . exp( - (grid_x - x0) ** 2 / ( 2.0 * sigma ** 2 ) ) psi /= numpy . sqrt( sigma * numpy . sqrt( numpy . pi ) ) # time evolution time = 0.0 timestep = 0 while time < t_max: if timestep % 4 == 0 : show(grid_x, numpy . absolute(psi) ** 2.0 , potential, time, timestep) print time time += delta_t timestep += 1 psi = time_step_evolution(psi, potential, grid_x, grid_p, dx, dp, delta_t) 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 Harmonic Totter import math , pylab # density matrix for a free particle (exact) def funct_rho_free (x, xp, beta): return (math . exp( - (x - xp) ** 2 / ( 2.0 * beta)) / math . sqrt( 2.0 * math . pi * beta)) beta = 0.1 nx = 300 L = 10.0 x = [ - L / 2.0 + i * L / float (nx - 1 ) for i in range (nx)] rho_free, rho_harm = [], [] for i in range (nx): rho_free . append([funct_rho_free(x[i], x[j], beta) for j in range (nx)]) rho_harm . append([rho_free[i][j] * math . exp( - beta * x[i] ** 2 / 4.0 - beta * x[j] ** 2 / 4.0 ) for j in range (nx)]) # graphics output (free particle) pylab . imshow(rho_free, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (free)' % beta) #pylab.savefig('plot-trotter-free.png') #pylab.clf() pylab . show() # graphics output (harmonic potential) pylab . imshow(rho_harm, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (harmonic)' % beta) #pylab.savefig('plot-trotter-harmonic.png') pylab . show()","title":"TUTORIAL"}]}