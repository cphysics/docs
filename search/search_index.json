{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Computational Physics Computational physics is the study and implementation of numerical analysis to solve problems in physics for which a quantitative theory already exists. Historically, computational physics was the first application of modern computers in science, and is now a subset of computational science ('Wikipedia'). In this Online document we will discuss from getting started with Python to Numerical Methods, Fractals and Chaos, Monte Carlo Simulation, Path Integral method, Signal Processing, Partial Differential Equations, Network and Complex System, Neural Networks, Nature Inspired Computing, Parallel and Distributed Computing, Blockchain, Quantum Computing.","title":"Home"},{"location":"#computational-physics","text":"Computational physics is the study and implementation of numerical analysis to solve problems in physics for which a quantitative theory already exists. Historically, computational physics was the first application of modern computers in science, and is now a subset of computational science ('Wikipedia'). In this Online document we will discuss from getting started with Python to Numerical Methods, Fractals and Chaos, Monte Carlo Simulation, Path Integral method, Signal Processing, Partial Differential Equations, Network and Complex System, Neural Networks, Nature Inspired Computing, Parallel and Distributed Computing, Blockchain, Quantum Computing.","title":"Computational Physics"},{"location":"References/","text":"References Mkdocs Deploy MkDocs MkDoc Black and Blue Codehilit Syntax highlight all Syntax highlight code","title":"References"},{"location":"References/#references","text":"","title":"References"},{"location":"References/#mkdocs","text":"Deploy MkDocs MkDoc Black and Blue Codehilit Syntax highlight all Syntax highlight code","title":"Mkdocs"},{"location":"UnderConstruction/","text":"Under Construction This page is under Construction","title":"Under Construction"},{"location":"UnderConstruction/#under-construction","text":"This page is under Construction","title":"Under Construction"},{"location":"prog/","text":"Introduction to Python programming Course Track: Fundamental DataStructure Loops and Condition Project Fern Function and Class Project N-charges Project Random Walk Project Diffusion","title":"Introduction"},{"location":"prog/#introduction-to-python-programming","text":"Course Track: Fundamental DataStructure Loops and Condition Project Fern Function and Class Project N-charges Project Random Walk Project Diffusion","title":"Introduction to Python programming"},{"location":"DataStructure/ds/","text":"Fundamental Data Structure : List, Tuple and Dictionary List To initiate a blank List. l = [] To find the type of the object. type (l) list To create a list from scratch. L = [ 1 , 2 , 3 , 4 , 5 , 6 ] Indexing of list. L[ 0 ],L[ 1 ],L[ 5 ] (1, 2, 6) Revers indexing is also possible. L[ - 1 ],L[ - 2 ],L[ - 3 ] (6, 5, 4) To find the length of list. len (L) 6 To add the element from last. L . append( 12 ) L [1, 2, 3, 4, 5, 6, 12] To find the sum of the elements (if they are of same types like int. double etc) sum (L) 33 To find maximum and minimum of the list max (L), min (L) (12, 1) To create a list of heterogeneous element types. L = [ 1 , 2.0 , 3 , 4 , 5 , \"Apple\" ] To find the type of elements of a list. type (L[ 1 ]), type (L[ 5 ]) (float, str) To create a list of list. L = [[ 1 , 2 , 3 ],[ 3 , 4 , 5 ],[ 5 , 7 , 9 ]] To find list inside a list. L[ 0 ] [1, 2, 3] L[ 0 ][ 1 ] 2 To add list L1 = [ 1 , 2 , 3 ] ; L2 = [ 2 , 4 , 6 ] L1 + L2, set (L1 + L2) ([1, 2, 3, 2, 4, 6], {1, 2, 3, 4, 6}) To create array for algebraic operations import numpy as np L1 = np . array([ 1 , 2 , 3 ]); L2 = np . array([ 2 , 4 , 6 ]) L1 + L2 array([3, 6, 9]) To iterate over the element of list L = [i for i in range ( 10 )] L [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] To create a random List import random as random L = [random . uniform( 0 , 1 ) for k in range ( 10 )] L [0.43053490647858217, 0.4042754547551368, 0.4825961844418639, 0.07969436319497114, 0.5359042493237792, 0.521045536638314, 0.9657067090287339, 0.11515389590934644, 0.20310645682803774, 0.3875919385817722] To create a random list of lists LL = [[random . uniform( 0 , 1 ) for k in range ( 3 )] for l in range ( 3 )] LL [[0.27628847122005273, 0.8897450734835115, 0.18989122408874082], [0.13835865058469599, 0.7262672634594681, 0.10898554004253247], [0.42276719493338266, 0.11377775037902738, 0.4901096855852801]] To save the data to json file import json with open ( 'data/mylist.json' , 'w' ) as f1: json . dump(LL,f1) Tuples To define a tuples from scratch t = ( 2 , 3 , 4 , 5 ) Find type type (t) tuple Indexing t[ 1 ] 3 Dictionary To initiate a dictionary D = dict () DD = {} Create a dictionary from scratch D = { \"fruit\" : 'apple' , \"vegetable\" : 'carrot' , \"rice\" : 2.0 , 'milk' : 10 ,} What are keys? D . keys() dict_keys(['fruit', 'vegetable', 'rice', 'milk']) What are values? D . values() dict_values(['apple', 'carrot', 2.0, 10]) Indexing D[ 'fruit' ] 'apple' Iteration over key and values for key,value in D . items(): print (key,value) fruit apple vegetable carrot rice 2.0 milk 10 Update a dictionary D . update({ \"salt\" : 2.0 }) D {'fruit': 'apple', 'vegetable': 'carrot', 'rice': 2.0, 'milk': 10, 'salt': 2.0} Create a list form a Dictionary list (D) ['fruit', 'vegetable', 'rice', 'milk', 'salt'] Create a list of keys list (D . keys()) ['fruit', 'vegetable', 'rice', 'milk', 'salt'] Create a list of values list (D . values()) ['apple', 'carrot', 2.0, 10, 2.0] Create a random Dictionary DD = {} for item in [ 'A' , 'B' , 'C' , 'D' , 'E' ]: DD . update({item:[random . uniform( 0 , 1 ) for k in range ( 10 )]}) DD {'A': [0.8623300586958146, 0.9817282451404751, 0.918013419185538, 0.7163654763224003, 0.9605939306786828, 0.10535569850024595, 0.11017993829505879, 0.7967874445465515, 0.40100560974033395, 0.6683804538904957], 'B': [0.9108032733225849, 0.5126845596833859, 0.2889475226297349, 0.4361419616905007, 0.9162781988261498, 0.6417420997937421, 0.5703303219382578, 0.8317203028864074, 0.9987773067590386, 0.19901433153401582], 'C': [0.6877286885216957, 0.16565933820204293, 0.25063345210121424, 0.31595887595060124, 0.03522116131022823, 0.5286776181365936, 0.8154337189974739, 0.8202821745739262, 0.0672014040433101, 0.12327287509980445], 'D': [0.4836330819912691, 0.8546497284804153, 0.14752285825255218, 0.5918584543549938, 0.14518319590340412, 0.025762251428333438, 0.016788596008689316, 0.009725555304236244, 0.8177641188673302, 0.5450138847266498], 'E': [0.6456541452062622, 0.7662672636891902, 0.04445215914793821, 0.3159171150800496, 0.9400712936126994, 0.6085210458061509, 0.6029509689621034, 0.34555270993185316, 0.7452915466172698, 0.03229045002223074]} Save a dictionary to a json file import json with open ( 'data/mydic.json' , 'w' ) as f2: json . dump(DD,f2)","title":"DataStructure"},{"location":"DataStructure/ds/#fundamental-data-structure","text":"","title":"Fundamental Data Structure :"},{"location":"DataStructure/ds/#list-tuple-and-dictionary","text":"","title":"List, Tuple and Dictionary"},{"location":"DataStructure/ds/#list","text":"To initiate a blank List. l = [] To find the type of the object. type (l) list To create a list from scratch. L = [ 1 , 2 , 3 , 4 , 5 , 6 ] Indexing of list. L[ 0 ],L[ 1 ],L[ 5 ] (1, 2, 6) Revers indexing is also possible. L[ - 1 ],L[ - 2 ],L[ - 3 ] (6, 5, 4) To find the length of list. len (L) 6 To add the element from last. L . append( 12 ) L [1, 2, 3, 4, 5, 6, 12] To find the sum of the elements (if they are of same types like int. double etc) sum (L) 33 To find maximum and minimum of the list max (L), min (L) (12, 1) To create a list of heterogeneous element types. L = [ 1 , 2.0 , 3 , 4 , 5 , \"Apple\" ] To find the type of elements of a list. type (L[ 1 ]), type (L[ 5 ]) (float, str) To create a list of list. L = [[ 1 , 2 , 3 ],[ 3 , 4 , 5 ],[ 5 , 7 , 9 ]] To find list inside a list. L[ 0 ] [1, 2, 3] L[ 0 ][ 1 ] 2 To add list L1 = [ 1 , 2 , 3 ] ; L2 = [ 2 , 4 , 6 ] L1 + L2, set (L1 + L2) ([1, 2, 3, 2, 4, 6], {1, 2, 3, 4, 6}) To create array for algebraic operations import numpy as np L1 = np . array([ 1 , 2 , 3 ]); L2 = np . array([ 2 , 4 , 6 ]) L1 + L2 array([3, 6, 9]) To iterate over the element of list L = [i for i in range ( 10 )] L [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] To create a random List import random as random L = [random . uniform( 0 , 1 ) for k in range ( 10 )] L [0.43053490647858217, 0.4042754547551368, 0.4825961844418639, 0.07969436319497114, 0.5359042493237792, 0.521045536638314, 0.9657067090287339, 0.11515389590934644, 0.20310645682803774, 0.3875919385817722] To create a random list of lists LL = [[random . uniform( 0 , 1 ) for k in range ( 3 )] for l in range ( 3 )] LL [[0.27628847122005273, 0.8897450734835115, 0.18989122408874082], [0.13835865058469599, 0.7262672634594681, 0.10898554004253247], [0.42276719493338266, 0.11377775037902738, 0.4901096855852801]] To save the data to json file import json with open ( 'data/mylist.json' , 'w' ) as f1: json . dump(LL,f1)","title":"List"},{"location":"DataStructure/ds/#tuples","text":"To define a tuples from scratch t = ( 2 , 3 , 4 , 5 ) Find type type (t) tuple Indexing t[ 1 ] 3","title":"Tuples"},{"location":"DataStructure/ds/#dictionary","text":"To initiate a dictionary D = dict () DD = {} Create a dictionary from scratch D = { \"fruit\" : 'apple' , \"vegetable\" : 'carrot' , \"rice\" : 2.0 , 'milk' : 10 ,} What are keys? D . keys() dict_keys(['fruit', 'vegetable', 'rice', 'milk']) What are values? D . values() dict_values(['apple', 'carrot', 2.0, 10]) Indexing D[ 'fruit' ] 'apple' Iteration over key and values for key,value in D . items(): print (key,value) fruit apple vegetable carrot rice 2.0 milk 10 Update a dictionary D . update({ \"salt\" : 2.0 }) D {'fruit': 'apple', 'vegetable': 'carrot', 'rice': 2.0, 'milk': 10, 'salt': 2.0} Create a list form a Dictionary list (D) ['fruit', 'vegetable', 'rice', 'milk', 'salt'] Create a list of keys list (D . keys()) ['fruit', 'vegetable', 'rice', 'milk', 'salt'] Create a list of values list (D . values()) ['apple', 'carrot', 2.0, 10, 2.0] Create a random Dictionary DD = {} for item in [ 'A' , 'B' , 'C' , 'D' , 'E' ]: DD . update({item:[random . uniform( 0 , 1 ) for k in range ( 10 )]}) DD {'A': [0.8623300586958146, 0.9817282451404751, 0.918013419185538, 0.7163654763224003, 0.9605939306786828, 0.10535569850024595, 0.11017993829505879, 0.7967874445465515, 0.40100560974033395, 0.6683804538904957], 'B': [0.9108032733225849, 0.5126845596833859, 0.2889475226297349, 0.4361419616905007, 0.9162781988261498, 0.6417420997937421, 0.5703303219382578, 0.8317203028864074, 0.9987773067590386, 0.19901433153401582], 'C': [0.6877286885216957, 0.16565933820204293, 0.25063345210121424, 0.31595887595060124, 0.03522116131022823, 0.5286776181365936, 0.8154337189974739, 0.8202821745739262, 0.0672014040433101, 0.12327287509980445], 'D': [0.4836330819912691, 0.8546497284804153, 0.14752285825255218, 0.5918584543549938, 0.14518319590340412, 0.025762251428333438, 0.016788596008689316, 0.009725555304236244, 0.8177641188673302, 0.5450138847266498], 'E': [0.6456541452062622, 0.7662672636891902, 0.04445215914793821, 0.3159171150800496, 0.9400712936126994, 0.6085210458061509, 0.6029509689621034, 0.34555270993185316, 0.7452915466172698, 0.03229045002223074]} Save a dictionary to a json file import json with open ( 'data/mydic.json' , 'w' ) as f2: json . dump(DD,f2)","title":"Dictionary"},{"location":"FunctionClass/fnc/","text":"Functions and Classes import numpy as np Class Circle Define a function which will take radious as input and provides area as output for a circle. def area (r): A = np . pi * r ** 2 return A Claculate the area of a sample circle of radius 10. area( 10 ) 314.1592653589793 Define a function which will take radious as input and provides circumference as output for a circle. def circumference (r): C = 2 * np . pi * r return C Claculate the circumference of a sample circle of radius 10. circumference( 10 ) 62.83185307179586 Lets build a class implementing above constants and functions class Circle (): def __init__ ( self , r): self . r = r def area ( self ): A = np . pi * self . r ** 2 return A def circumference ( self ): C = 2 * np . pi * self . r return C Test using examples Circle( 5 ) . area() 78.53981633974483 CC = Circle( 5 ) CC . area(),CC . circumference() (78.53981633974483, 31.41592653589793) CC . r 5 for r in [ 2 , 3 , 6 , 24 , 25 , 46 , 567 ]: CC = Circle(r) print ( \"radius: \" , r,\\ \"area : \" , CC . area(),\\ \"circumf : \" , CC . circumference()) radius: 2 area : 12.566370614359172 circumf : 12.566370614359172 radius: 3 area : 28.274333882308138 circumf : 18.84955592153876 radius: 6 area : 113.09733552923255 circumf : 37.69911184307752 radius: 24 area : 1809.5573684677208 circumf : 150.79644737231007 radius: 25 area : 1963.4954084936207 circumf : 157.07963267948966 radius: 46 area : 6647.610054996002 circumf : 289.02652413026095 radius: 567 area : 1009987.480609929 circumf : 3562.5660691708254 Class Gravity def gravity (m1,m2,d): F = (m1 * m2) / d ** 2 return F gravity( 5 , 4 , 10 ) 0.2 Lets create a class for Gravity calculation class Newton (): def __init__ ( self ,value_of_G, value_of_g, supplied_info): self . G = value_of_G self . info = supplied_info self . g = value_of_g def gravity ( self ,m1,m2,d): F = self . G * (m1 * m2) / d ** 2 print ( self . info) return F def gravity_pot ( self ,m1): F = m1 * self . g return F N1 = Newton(value_of_G = 6.7 , value_of_g = 9.8 ,\\ supplied_info = \"great job\" ) N1 . G, N1 . g,N1 . gravity( 2 , 3 , 13 ),N1 . gravity_pot( 12 ) great job (6.7, 9.8, 0.2378698224852071, 117.60000000000001) N1 . gravity(m1 = 11 ,m2 = 12 ,d = 3 ) great job 98.26666666666667","title":"Functions and Class"},{"location":"FunctionClass/fnc/#functions-and-classes","text":"import numpy as np","title":"Functions and Classes"},{"location":"FunctionClass/fnc/#class-circle","text":"Define a function which will take radious as input and provides area as output for a circle. def area (r): A = np . pi * r ** 2 return A Claculate the area of a sample circle of radius 10. area( 10 ) 314.1592653589793 Define a function which will take radious as input and provides circumference as output for a circle. def circumference (r): C = 2 * np . pi * r return C Claculate the circumference of a sample circle of radius 10. circumference( 10 ) 62.83185307179586 Lets build a class implementing above constants and functions class Circle (): def __init__ ( self , r): self . r = r def area ( self ): A = np . pi * self . r ** 2 return A def circumference ( self ): C = 2 * np . pi * self . r return C Test using examples Circle( 5 ) . area() 78.53981633974483 CC = Circle( 5 ) CC . area(),CC . circumference() (78.53981633974483, 31.41592653589793) CC . r 5 for r in [ 2 , 3 , 6 , 24 , 25 , 46 , 567 ]: CC = Circle(r) print ( \"radius: \" , r,\\ \"area : \" , CC . area(),\\ \"circumf : \" , CC . circumference()) radius: 2 area : 12.566370614359172 circumf : 12.566370614359172 radius: 3 area : 28.274333882308138 circumf : 18.84955592153876 radius: 6 area : 113.09733552923255 circumf : 37.69911184307752 radius: 24 area : 1809.5573684677208 circumf : 150.79644737231007 radius: 25 area : 1963.4954084936207 circumf : 157.07963267948966 radius: 46 area : 6647.610054996002 circumf : 289.02652413026095 radius: 567 area : 1009987.480609929 circumf : 3562.5660691708254","title":"Class Circle"},{"location":"FunctionClass/fnc/#class-gravity","text":"def gravity (m1,m2,d): F = (m1 * m2) / d ** 2 return F gravity( 5 , 4 , 10 ) 0.2 Lets create a class for Gravity calculation class Newton (): def __init__ ( self ,value_of_G, value_of_g, supplied_info): self . G = value_of_G self . info = supplied_info self . g = value_of_g def gravity ( self ,m1,m2,d): F = self . G * (m1 * m2) / d ** 2 print ( self . info) return F def gravity_pot ( self ,m1): F = m1 * self . g return F N1 = Newton(value_of_G = 6.7 , value_of_g = 9.8 ,\\ supplied_info = \"great job\" ) N1 . G, N1 . g,N1 . gravity( 2 , 3 , 13 ),N1 . gravity_pot( 12 ) great job (6.7, 9.8, 0.2378698224852071, 117.60000000000001) N1 . gravity(m1 = 11 ,m2 = 12 ,d = 3 ) great job 98.26666666666667","title":"Class Gravity"},{"location":"GettingStarted/anaconda/","text":"Installing Python To install Anaconda Python follow the instruction at Anaconda Distribution Website . Based on the operating system select the proper version of the Anaconda package and install it in your PC. After you successfully install the proper version, you will get anaconda application in you PC which will look like the figure below: Best way to start with is the \"Jupyter notebook\". Lunch the jupyter notebook to start with Python. Note- Linux: For Linux user, it could be little bit tricky. SOme time it becomes hard to locate anaconda path to the environment so you need to point the python you want to use. Please, run the command below to point the python: bash export PATH=/home/ubuntu/anaconda3/bin:$PATH There is 'base' or 'anaconda3' environment by defult. You can find the list of available environmet by typing following command on the terminal bash conda env list To start the 'base' environment type bash source activate base To install new package for example 'jupyter notebook' type bash pip install jupyter notebook After sucessfully installing Jupyter notebook, tye following to start it bash Jupyter notebook Note - Cloud For running Jupyter notebook in AWS cloud, it is important to open the \"8888\" to \"8889\" with TCP rule with IP \"0.0.0.0\" and allow to be opend from anywhere. Once port is open, type following to bash jupyter notebook --ip=0.0.0.0 --no-browser","title":"Guide to starting Python"},{"location":"GettingStarted/anaconda/#installing-python","text":"To install Anaconda Python follow the instruction at Anaconda Distribution Website . Based on the operating system select the proper version of the Anaconda package and install it in your PC. After you successfully install the proper version, you will get anaconda application in you PC which will look like the figure below: Best way to start with is the \"Jupyter notebook\". Lunch the jupyter notebook to start with Python.","title":"Installing Python"},{"location":"GettingStarted/anaconda/#note-linux","text":"For Linux user, it could be little bit tricky. SOme time it becomes hard to locate anaconda path to the environment so you need to point the python you want to use. Please, run the command below to point the python: bash export PATH=/home/ubuntu/anaconda3/bin:$PATH There is 'base' or 'anaconda3' environment by defult. You can find the list of available environmet by typing following command on the terminal bash conda env list To start the 'base' environment type bash source activate base To install new package for example 'jupyter notebook' type bash pip install jupyter notebook After sucessfully installing Jupyter notebook, tye following to start it bash Jupyter notebook","title":"Note- Linux:"},{"location":"GettingStarted/anaconda/#note-cloud","text":"For running Jupyter notebook in AWS cloud, it is important to open the \"8888\" to \"8889\" with TCP rule with IP \"0.0.0.0\" and allow to be opend from anywhere. Once port is open, type following to bash jupyter notebook --ip=0.0.0.0 --no-browser","title":"Note - Cloud"},{"location":"GettingStarted/env/","text":"Python Environment Basics To avoid errors later, it's best to update all the packages in the default environment. Open the Anaconda Prompt application. In the prompt, run the following commands: conda upgrade conda conda upgrade --all If you are seeing the following \"conda command not found\" and are using ZShell, you have to do the following: export PATH = \"/Users/username/anaconda/bin: $PATH \" or update above command line to your .zsh_config file. Once you have Anaconda installed, managing packages is fairly straightforward. To install a package, type conda install package_name in your terminal. For example, to install numpy, type conda install numpy. You can install multiple packages at the same time. Something like conda install numpy scipy pandas will install all those packages simultaneously. It's also possible to specify which version of a package you want by adding the version number such as conda install numpy = 1 .10. Conda also automatically installs dependencies for you. For example scipy depends on numpy, it uses and requires numpy. If you install just scipy (conda install scipy), Conda will also install numpy if it isn't already installed. Most of the commands are pretty intuitive. To uninstall, use conda remove package_name To update a package conda update package_name If you want to update all packages in an environment, which is often useful, use conda update --all And finally, to list installed packages, it's conda list If you don't know the exact name of the package you're looking for, you can try searching with conda search search_term For example, I know I want to install Beautiful Soup, but I'm not sure of the exact package name. So, I try conda search beautifulsoup Environments Conda can be used to create environments to isolate your projects. To create an environment, use conda create -n env_name list of packages in your terminal Here -n env_name sets the name of your environment (-n for name) and list of packages is the list of packages you want installed in the environment. For example, to create an environment named my_env and install numpy in it, type conda create -n my_env numpy When creating an environment, you can specify which version of Python to install in the environment. This is useful when you're working with code in both Python 2.x and Python 3.x. To create an environment with a specific Python version, do something like conda create -n py3 python = 3 or conda create -n py2 python = 2 I actually have both of these environments on my personal computer. I use them as general environments not tied to any specific project, but rather for general work with each Python version easily accessible. These commands will install the most recent version of Python 3 and 2, respectively. To install a specific version, use conda create -n py python = 3 .3 for Python 3.3. Once you have an environment created, use source activate my_env to enter it on OSX/Linux. On Windows, use activate my_env When you're in the environment, you'll see the environment name in the terminal prompt. Something like (my_env) ~ $. The environment has only a few packages installed by default, plus the ones you installed when creating it. You can check this out with conda list. Installing packages in the environment is the same as before: conda install package_name Only this time, the specific packages you install will only be available when you're in the environment. To leave the environment, type source deactivate ( on OSX/Linux ) On Windows, use deactivate Saving and loading environments A really useful feature is sharing environments so others can install all the packages used in your code, with the correct versions. You can save the packages to a YAML file with conda env export > environment.yaml The first part conda env export writes out all the packages in the environment, including the Python version. Above you can see the name of the environment and all the dependencies (along with versions) are listed. The second part of the export command, > environment.yaml writes the exported text to a YAML file environment.yaml . This file can now be shared and others will be able to create the same environment you used for the project. To create an environment from an environment file use conda env create -f environment.yaml This will create a new environment with the same name listed in environment.yaml . Listing environments If you forget what your environments are named (happens to me sometimes), use conda env list to list out all the environments you've created. You should see a list of environments, there will be an asterisk next to the environment you're currently in. The default environment, the environment used when you aren't in one, is called root . Removing environments If there are environments you don't use anymore, conda env remove -n env_name will remove the specified environment (here, named env_name ). Using environments One thing that\u2019s helped me tremendously is having separate environments for Python 2 and Python 3. I used conda create -n py2 python = 2 and conda create -n py3 python = 3 to create two separate environments, py2 and py3 . Now I have a general use environment for each Python version. In each of those environments, I've installed most of the standard data science packages (numpy, scipy, pandas, etc.) I\u2019ve also found it useful to create environments for each project I\u2019m working on. It works great for non-data related projects too like web apps with Flask. For example, I have an environment for my personal blog using Pelican . Sharing environments When sharing your code on GitHub, it's good practice to make an environment file and include it in the repository. This will make it easier for people to install all the dependencies for your code. I also usually include a pip requirements.txt file using pip freeze ( learn more here ) for people not using conda. More to learn To learn more about conda and how it fits in the Python ecosystem, check out this article by Jake Vanderplas: Conda myths and misconceptions. And here's the conda documentation you can reference later.","title":"Setting up Python Environment"},{"location":"GettingStarted/env/#python-environment","text":"","title":"Python Environment"},{"location":"GettingStarted/env/#basics","text":"To avoid errors later, it's best to update all the packages in the default environment. Open the Anaconda Prompt application. In the prompt, run the following commands: conda upgrade conda conda upgrade --all If you are seeing the following \"conda command not found\" and are using ZShell, you have to do the following: export PATH = \"/Users/username/anaconda/bin: $PATH \" or update above command line to your .zsh_config file. Once you have Anaconda installed, managing packages is fairly straightforward. To install a package, type conda install package_name in your terminal. For example, to install numpy, type conda install numpy. You can install multiple packages at the same time. Something like conda install numpy scipy pandas will install all those packages simultaneously. It's also possible to specify which version of a package you want by adding the version number such as conda install numpy = 1 .10. Conda also automatically installs dependencies for you. For example scipy depends on numpy, it uses and requires numpy. If you install just scipy (conda install scipy), Conda will also install numpy if it isn't already installed. Most of the commands are pretty intuitive. To uninstall, use conda remove package_name To update a package conda update package_name If you want to update all packages in an environment, which is often useful, use conda update --all And finally, to list installed packages, it's conda list If you don't know the exact name of the package you're looking for, you can try searching with conda search search_term For example, I know I want to install Beautiful Soup, but I'm not sure of the exact package name. So, I try conda search beautifulsoup","title":"Basics"},{"location":"GettingStarted/env/#environments","text":"Conda can be used to create environments to isolate your projects. To create an environment, use conda create -n env_name list of packages in your terminal Here -n env_name sets the name of your environment (-n for name) and list of packages is the list of packages you want installed in the environment. For example, to create an environment named my_env and install numpy in it, type conda create -n my_env numpy When creating an environment, you can specify which version of Python to install in the environment. This is useful when you're working with code in both Python 2.x and Python 3.x. To create an environment with a specific Python version, do something like conda create -n py3 python = 3 or conda create -n py2 python = 2 I actually have both of these environments on my personal computer. I use them as general environments not tied to any specific project, but rather for general work with each Python version easily accessible. These commands will install the most recent version of Python 3 and 2, respectively. To install a specific version, use conda create -n py python = 3 .3 for Python 3.3. Once you have an environment created, use source activate my_env to enter it on OSX/Linux. On Windows, use activate my_env When you're in the environment, you'll see the environment name in the terminal prompt. Something like (my_env) ~ $. The environment has only a few packages installed by default, plus the ones you installed when creating it. You can check this out with conda list. Installing packages in the environment is the same as before: conda install package_name Only this time, the specific packages you install will only be available when you're in the environment. To leave the environment, type source deactivate ( on OSX/Linux ) On Windows, use deactivate","title":"Environments"},{"location":"GettingStarted/env/#saving-and-loading-environments","text":"A really useful feature is sharing environments so others can install all the packages used in your code, with the correct versions. You can save the packages to a YAML file with conda env export > environment.yaml The first part conda env export writes out all the packages in the environment, including the Python version. Above you can see the name of the environment and all the dependencies (along with versions) are listed. The second part of the export command, > environment.yaml writes the exported text to a YAML file environment.yaml . This file can now be shared and others will be able to create the same environment you used for the project. To create an environment from an environment file use conda env create -f environment.yaml This will create a new environment with the same name listed in environment.yaml .","title":"Saving and loading environments"},{"location":"GettingStarted/env/#listing-environments","text":"If you forget what your environments are named (happens to me sometimes), use conda env list to list out all the environments you've created. You should see a list of environments, there will be an asterisk next to the environment you're currently in. The default environment, the environment used when you aren't in one, is called root .","title":"Listing environments"},{"location":"GettingStarted/env/#removing-environments","text":"If there are environments you don't use anymore, conda env remove -n env_name will remove the specified environment (here, named env_name ).","title":"Removing environments"},{"location":"GettingStarted/env/#using-environments","text":"One thing that\u2019s helped me tremendously is having separate environments for Python 2 and Python 3. I used conda create -n py2 python = 2 and conda create -n py3 python = 3 to create two separate environments, py2 and py3 . Now I have a general use environment for each Python version. In each of those environments, I've installed most of the standard data science packages (numpy, scipy, pandas, etc.) I\u2019ve also found it useful to create environments for each project I\u2019m working on. It works great for non-data related projects too like web apps with Flask. For example, I have an environment for my personal blog using Pelican .","title":"Using environments"},{"location":"GettingStarted/env/#sharing-environments","text":"When sharing your code on GitHub, it's good practice to make an environment file and include it in the repository. This will make it easier for people to install all the dependencies for your code. I also usually include a pip requirements.txt file using pip freeze ( learn more here ) for people not using conda.","title":"Sharing environments"},{"location":"GettingStarted/env/#more-to-learn","text":"To learn more about conda and how it fits in the Python ecosystem, check out this article by Jake Vanderplas: Conda myths and misconceptions. And here's the conda documentation you can reference later.","title":"More to learn"},{"location":"GettingStarted/git/","text":"How to git Reference : How to Git Create a new repository on GitHub. To avoid errors, do not initialize the new repository with README, license, or gitignore files. You can add these files after your project has been pushed to GitHub. Open Terminal. Change the current working directory to your local project. Initialize the local directory as a Git repository. git init Add the files in your new local repository. This stages them for the first commit. git add . Adds the files in the local repository and stages them for commit. To unstage a file, use 'git reset HEAD YOUR-FILE'. Commit the files that you've staged in your local repository. git commit -m \"First commit\" Commits the tracked changes and prepares them to be pushed to a remote repository. To remove this commit and modify the file, use 'git reset --soft HEAD~1' and commit and add the file again. Copy remote repository URL fieldAt the top of your GitHub repository's Quick Setup page, click to copy the remote repository URL. In Terminal, add the URL for the remote repository where your local repository will be pushed. git remote add origin remote repository URL Sets the new remote git remote -v Verifies the new remote URL Push the changes in your local repository to GitHub. git push origin master Pushes the changes in your local repository up to the remote repository you specified as the origin","title":"How to Git"},{"location":"GettingStarted/git/#how-to-git","text":"Reference : How to Git Create a new repository on GitHub. To avoid errors, do not initialize the new repository with README, license, or gitignore files. You can add these files after your project has been pushed to GitHub. Open Terminal. Change the current working directory to your local project. Initialize the local directory as a Git repository. git init Add the files in your new local repository. This stages them for the first commit. git add . Adds the files in the local repository and stages them for commit. To unstage a file, use 'git reset HEAD YOUR-FILE'. Commit the files that you've staged in your local repository. git commit -m \"First commit\" Commits the tracked changes and prepares them to be pushed to a remote repository. To remove this commit and modify the file, use 'git reset --soft HEAD~1' and commit and add the file again. Copy remote repository URL fieldAt the top of your GitHub repository's Quick Setup page, click to copy the remote repository URL. In Terminal, add the URL for the remote repository where your local repository will be pushed. git remote add origin remote repository URL Sets the new remote git remote -v Verifies the new remote URL Push the changes in your local repository to GitHub. git push origin master Pushes the changes in your local repository up to the remote repository you specified as the origin","title":"How to git"},{"location":"GettingStarted/jupyter/","text":"Installing Jupyter Notebook By far the easiest way to install Jupyter is with Anaconda. Jupyter notebooks automatically come with the distribution. You'll be able to use notebooks from the default environment. To install Jupyter notebooks in a conda environment, use conda install jupyter notebook Jupyter notebooks are also available through pip with pip install jupyter notebook Markdown Cheatsheet : https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet Convert a notebook to an HTML file, in your terminal use jupyter nbconvert --to html notebook.ipynb Convert: https://nbconvert.readthedocs.io/en/latest/usage.html To create the slideshow from the notebook file, you'll need to use nbconvert: jupyter nbconvert notebook.ipynb --to slides This just converts the notebook to the necessary files for the slideshow, but you need to serve it with an HTTP server to actually see the presentation. To convert it and immediately see it, use jupyter nbconvert notebook.ipynb --to slides --post serve This will open up the slideshow in your browser so you can present it. panda presentation: presentation","title":"Installing Jupyter Notebook"},{"location":"GettingStarted/jupyter/#installing-jupyter-notebook","text":"By far the easiest way to install Jupyter is with Anaconda. Jupyter notebooks automatically come with the distribution. You'll be able to use notebooks from the default environment. To install Jupyter notebooks in a conda environment, use conda install jupyter notebook Jupyter notebooks are also available through pip with pip install jupyter notebook Markdown Cheatsheet : https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet Convert a notebook to an HTML file, in your terminal use jupyter nbconvert --to html notebook.ipynb Convert: https://nbconvert.readthedocs.io/en/latest/usage.html To create the slideshow from the notebook file, you'll need to use nbconvert: jupyter nbconvert notebook.ipynb --to slides This just converts the notebook to the necessary files for the slideshow, but you need to serve it with an HTTP server to actually see the presentation. To convert it and immediately see it, use jupyter nbconvert notebook.ipynb --to slides --post serve This will open up the slideshow in your browser so you can present it. panda presentation: presentation","title":"Installing Jupyter Notebook"},{"location":"GettingStarted/lib/","text":"Python Libraries Following are the best Python Libraries: TensorFlow Scikit-Learn Numpy Keras PyTorch LightGBM Eli5 SciPy Theano Pandas","title":"Guide to Python Libraries"},{"location":"GettingStarted/lib/#python-libraries","text":"Following are the best Python Libraries: TensorFlow Scikit-Learn Numpy Keras PyTorch LightGBM Eli5 SciPy Theano Pandas","title":"Python Libraries"},{"location":"GettingStarted/note/","text":"Why Codes?","title":"Note"},{"location":"GettingStarted/note/#why-codes","text":"","title":"Why Codes?"},{"location":"Montecarlo/BEC/bec/","text":"Bose Einstein Condensation Permutation Sample % matplotlib inline import random N = 3 statistics = {} L = range (N) nsteps = 10 for step in range (nsteps): i = random . randint( 0 , N - 1 ) j = random . randint( 0 , N - 1 ) L[i], L[j] = L[j], L[i] if tuple (L) in statistics: statistics[ tuple (L)] += 1 else : statistics[ tuple (L)] = 1 print L print range (N) print for item in statistics: print item, statistics[item] [2, 1, 0] [0, 1, 2] [1, 2, 0] [0, 1, 2] [0, 2, 1] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [2, 1, 0] [0, 1, 2] [2, 0, 1] [0, 1, 2] [2, 1, 0] [0, 1, 2] [2, 1, 0] [0, 1, 2] (0, 1, 2) 3 (1, 2, 0) 1 (2, 1, 0) 4 (0, 2, 1) 1 (2, 0, 1) 1 Marcov Harmonic Boson import random , math def levy_harmonic_path (k, beta): xk = tuple ([random . gauss( 0.0 , 1.0 / math . sqrt( 2.0 * math . tanh(k * beta / 2.0 ))) for d in range ( 3 )]) x = [xk] for j in range ( 1 , k): Upsilon_1 = ( 1.0 / math . tanh(beta) + 1.0 / math . tanh((k - j) * beta)) Upsilon_2 = [x[j - 1 ][d] / math . sinh(beta) + xk[d] / math . sinh((k - j) * beta) for d in range ( 3 )] x_mean = [Upsilon_2[d] / Upsilon_1 for d in range ( 3 )] sigma = 1.0 / math . sqrt(Upsilon_1) dummy = [random . gauss(x_mean[d], sigma) for d in range ( 3 )] x . append( tuple (dummy)) return x def rho_harm (x, xp, beta): Upsilon_1 = sum ((x[d] + xp[d]) ** 2 / 4.0 * math . tanh(beta / 2.0 ) for d in range ( 3 )) Upsilon_2 = sum ((x[d] - xp[d]) ** 2 / 4.0 / math . tanh(beta / 2.0 ) for d in range ( 3 )) return math . exp( - Upsilon_1 - Upsilon_2) N = 128 T_star = 0.9 beta = 1.0 / (T_star * N ** ( 1.0 / 3.0 )) nsteps = 1000 positions = {} for j in range (N): a = levy_harmonic_path( 1 , beta) positions[a[ 0 ]] = a[ 0 ] for step in range (nsteps): boson_a = random . choice(positions . keys()) perm_cycle = [] while True : perm_cycle . append(boson_a) boson_b = positions . pop(boson_a) if boson_b == perm_cycle[ 0 ]: break else : boson_a = boson_b k = len (perm_cycle) perm_cycle = levy_harmonic_path(k, beta) positions[perm_cycle[ - 1 ]] = perm_cycle[ 0 ] for j in range ( len (perm_cycle) - 1 ): positions[perm_cycle[j]] = perm_cycle[j + 1 ] a_1 = random . choice(positions . keys()) b_1 = positions . pop(a_1) a_2 = random . choice(positions . keys()) b_2 = positions . pop(a_2) weight_new = rho_harm(a_1, b_2, beta) * rho_harm(a_2, b_1, beta) weight_old = rho_harm(a_1, b_1, beta) * rho_harm(a_2, b_2, beta) if random . uniform( 0.0 , 1.0 ) < weight_new / weight_old: positions[a_1] = b_2 positions[a_2] = b_1 else : positions[a_1] = b_1 positions[a_2] = b_2 Marcov Harmonic Boson Movie import random , math , pylab , mpl_toolkits.mplot3d def levy_harmonic_path (k, beta): xk = tuple ([random . gauss( 0.0 , 1.0 / math . sqrt( 2.0 * math . tanh(k * beta / 2.0 ))) for d in range ( 3 )]) x = [xk] for j in range ( 1 , k): Upsilon_1 = ( 1.0 / math . tanh(beta) + 1.0 / math . tanh((k - j) * beta)) Upsilon_2 = [x[j - 1 ][d] / math . sinh(beta) + xk[d] / math . sinh((k - j) * beta) for d in range ( 3 )] x_mean = [Upsilon_2[d] / Upsilon_1 for d in range ( 3 )] sigma = 1.0 / math . sqrt(Upsilon_1) dummy = [random . gauss(x_mean[d], sigma) for d in range ( 3 )] x . append( tuple (dummy)) return x def rho_harm (x, xp, beta): Upsilon_1 = sum ((x[d] + xp[d]) ** 2 / 4.0 * math . tanh(beta / 2.0 ) for d in range ( 3 )) Upsilon_2 = sum ((x[d] - xp[d]) ** 2 / 4.0 / math . tanh(beta / 2.0 ) for d in range ( 3 )) return math . exp( - Upsilon_1 - Upsilon_2) N = 256 T_star = 0.6 beta = 1.0 / (T_star * N ** ( 1.0 / 3.0 )) nsteps = 1000 positions = {} for j in range (N): a = levy_harmonic_path( 1 , beta) positions[a[ 0 ]] = a[ 0 ] for step in range (nsteps): boson_a = random . choice(positions . keys()) perm_cycle = [] while True : perm_cycle . append(boson_a) boson_b = positions . pop(boson_a) if boson_b == perm_cycle[ 0 ]: break else : boson_a = boson_b k = len (perm_cycle) perm_cycle = levy_harmonic_path(k, beta) positions[perm_cycle[ - 1 ]] = perm_cycle[ 0 ] for j in range ( len (perm_cycle) - 1 ): positions[perm_cycle[j]] = perm_cycle[j + 1 ] a_1 = random . choice(positions . keys()) b_1 = positions . pop(a_1) a_2 = random . choice(positions . keys()) b_2 = positions . pop(a_2) weight_new = rho_harm(a_1, b_2, beta) * rho_harm(a_2, b_1, beta) weight_old = rho_harm(a_1, b_1, beta) * rho_harm(a_2, b_2, beta) if random . uniform( 0.0 , 1.0 ) < weight_new / weight_old: positions[a_1] = b_2 positions[a_2] = b_1 else : positions[a_1] = b_1 positions[a_2] = b_2 fig = pylab . figure() ax = mpl_toolkits . mplot3d . axes3d . Axes3D(fig) ax . set_aspect( 'equal' ) list_colors = [ 'b' , 'g' , 'r' , 'c' , 'm' , 'y' , 'k' ] n_colors = len (list_colors) dict_colors = {} i_color = 0 # find and plot permutation cycles: while positions: x, y, z = [], [], [] starting_boson = positions . keys()[ 0 ] boson_old = starting_boson while True : x . append(boson_old[ 0 ]) y . append(boson_old[ 1 ]) z . append(boson_old[ 2 ]) boson_new = positions . pop(boson_old) if boson_new == starting_boson: break else : boson_old = boson_new len_cycle = len (x) if len_cycle > 2 : x . append(x[ 0 ]) y . append(y[ 0 ]) z . append(z[ 0 ]) if len_cycle in dict_colors: color = dict_colors[len_cycle] ax . plot(x, y, z, color + '+-' , lw = 0.75 ) else : color = list_colors[i_color] i_color = (i_color + 1 ) % n_colors dict_colors[len_cycle] = color ax . plot(x, y, z, color + '+-' , label = 'k= %i ' % len_cycle, lw = 0.75 ) # finalize plot pylab . title( '$N= %i $, $T^*= %s $' % (N, T_star)) pylab . legend() ax . set_xlabel( '$x$' , fontsize = 16 ) ax . set_ylabel( '$y$' , fontsize = 16 ) ax . set_zlabel( '$z$' , fontsize = 16 ) ax . set_xlim3d([ - 8 , 8 ]) ax . set_ylim3d([ - 8 , 8 ]) ax . set_zlim3d([ - 8 , 8 ]) #pylab.savefig('snapshot_bosons_3d_N%04i_Tstar%04.2f.png' % (N, T_star)) pylab . show() TUTORIAL Permutation Sample Cycle import random N = 20 stats = [ 0 ] * (N + 1 ) L = range (N) nsteps = 100 for step in range (nsteps): i = random . randint( 0 , N - 1 ) j = random . randint( 0 , N - 1 ) L[i], L[j] = L[j], L[i] if step % 100 == 0 : cycle_dict = {} for k in range (N): cycle_dict[k] = L[k] while cycle_dict != {}: starting_element = cycle_dict . keys()[ 0 ] cycle_length = 0 old_element = starting_element while True : cycle_length += 1 new_element = cycle_dict . pop(old_element) if new_element == starting_element: break else : old_element = new_element stats[cycle_length] += 1 for k in range ( 1 , N + 1 ): print k, stats[k] 1 18 2 1 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 18 0 19 0 20 0 Direct Harmonic Boson import math , random def z (k, beta): return ( 1.0 - math . exp( - k * beta)) ** ( - 3 ) def canonic_recursion (N, beta): Z = [ 1.0 ] for M in range ( 1 , N + 1 ): Z . append( sum (Z[k] * z(M - k, beta) \\ for k in range (M)) / M) return Z def make_pi_list (Z, M): pi_list = [ 0.0 ] + [z(k, beta) * Z[M - k] / Z[M] / M \\ for k in range ( 1 , M + 1 )] pi_cumulative = [ 0.0 ] for k in range ( 1 , M + 1 ): pi_cumulative . append(pi_cumulative[k - 1 ] + pi_list[k]) return pi_cumulative def naive_tower_sample (pi_cumulative): eta = random . uniform( 0.0 , 1.0 ) for k in range ( len (pi_cumulative)): if eta < pi_cumulative[k]: break return k def levy_harmonic_path (dtau, N): beta = N * dtau x_N = random . gauss( 0.0 , 1.0 / math . sqrt( 2.0 * math . tanh(beta / 2.0 ))) x = [x_N] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Upsilon_1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Upsilon_2 = x[k - 1 ] / math . sinh(dtau) + \\ x_N / math . sinh(dtau_prime) x_mean = Upsilon_2 / Upsilon_1 sigma = 1.0 / math . sqrt(Upsilon_1) x . append(random . gauss(x_mean, sigma)) return x ### main program starts here ### N = 8 T_star = 0.1 beta = 1.0 / N ** ( 1.0 / 3.0 ) / T_star n_steps = 1000 Z = canonic_recursion(N, beta) for step in range (n_steps): N_tmp = N x_config = [] y_config = [] z_config = [] while N_tmp > 0 : pi_sum = make_pi_list(Z, N_tmp) k = naive_tower_sample(pi_sum) x_config += levy_harmonic_path(beta, k) y_config += levy_harmonic_path(beta, k) z_config += levy_harmonic_path(beta, k) N_tmp -= k Canonic Harmonic Recursion import math def z (k, beta): return 1.0 / ( 1.0 - math . exp( - k * beta)) ** 3 def canonic_recursion (N, beta): Z = [ 1.0 ] for M in range ( 1 , N + 1 ): Z . append( sum (Z[k] * z(M - k, beta) \\ for k in range (M)) / M) return Z N = 100 beta = 1.0 Z = canonic_recursion(N, beta) print N, Z[ - 1 ] 100 27.328822346 Canonic Recurrsion Movie import math , pylab def z (k, beta): return 1.0 / ( 1.0 - math . exp( - k * beta)) ** 3 def canonic_recursion (N, beta): Z = [ 1.0 ] for M in range ( 1 , N + 1 ): Z . append( sum (Z[k] * z(M - k, beta) \\ for k in range (M)) / M) return Z N = 256 T_star = 0.6 beta = 1.0 / N ** ( 1.0 / 3.0 ) / T_star Z = canonic_recursion(N, beta) pi_k = [(z(k, beta) * Z[N - k] / Z[ - 1 ]) / float (N) for k in range ( 1 , N + 1 )] # graphics output pylab . plot( range ( 1 , N + 1 ), pi_k, 'b-' , lw = 2.5 ) pylab . ylim( 0.0 , 0.01 ) pylab . xlabel( 'cycle length $k$' , fontsize = 16 ) pylab . ylabel( 'cycle probability $\\pi_k$' , fontsize = 16 ) pylab . title( 'Cycle length distribution ($N= %i $, $T^*= %s $)' % (N, T_star), fontsize = 16 ) #pylab.savefig('plot-prob_cycle_length.png') pylab . show()","title":"Bose-Einstein Condensation"},{"location":"Montecarlo/BEC/bec/#bose-einstein-condensation","text":"Permutation Sample % matplotlib inline import random N = 3 statistics = {} L = range (N) nsteps = 10 for step in range (nsteps): i = random . randint( 0 , N - 1 ) j = random . randint( 0 , N - 1 ) L[i], L[j] = L[j], L[i] if tuple (L) in statistics: statistics[ tuple (L)] += 1 else : statistics[ tuple (L)] = 1 print L print range (N) print for item in statistics: print item, statistics[item] [2, 1, 0] [0, 1, 2] [1, 2, 0] [0, 1, 2] [0, 2, 1] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [0, 1, 2] [2, 1, 0] [0, 1, 2] [2, 0, 1] [0, 1, 2] [2, 1, 0] [0, 1, 2] [2, 1, 0] [0, 1, 2] (0, 1, 2) 3 (1, 2, 0) 1 (2, 1, 0) 4 (0, 2, 1) 1 (2, 0, 1) 1 Marcov Harmonic Boson import random , math def levy_harmonic_path (k, beta): xk = tuple ([random . gauss( 0.0 , 1.0 / math . sqrt( 2.0 * math . tanh(k * beta / 2.0 ))) for d in range ( 3 )]) x = [xk] for j in range ( 1 , k): Upsilon_1 = ( 1.0 / math . tanh(beta) + 1.0 / math . tanh((k - j) * beta)) Upsilon_2 = [x[j - 1 ][d] / math . sinh(beta) + xk[d] / math . sinh((k - j) * beta) for d in range ( 3 )] x_mean = [Upsilon_2[d] / Upsilon_1 for d in range ( 3 )] sigma = 1.0 / math . sqrt(Upsilon_1) dummy = [random . gauss(x_mean[d], sigma) for d in range ( 3 )] x . append( tuple (dummy)) return x def rho_harm (x, xp, beta): Upsilon_1 = sum ((x[d] + xp[d]) ** 2 / 4.0 * math . tanh(beta / 2.0 ) for d in range ( 3 )) Upsilon_2 = sum ((x[d] - xp[d]) ** 2 / 4.0 / math . tanh(beta / 2.0 ) for d in range ( 3 )) return math . exp( - Upsilon_1 - Upsilon_2) N = 128 T_star = 0.9 beta = 1.0 / (T_star * N ** ( 1.0 / 3.0 )) nsteps = 1000 positions = {} for j in range (N): a = levy_harmonic_path( 1 , beta) positions[a[ 0 ]] = a[ 0 ] for step in range (nsteps): boson_a = random . choice(positions . keys()) perm_cycle = [] while True : perm_cycle . append(boson_a) boson_b = positions . pop(boson_a) if boson_b == perm_cycle[ 0 ]: break else : boson_a = boson_b k = len (perm_cycle) perm_cycle = levy_harmonic_path(k, beta) positions[perm_cycle[ - 1 ]] = perm_cycle[ 0 ] for j in range ( len (perm_cycle) - 1 ): positions[perm_cycle[j]] = perm_cycle[j + 1 ] a_1 = random . choice(positions . keys()) b_1 = positions . pop(a_1) a_2 = random . choice(positions . keys()) b_2 = positions . pop(a_2) weight_new = rho_harm(a_1, b_2, beta) * rho_harm(a_2, b_1, beta) weight_old = rho_harm(a_1, b_1, beta) * rho_harm(a_2, b_2, beta) if random . uniform( 0.0 , 1.0 ) < weight_new / weight_old: positions[a_1] = b_2 positions[a_2] = b_1 else : positions[a_1] = b_1 positions[a_2] = b_2 Marcov Harmonic Boson Movie import random , math , pylab , mpl_toolkits.mplot3d def levy_harmonic_path (k, beta): xk = tuple ([random . gauss( 0.0 , 1.0 / math . sqrt( 2.0 * math . tanh(k * beta / 2.0 ))) for d in range ( 3 )]) x = [xk] for j in range ( 1 , k): Upsilon_1 = ( 1.0 / math . tanh(beta) + 1.0 / math . tanh((k - j) * beta)) Upsilon_2 = [x[j - 1 ][d] / math . sinh(beta) + xk[d] / math . sinh((k - j) * beta) for d in range ( 3 )] x_mean = [Upsilon_2[d] / Upsilon_1 for d in range ( 3 )] sigma = 1.0 / math . sqrt(Upsilon_1) dummy = [random . gauss(x_mean[d], sigma) for d in range ( 3 )] x . append( tuple (dummy)) return x def rho_harm (x, xp, beta): Upsilon_1 = sum ((x[d] + xp[d]) ** 2 / 4.0 * math . tanh(beta / 2.0 ) for d in range ( 3 )) Upsilon_2 = sum ((x[d] - xp[d]) ** 2 / 4.0 / math . tanh(beta / 2.0 ) for d in range ( 3 )) return math . exp( - Upsilon_1 - Upsilon_2) N = 256 T_star = 0.6 beta = 1.0 / (T_star * N ** ( 1.0 / 3.0 )) nsteps = 1000 positions = {} for j in range (N): a = levy_harmonic_path( 1 , beta) positions[a[ 0 ]] = a[ 0 ] for step in range (nsteps): boson_a = random . choice(positions . keys()) perm_cycle = [] while True : perm_cycle . append(boson_a) boson_b = positions . pop(boson_a) if boson_b == perm_cycle[ 0 ]: break else : boson_a = boson_b k = len (perm_cycle) perm_cycle = levy_harmonic_path(k, beta) positions[perm_cycle[ - 1 ]] = perm_cycle[ 0 ] for j in range ( len (perm_cycle) - 1 ): positions[perm_cycle[j]] = perm_cycle[j + 1 ] a_1 = random . choice(positions . keys()) b_1 = positions . pop(a_1) a_2 = random . choice(positions . keys()) b_2 = positions . pop(a_2) weight_new = rho_harm(a_1, b_2, beta) * rho_harm(a_2, b_1, beta) weight_old = rho_harm(a_1, b_1, beta) * rho_harm(a_2, b_2, beta) if random . uniform( 0.0 , 1.0 ) < weight_new / weight_old: positions[a_1] = b_2 positions[a_2] = b_1 else : positions[a_1] = b_1 positions[a_2] = b_2 fig = pylab . figure() ax = mpl_toolkits . mplot3d . axes3d . Axes3D(fig) ax . set_aspect( 'equal' ) list_colors = [ 'b' , 'g' , 'r' , 'c' , 'm' , 'y' , 'k' ] n_colors = len (list_colors) dict_colors = {} i_color = 0 # find and plot permutation cycles: while positions: x, y, z = [], [], [] starting_boson = positions . keys()[ 0 ] boson_old = starting_boson while True : x . append(boson_old[ 0 ]) y . append(boson_old[ 1 ]) z . append(boson_old[ 2 ]) boson_new = positions . pop(boson_old) if boson_new == starting_boson: break else : boson_old = boson_new len_cycle = len (x) if len_cycle > 2 : x . append(x[ 0 ]) y . append(y[ 0 ]) z . append(z[ 0 ]) if len_cycle in dict_colors: color = dict_colors[len_cycle] ax . plot(x, y, z, color + '+-' , lw = 0.75 ) else : color = list_colors[i_color] i_color = (i_color + 1 ) % n_colors dict_colors[len_cycle] = color ax . plot(x, y, z, color + '+-' , label = 'k= %i ' % len_cycle, lw = 0.75 ) # finalize plot pylab . title( '$N= %i $, $T^*= %s $' % (N, T_star)) pylab . legend() ax . set_xlabel( '$x$' , fontsize = 16 ) ax . set_ylabel( '$y$' , fontsize = 16 ) ax . set_zlabel( '$z$' , fontsize = 16 ) ax . set_xlim3d([ - 8 , 8 ]) ax . set_ylim3d([ - 8 , 8 ]) ax . set_zlim3d([ - 8 , 8 ]) #pylab.savefig('snapshot_bosons_3d_N%04i_Tstar%04.2f.png' % (N, T_star)) pylab . show()","title":"Bose Einstein Condensation"},{"location":"Montecarlo/BEC/bec/#tutorial","text":"Permutation Sample Cycle import random N = 20 stats = [ 0 ] * (N + 1 ) L = range (N) nsteps = 100 for step in range (nsteps): i = random . randint( 0 , N - 1 ) j = random . randint( 0 , N - 1 ) L[i], L[j] = L[j], L[i] if step % 100 == 0 : cycle_dict = {} for k in range (N): cycle_dict[k] = L[k] while cycle_dict != {}: starting_element = cycle_dict . keys()[ 0 ] cycle_length = 0 old_element = starting_element while True : cycle_length += 1 new_element = cycle_dict . pop(old_element) if new_element == starting_element: break else : old_element = new_element stats[cycle_length] += 1 for k in range ( 1 , N + 1 ): print k, stats[k] 1 18 2 1 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 18 0 19 0 20 0 Direct Harmonic Boson import math , random def z (k, beta): return ( 1.0 - math . exp( - k * beta)) ** ( - 3 ) def canonic_recursion (N, beta): Z = [ 1.0 ] for M in range ( 1 , N + 1 ): Z . append( sum (Z[k] * z(M - k, beta) \\ for k in range (M)) / M) return Z def make_pi_list (Z, M): pi_list = [ 0.0 ] + [z(k, beta) * Z[M - k] / Z[M] / M \\ for k in range ( 1 , M + 1 )] pi_cumulative = [ 0.0 ] for k in range ( 1 , M + 1 ): pi_cumulative . append(pi_cumulative[k - 1 ] + pi_list[k]) return pi_cumulative def naive_tower_sample (pi_cumulative): eta = random . uniform( 0.0 , 1.0 ) for k in range ( len (pi_cumulative)): if eta < pi_cumulative[k]: break return k def levy_harmonic_path (dtau, N): beta = N * dtau x_N = random . gauss( 0.0 , 1.0 / math . sqrt( 2.0 * math . tanh(beta / 2.0 ))) x = [x_N] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Upsilon_1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Upsilon_2 = x[k - 1 ] / math . sinh(dtau) + \\ x_N / math . sinh(dtau_prime) x_mean = Upsilon_2 / Upsilon_1 sigma = 1.0 / math . sqrt(Upsilon_1) x . append(random . gauss(x_mean, sigma)) return x ### main program starts here ### N = 8 T_star = 0.1 beta = 1.0 / N ** ( 1.0 / 3.0 ) / T_star n_steps = 1000 Z = canonic_recursion(N, beta) for step in range (n_steps): N_tmp = N x_config = [] y_config = [] z_config = [] while N_tmp > 0 : pi_sum = make_pi_list(Z, N_tmp) k = naive_tower_sample(pi_sum) x_config += levy_harmonic_path(beta, k) y_config += levy_harmonic_path(beta, k) z_config += levy_harmonic_path(beta, k) N_tmp -= k Canonic Harmonic Recursion import math def z (k, beta): return 1.0 / ( 1.0 - math . exp( - k * beta)) ** 3 def canonic_recursion (N, beta): Z = [ 1.0 ] for M in range ( 1 , N + 1 ): Z . append( sum (Z[k] * z(M - k, beta) \\ for k in range (M)) / M) return Z N = 100 beta = 1.0 Z = canonic_recursion(N, beta) print N, Z[ - 1 ] 100 27.328822346 Canonic Recurrsion Movie import math , pylab def z (k, beta): return 1.0 / ( 1.0 - math . exp( - k * beta)) ** 3 def canonic_recursion (N, beta): Z = [ 1.0 ] for M in range ( 1 , N + 1 ): Z . append( sum (Z[k] * z(M - k, beta) \\ for k in range (M)) / M) return Z N = 256 T_star = 0.6 beta = 1.0 / N ** ( 1.0 / 3.0 ) / T_star Z = canonic_recursion(N, beta) pi_k = [(z(k, beta) * Z[N - k] / Z[ - 1 ]) / float (N) for k in range ( 1 , N + 1 )] # graphics output pylab . plot( range ( 1 , N + 1 ), pi_k, 'b-' , lw = 2.5 ) pylab . ylim( 0.0 , 0.01 ) pylab . xlabel( 'cycle length $k$' , fontsize = 16 ) pylab . ylabel( 'cycle probability $\\pi_k$' , fontsize = 16 ) pylab . title( 'Cycle length distribution ($N= %i $, $T^*= %s $)' % (N, T_star), fontsize = 16 ) #pylab.savefig('plot-prob_cycle_length.png') pylab . show()","title":"TUTORIAL"},{"location":"Montecarlo/GettingStarted/intro/","text":"Introduction to Montecarlo Method import random import matplotlib.pyplot as plt import numpy as np import pylab import seaborn as sns sns . set() % matplotlib inline Lets calculate the value of PI directly n_trials = 1000 n_hits = 0 plt . figure(figsize = [ 8 , 8 ]) for iter in range (n_trials): x = random . uniform( - 1.0 , 1.0 ) y = random . uniform( - 1.0 , 1.0 ) if x ** 2 + y ** 2 < 1.0 : plt . scatter(x,y,color = \"blue\" ) n_hits += 1 else : plt . scatter(x,y,color = \"red\" ) print ( 4.0 * n_hits / float (n_trials)) plt . savefig( \"test.png\" ) 3.208 Lets construct the function to run above code multiple time def direct_pi (N): n_hits = 0 for i in range (N): x = random . uniform( - 1.0 , 1.0 ) y = random . uniform( - 1.0 , 1.0 ) if x ** 2 + y ** 2 < 1.0 : n_hits += 1 computed_pi = 4.0 * n_hits / float (n_trials) return computed_pi n_runs = 100 n_trials = 1000 for run in range (n_runs): pi = direct_pi(n_trials) plt . scatter(run,pi) Marcob chain Calculation of PI x, y = 1.0 , 1.0 delta = 0.1 n_trials = 5000 n_hits = 0 for i in range (n_trials): del_x = random . uniform( - delta, delta) del_y = random . uniform( - delta, delta) '''to make sure they are inside square''' if ( abs (x + del_x) < 1.0 and abs (y + del_y) < 1.0 ): x = x + del_x y = y + del_y '''to make sure they are inside circle''' if x ** 2 + y ** 2 < 1.0 : n_hits += 1 plt . scatter(x,y,color = \"blue\" ) else : plt . scatter(x,y,color = \"red\" ) print 4.0 * n_hits / float (n_trials) 3.0576 Lets construct the function to run above code multiple time. def markov_pi (N, delta): x, y = 1.0 , 1.0 n_hits = 0 for i in range (N): del_x, del_y = random . uniform( - delta, delta), random . uniform( - delta, delta) if abs (x + del_x) < 1.0 and abs (y + del_y) < 1.0 : x, y = x + del_x, y + del_y if x ** 2 + y ** 2 < 1.0 : n_hits += 1 computed_pi = 4.0 * n_hits / float (n_trials) return computed_pi n_runs = 100 n_trials = 400 delta = 0.1 for run in range (n_runs): pi = markov_pi(n_trials, delta) plt . scatter(run,pi) Pebble Game Lets Construct Pebble Story neighbor = [[ 1 , 3 , 0 , 0 ], [ 2 , 4 , 0 , 1 ], [ 2 , 5 , 1 , 2 ], [ 4 , 6 , 3 , 0 ], [ 5 , 7 , 3 , 1 ], [ 5 , 8 , 4 , 2 ], [ 7 , 6 , 6 , 3 ], [ 8 , 7 , 6 , 4 ], [ 8 , 8 , 7 , 5 ]] t_max = 4 site = 8 t = 0 print site while t < t_max: t += 1 site = neighbor[site][random . randint( 0 , 3 )] print site 8 8 5 2 2 Histogram with weight neighbor_o = [[ 1 , 3 , 0 , 0 ], [ 2 , 4 , 0 , 1 ], [ 2 , 5 , 1 , 2 ], [ 4 , 6 , 3 , 0 ], [ 5 , 7 , 3 , 1 ], [ 5 , 8 , 4 , 2 ], [ 7 , 6 , 6 , 3 ], [ 8 , 7 , 6 , 4 ], [ 8 , 8 , 7 , 5 ]] histo = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] weight = [ 3.0 , 0.5 , 1.0 , 0.5 , 1.0 , 0.5 , 2.0 , 0.5 , 1.0 ] pos = 8 n_iter = 10000 for iter in range (n_iter): new_pos = neighbor_o[pos][random . randint( 0 , 3 )] if random . random() < weight[new_pos] / weight[pos]: pos = new_pos histo[pos] += 1 norm = sum (weight) print 'comparison: weight, histogram' for k in range ( 9 ): print 'site: ' , k, ' weight: ' , weight[k], ' histo: ' , norm * histo[k] / float (n_iter) comparison: weight, histogram site: 0 weight: 3.0 histo: 2.952 site: 1 weight: 0.5 histo: 0.501 site: 2 weight: 1.0 histo: 0.975 site: 3 weight: 0.5 histo: 0.479 site: 4 weight: 1.0 histo: 1.001 site: 5 weight: 0.5 histo: 0.496 site: 6 weight: 2.0 histo: 2.121 site: 7 weight: 0.5 histo: 0.508 site: 8 weight: 1.0 histo: 0.967 Pebble Multirun neighbour = { 1 : [ 2 , 4 , 1 , 1 ], 2 : [ 3 , 5 , 1 , 2 ], 3 : [ 3 , 6 , 2 , 3 ], 4 : [ 5 , 7 , 4 , 1 ], 5 : [ 6 , 8 , 4 , 2 ], 6 : [ 6 , 9 , 5 , 3 ], 7 : [ 8 , 7 , 7 , 4 ], 8 : [ 9 , 8 , 7 , 5 ], 9 : [ 9 , 9 , 8 , 6 ]} xvec = { 1 : 3 , 2 : 2 , 3 : 1 , 4 : 3 , 5 : 2 , 6 : 1 , 7 : 3 , 8 : 2 , 9 : 1 } yvec = { 1 : 1 , 2 : 1 , 3 : 1 , 4 : 2 , 5 : 2 , 6 : 2 , 7 : 3 , 8 : 3 , 9 : 3 } list_vec = [] run = 0 if run < 10 : run_str = '0' + str (run) else : run_str = str (run) for n_runs in range ( 100000 ): pos = 9 for iter in range (run): pos = neighbor[pos][ random . randint( 0 , 3 )] list_vec . append(pos) x = [xvec[k] for k in list_vec] y = [yvec[k] for k in list_vec] plt . xticks([]) plt . yticks([]) '''create a Histogram''' H, xedges, yedges = np . histogram2d(x, y, bins = ( 3 , 3 ), range = [[ 1 , 3 ],[ 1 , 3 ]], normed = True ) print H H /= np . sum(H) print H '''plot Histogram''' extent = [yedges[ 0 ], yedges[ - 1 ], xedges[ - 1 ], xedges[ 0 ]] plt . imshow(H, extent = extent, interpolation = 'nearest' , vmin = 0.0 , vmax = 1.0 ) plt . set_cmap( 'hot' ) plt . colorbar() plt . title( 't = ' + str (run),fontsize = 22 ) plt . savefig( '3x3_pebble_run_' + run_str + '.png' ) plt . show() [[ 0. 0. 2.25] [ 0. 0. 0. ] [ 0. 0. 0. ]] [[ 0. 0. 1.] [ 0. 0. 0.] [ 0. 0. 0.]] Multiple Histogram xvec = { 1 : 3 , 2 : 2 , 3 : 1 , 4 : 3 , 5 : 2 , 6 : 1 , 7 : 3 , 8 : 2 , 9 : 1 } yvec = { 1 : 1 , 2 : 1 , 3 : 1 , 4 : 2 , 5 : 2 , 6 : 2 , 7 : 3 , 8 : 3 , 9 : 3 } N_runs = 4 for run in range (N_runs): list_vec = [] if run < 10 : run_str = '0' + str (run) else : run_str = str (run) for n_runs in range ( 100000 ): pos = 9 for iter in range (run): pos = neighbor[pos][ random . randint( 0 , 3 )] list_vec . append(pos) x = [xvec[k] for k in list_vec] y = [yvec[k] for k in list_vec] plt . subplot( 2 , 2 ,run + 1 ) plt . xticks([]) plt . yticks([]) H, xedges, yedges = np . histogram2d(x, y, bins = ( 3 , 3 ), range = [[ 1 , 3 ],[ 1 , 3 ]], normed = True ) #print H H /= np . sum(H) # print H extent = [yedges[ 0 ], yedges[ - 1 ], xedges[ - 1 ], xedges[ 0 ]] histo = plt . imshow(H, extent = extent, interpolation = 'nearest' , vmin = 0 , vmax = 1.00 ) histo . set_cmap( 'hot' ) plt . colorbar() plt . title( 't = ' + str (run),fontsize = 10 ) #plt.savefig('marcob/3x3_pebble_run_'+run_str+'.png') #plt.close() plt . show() Pebble movie def grider (): pylab . plot([ 0.5 , 3.5 ], [ 1.5 , 1.5 ], 'b' ) pylab . plot([ 0.5 , 3.5 ], [ 2.5 , 2.5 ], 'b' ) pylab . plot([ 1.5 , 1.5 ], [ 0.5 , 3.5 ], 'b' ) pylab . plot([ 2.5 , 2.5 ], [ 0.5 , 3.5 ], 'b' ) return grider() sigma = 0.4 # sigma and s_map are needed for the graphical output s_map = [( 1.0 , 1.0 ), ( 2.0 , 1.0 ), ( 3.0 , 1.0 ), ( 1.0 , 2.0 ), ( 2.0 , 2.0 ), ( 3.0 , 2.0 ), ( 1.0 , 3.0 ), ( 2.0 , 3.0 ), ( 3.0 , 3.0 )] neighbor_o = [[ 1 , 3 , 0 , 0 ], [ 2 , 4 , 0 , 1 ], [ 2 , 5 , 1 , 2 ], [ 4 , 6 , 3 , 0 ], [ 5 , 7 , 3 , 1 ], [ 5 , 8 , 4 , 2 ], [ 7 , 6 , 6 , 3 ], [ 8 , 7 , 6 , 4 ], [ 8 , 8 , 7 , 5 ]] site = 8 N_runs = 10 for run in range (N_runs): if run < 10 : number_string = '0' + str (run) else : number_string = str (run) # Begin of graphical output cir = pylab . Circle(s_map[site], radius = sigma, fc = 'r' ) pylab . subplot( 5 , 2 ,run + 1 ) pylab . gca() . add_patch(cir) grider() pylab . title( 't = ' + number_string) pylab . axis( 'scaled' ) pylab . axis([ 0.5 , 3.5 , 0.5 , 3.5 ]) pylab . xticks([]) pylab . yticks([]) #pylab.savefig('peeble_movie/pebble_basic_movie_'+number_string+'.png', transparent=False) #pylab.show() #pylab.clf() # End of graphical output site = neighbor_o[site][ random . randint( 0 , 3 )] pylab . show() Peeble-Dual def double_grider (): pylab . axis([ 0.5 , 6.5 , - 2.5 , 3.5 ]) pylab . plot([ 0.5 , 3.5 ], [ 0.5 , 0.5 ], 'r' ) pylab . plot([ 0.5 , 3.5 ], [ 1.5 , 1.5 ], 'r' ) pylab . plot([ 0.5 , 3.5 ], [ 2.5 , 2.5 ], 'r' ) pylab . plot([ 1.5 , 1.5 ], [ 0.5 , 3.5 ], 'r' ) pylab . plot([ 2.5 , 2.5 ], [ 0.5 , 3.5 ], 'r' ) pylab . plot([ 3.5 , 3.5 ], [ 0.5 , 3.5 ], 'r' ) pylab . plot([ 0.5 + offset, 3.5 + offset], [ 1.5 - offset, 1.5 - offset], 'b' ) pylab . plot([ 0.5 + offset, 3.5 + offset], [ 2.5 - offset, 2.5 - offset], 'b' ) pylab . plot([ 0.5 + offset, 3.5 + offset], [ 3.5 - offset, 3.5 - offset], 'b' ) pylab . plot([ 0.5 + offset, 0.5 + offset], [ 0.5 - offset, 3.5 - offset], 'b' ) pylab . plot([ 1.5 + offset, 1.5 + offset], [ 0.5 - offset, 3.5 - offset], 'b' ) pylab . plot([ 2.5 + offset, 2.5 + offset], [ 0.5 - offset, 3.5 - offset], 'b' ) return double_grider() Pebble transfer strategy transfer = np . zeros(( 9 , 9 )) for k in range ( 9 ): for neigh in range ( 4 ): transfer[neighbor_o[k][neigh], k] += 0.25 position = np . zeros( 9 ) position[ 8 ] = 1.0 for t in range ( 10 ): print t, ' ' ,[ \" %0.5f \" % abs (i - 1.0 / 9.0 ) for i in position] position = np . dot(transfer, position) 0 ['0.11111', '0.11111', '0.11111', '0.11111', '0.11111', '0.11111', '0.11111', '0.11111', '0.88889'] 1 ['0.11111', '0.11111', '0.11111', '0.11111', '0.11111', '0.13889', '0.11111', '0.13889', '0.38889'] 2 ['0.11111', '0.11111', '0.04861', '0.11111', '0.01389', '0.07639', '0.04861', '0.07639', '0.26389'] 3 ['0.11111', '0.06424', '0.03299', '0.06424', '0.01736', '0.07639', '0.03299', '0.07639', '0.17014'] 4 ['0.08767', '0.05642', '0.01345', '0.05642', '0.00608', '0.04905', '0.01345', '0.04905', '0.12326'] 5 ['0.07205', '0.03787', '0.00857', '0.03787', '0.00369', '0.04123', '0.00857', '0.04123', '0.08615'] 6 ['0.05496', '0.03054', '0.00345', '0.03054', '0.00168', '0.02878', '0.00345', '0.02878', '0.06369'] 7 ['0.04275', '0.02182', '0.00216', '0.02182', '0.00088', '0.02268', '0.00216', '0.02268', '0.04624'] 8 ['0.03228', '0.01690', '0.00087', '0.01690', '0.00043', '0.01647', '0.00087', '0.01647', '0.03446'] 9 ['0.02459', '0.01241', '0.00054', '0.01241', '0.00022', '0.01262', '0.00054', '0.01262', '0.02546'] Pebble transfer Eigen import numpy neighbor = [[ 1 , 3 , 0 , 0 ], [ 2 , 4 , 0 , 1 ], [ 2 , 5 , 1 , 2 ], [ 4 , 6 , 3 , 0 ], [ 5 , 7 , 3 , 1 ], [ 5 , 8 , 4 , 2 ], [ 7 , 6 , 6 , 3 ], [ 8 , 7 , 6 , 4 ], [ 8 , 8 , 7 , 5 ]] transfer = numpy . zeros(( 18 , 18 )) for k in range ( 9 ): for neigh in range ( 4 ): transfer[neighbor[k][neigh], k] += 0.25 # red pebble game transfer[neighbor[k][neigh] + 9 , k + 9 ] += 0.25 # blue pebble game # small transition epsilon between red 2 and blue 6 epsilon = 0.04 transfer[ 6 + 9 , 2 ] = transfer[ 2 , 6 + 9 ] = epsilon transfer[ 2 , 2 ] -= epsilon transfer[ 6 + 9 , 6 + 9 ] -= epsilon eigenvalues, eigenvectors = numpy . linalg . eig(transfer) print eigenvalues # you may print the eigenvectors by uncommenting the following four lines #for iter in range(18): # print eigenvalues[iter] # for i in range(18): # print eigenvectors[i][iter] [ -5.02430015e-01 -5.00000000e-01 1.00000000e+00 9.92451031e-01 7.25649298e-01 5.00000000e-01 4.79023434e-01 -1.50050555e-02 2.40311308e-01 7.50000000e-01 7.50000000e-01 1.52303605e-17 7.50000000e-01 -1.04083409e-16 1.07326675e-17 2.50000000e-01 2.50000000e-01 2.50000000e-01] random . seed( '1234' ) sigma = 0.4 epsilon = 0.4 # probability to switch from red to blue pebble, and vice versa pylab . figure() s_map_red = [( 1.0 , 1.0 ), ( 2.0 , 1.0 ), ( 3.0 , 1.0 ), ( 1.0 , 2.0 ), ( 2.0 , 2.0 ), ( 3.0 , 2.0 ), ( 1.0 , 3.0 ), ( 2.0 , 3.0 ), ( 3.0 , 3.0 )] offset = 3.0 s_map_blue = [(x + offset,y - offset) for (x,y) in s_map_red] color = 'red' #chose 'red' or 'blue' site = 8 tmax = 10 for iter in range (tmax): period = 4 if ( iter % period) == 0 : # Begin of graphical output maxlength = len ( str (tmax - 1 )) number_string = str ( iter ) . zfill(maxlength) if color == 'red' : cir = pylab . Circle(s_map_red[site], radius = sigma, fc = 'r' ) if color == 'blue' : cir = pylab . Circle(s_map_blue[site], radius = sigma, fc = 'b' ) pylab . figure() #pylab.subplot(2,2,iter) pylab . gca() . add_patch(cir) double_grider() pylab . title( 't = ' + number_string) pylab . axis( 'scaled' ) pylab . axis([ 0.5 , 6.5 , - 2.5 , 3.5 ]) pylab . xticks([]) pylab . yticks([]) number_string_filename = str ( iter / period) . zfill( 3 ) #pylab.savefig('peeble_dual/pebble_dual_movie_epsilon_'+number_string_filename+'.png', transparent=True) #pylab.clf() #pylab.close() pylab . show() # End of graphical output newsite = neighbor_o[site][ random . randint( 0 , 3 )] newcolor = color if (color == 'red' ) and (site == 2 ) and (newsite == 2 ): if random . random() < epsilon: newcolor = 'blue' newsite = 6 print \"transition red->blue at time = \" , iter if (color == 'blue' ) and (site == 6 ) and (newsite == 6 ): if random . random() < epsilon: newcolor = 'red' newsite = 2 print \"transition blue->red at time = \" , iter site = newsite color = newcolor &lt;matplotlib.figure.Figure at 0x10aa4cd50&gt; Pebble Dual Eigen import numpy neighbor = [[ 1 , 3 , 0 , 0 ], [ 2 , 4 , 0 , 1 ], [ 2 , 5 , 1 , 2 ], [ 4 , 6 , 3 , 0 ], [ 5 , 7 , 3 , 1 ], [ 5 , 8 , 4 , 2 ], [ 7 , 6 , 6 , 3 ], [ 8 , 7 , 6 , 4 ], [ 8 , 8 , 7 , 5 ]] transfer = numpy . zeros(( 18 , 18 )) for k in range ( 9 ): for neigh in range ( 4 ): transfer[neighbor[k][neigh], k] += 0.25 # red pebble game transfer[neighbor[k][neigh] + 9 , k + 9 ] += 0.25 # blue pebble game # small transition epsilon between red 2 and blue 6 epsilon = 0.04 transfer[ 6 + 9 , 2 ] = transfer[ 2 , 6 + 9 ] = epsilon transfer[ 2 , 2 ] -= epsilon transfer[ 6 + 9 , 6 + 9 ] -= epsilon eigenvalues, eigenvectors = numpy . linalg . eig(transfer) print eigenvalues # you may print the eigenvectors by uncommenting the following four lines #for iter in range(18): # print eigenvalues[iter] # for i in range(18): # print eigenvectors[i][iter] [ -5.02430015e-01 -5.00000000e-01 1.00000000e+00 9.92451031e-01 7.25649298e-01 5.00000000e-01 4.79023434e-01 -1.50050555e-02 2.40311308e-01 7.50000000e-01 7.50000000e-01 1.52303605e-17 7.50000000e-01 -1.04083409e-16 1.07326675e-17 2.50000000e-01 2.50000000e-01 2.50000000e-01] Pebble Recrrunt Movie import math , random , pylab sigma = 0.4 epsilon = 0.1 pylab . figure() s_map = [( 1.0 , 1.0 ), ( 2.0 , 1.0 )] neighbor = [[ 1 ], [ 0 ]] pos = 0 tmax = 5 for iter in range (tmax): # Begin of the graphics output pylab . figure() number_string = str ( iter ) . zfill( len ( str (tmax))) cir = pylab . Circle(s_map[pos], radius = sigma, fc = 'r' ) pylab . gca() . add_patch(cir) pylab . plot([ 1.5 , 1.5 ], [ 0.5 , 1.5 ], 'b' ) pylab . title( 't = ' + number_string) pylab . axis( 'scaled' ) pylab . axis([ 0.5 , 2.5 , 0.5 , 1.5 ]) pylab . xticks([]) pylab . yticks([]) pylab . savefig( 'recurrent/2x1pebble_epsilon' + number_string + '.png' , transparent = True ) #pylab.close() pylab . show() # End of the graphics output newpos = neighbor[pos][ 0 ] if random . random() < epsilon: newpos = pos pos = newpos &lt;matplotlib.figure.Figure at 0x10a282e10&gt; import numpy epsilon = 0.01 transfer = [[ epsilon, 1.0 - epsilon ], [ 1.0 - epsilon, epsilon ]] eigenvalues, eigenvectors = numpy . linalg . eig(transfer) print eigenvalues # you may print the eigenvectors by uncommenting the following lines... #for iter in range(2): # print eigenvalues[iter] # for i in range(2): # print eigenvectors[i][iter] [ 1. -0.98]","title":"Algorithms in Monte Carlo Simulation"},{"location":"Montecarlo/GettingStarted/intro/#introduction-to-montecarlo-method","text":"import random import matplotlib.pyplot as plt import numpy as np import pylab import seaborn as sns sns . set() % matplotlib inline","title":"Introduction to Montecarlo Method"},{"location":"Montecarlo/GettingStarted/intro/#lets-calculate-the-value-of-pi-directly","text":"n_trials = 1000 n_hits = 0 plt . figure(figsize = [ 8 , 8 ]) for iter in range (n_trials): x = random . uniform( - 1.0 , 1.0 ) y = random . uniform( - 1.0 , 1.0 ) if x ** 2 + y ** 2 < 1.0 : plt . scatter(x,y,color = \"blue\" ) n_hits += 1 else : plt . scatter(x,y,color = \"red\" ) print ( 4.0 * n_hits / float (n_trials)) plt . savefig( \"test.png\" ) 3.208 Lets construct the function to run above code multiple time def direct_pi (N): n_hits = 0 for i in range (N): x = random . uniform( - 1.0 , 1.0 ) y = random . uniform( - 1.0 , 1.0 ) if x ** 2 + y ** 2 < 1.0 : n_hits += 1 computed_pi = 4.0 * n_hits / float (n_trials) return computed_pi n_runs = 100 n_trials = 1000 for run in range (n_runs): pi = direct_pi(n_trials) plt . scatter(run,pi)","title":"Lets calculate the value of PI directly"},{"location":"Montecarlo/GettingStarted/intro/#marcob-chain-calculation-of-pi","text":"x, y = 1.0 , 1.0 delta = 0.1 n_trials = 5000 n_hits = 0 for i in range (n_trials): del_x = random . uniform( - delta, delta) del_y = random . uniform( - delta, delta) '''to make sure they are inside square''' if ( abs (x + del_x) < 1.0 and abs (y + del_y) < 1.0 ): x = x + del_x y = y + del_y '''to make sure they are inside circle''' if x ** 2 + y ** 2 < 1.0 : n_hits += 1 plt . scatter(x,y,color = \"blue\" ) else : plt . scatter(x,y,color = \"red\" ) print 4.0 * n_hits / float (n_trials) 3.0576 Lets construct the function to run above code multiple time. def markov_pi (N, delta): x, y = 1.0 , 1.0 n_hits = 0 for i in range (N): del_x, del_y = random . uniform( - delta, delta), random . uniform( - delta, delta) if abs (x + del_x) < 1.0 and abs (y + del_y) < 1.0 : x, y = x + del_x, y + del_y if x ** 2 + y ** 2 < 1.0 : n_hits += 1 computed_pi = 4.0 * n_hits / float (n_trials) return computed_pi n_runs = 100 n_trials = 400 delta = 0.1 for run in range (n_runs): pi = markov_pi(n_trials, delta) plt . scatter(run,pi)","title":"Marcob chain Calculation of PI"},{"location":"Montecarlo/GettingStarted/intro/#pebble-game","text":"Lets Construct Pebble Story neighbor = [[ 1 , 3 , 0 , 0 ], [ 2 , 4 , 0 , 1 ], [ 2 , 5 , 1 , 2 ], [ 4 , 6 , 3 , 0 ], [ 5 , 7 , 3 , 1 ], [ 5 , 8 , 4 , 2 ], [ 7 , 6 , 6 , 3 ], [ 8 , 7 , 6 , 4 ], [ 8 , 8 , 7 , 5 ]] t_max = 4 site = 8 t = 0 print site while t < t_max: t += 1 site = neighbor[site][random . randint( 0 , 3 )] print site 8 8 5 2 2 Histogram with weight neighbor_o = [[ 1 , 3 , 0 , 0 ], [ 2 , 4 , 0 , 1 ], [ 2 , 5 , 1 , 2 ], [ 4 , 6 , 3 , 0 ], [ 5 , 7 , 3 , 1 ], [ 5 , 8 , 4 , 2 ], [ 7 , 6 , 6 , 3 ], [ 8 , 7 , 6 , 4 ], [ 8 , 8 , 7 , 5 ]] histo = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] weight = [ 3.0 , 0.5 , 1.0 , 0.5 , 1.0 , 0.5 , 2.0 , 0.5 , 1.0 ] pos = 8 n_iter = 10000 for iter in range (n_iter): new_pos = neighbor_o[pos][random . randint( 0 , 3 )] if random . random() < weight[new_pos] / weight[pos]: pos = new_pos histo[pos] += 1 norm = sum (weight) print 'comparison: weight, histogram' for k in range ( 9 ): print 'site: ' , k, ' weight: ' , weight[k], ' histo: ' , norm * histo[k] / float (n_iter) comparison: weight, histogram site: 0 weight: 3.0 histo: 2.952 site: 1 weight: 0.5 histo: 0.501 site: 2 weight: 1.0 histo: 0.975 site: 3 weight: 0.5 histo: 0.479 site: 4 weight: 1.0 histo: 1.001 site: 5 weight: 0.5 histo: 0.496 site: 6 weight: 2.0 histo: 2.121 site: 7 weight: 0.5 histo: 0.508 site: 8 weight: 1.0 histo: 0.967","title":"Pebble Game"},{"location":"Montecarlo/GettingStarted/intro/#pebble-multirun","text":"neighbour = { 1 : [ 2 , 4 , 1 , 1 ], 2 : [ 3 , 5 , 1 , 2 ], 3 : [ 3 , 6 , 2 , 3 ], 4 : [ 5 , 7 , 4 , 1 ], 5 : [ 6 , 8 , 4 , 2 ], 6 : [ 6 , 9 , 5 , 3 ], 7 : [ 8 , 7 , 7 , 4 ], 8 : [ 9 , 8 , 7 , 5 ], 9 : [ 9 , 9 , 8 , 6 ]} xvec = { 1 : 3 , 2 : 2 , 3 : 1 , 4 : 3 , 5 : 2 , 6 : 1 , 7 : 3 , 8 : 2 , 9 : 1 } yvec = { 1 : 1 , 2 : 1 , 3 : 1 , 4 : 2 , 5 : 2 , 6 : 2 , 7 : 3 , 8 : 3 , 9 : 3 } list_vec = [] run = 0 if run < 10 : run_str = '0' + str (run) else : run_str = str (run) for n_runs in range ( 100000 ): pos = 9 for iter in range (run): pos = neighbor[pos][ random . randint( 0 , 3 )] list_vec . append(pos) x = [xvec[k] for k in list_vec] y = [yvec[k] for k in list_vec] plt . xticks([]) plt . yticks([]) '''create a Histogram''' H, xedges, yedges = np . histogram2d(x, y, bins = ( 3 , 3 ), range = [[ 1 , 3 ],[ 1 , 3 ]], normed = True ) print H H /= np . sum(H) print H '''plot Histogram''' extent = [yedges[ 0 ], yedges[ - 1 ], xedges[ - 1 ], xedges[ 0 ]] plt . imshow(H, extent = extent, interpolation = 'nearest' , vmin = 0.0 , vmax = 1.0 ) plt . set_cmap( 'hot' ) plt . colorbar() plt . title( 't = ' + str (run),fontsize = 22 ) plt . savefig( '3x3_pebble_run_' + run_str + '.png' ) plt . show() [[ 0. 0. 2.25] [ 0. 0. 0. ] [ 0. 0. 0. ]] [[ 0. 0. 1.] [ 0. 0. 0.] [ 0. 0. 0.]] Multiple Histogram xvec = { 1 : 3 , 2 : 2 , 3 : 1 , 4 : 3 , 5 : 2 , 6 : 1 , 7 : 3 , 8 : 2 , 9 : 1 } yvec = { 1 : 1 , 2 : 1 , 3 : 1 , 4 : 2 , 5 : 2 , 6 : 2 , 7 : 3 , 8 : 3 , 9 : 3 } N_runs = 4 for run in range (N_runs): list_vec = [] if run < 10 : run_str = '0' + str (run) else : run_str = str (run) for n_runs in range ( 100000 ): pos = 9 for iter in range (run): pos = neighbor[pos][ random . randint( 0 , 3 )] list_vec . append(pos) x = [xvec[k] for k in list_vec] y = [yvec[k] for k in list_vec] plt . subplot( 2 , 2 ,run + 1 ) plt . xticks([]) plt . yticks([]) H, xedges, yedges = np . histogram2d(x, y, bins = ( 3 , 3 ), range = [[ 1 , 3 ],[ 1 , 3 ]], normed = True ) #print H H /= np . sum(H) # print H extent = [yedges[ 0 ], yedges[ - 1 ], xedges[ - 1 ], xedges[ 0 ]] histo = plt . imshow(H, extent = extent, interpolation = 'nearest' , vmin = 0 , vmax = 1.00 ) histo . set_cmap( 'hot' ) plt . colorbar() plt . title( 't = ' + str (run),fontsize = 10 ) #plt.savefig('marcob/3x3_pebble_run_'+run_str+'.png') #plt.close() plt . show() Pebble movie def grider (): pylab . plot([ 0.5 , 3.5 ], [ 1.5 , 1.5 ], 'b' ) pylab . plot([ 0.5 , 3.5 ], [ 2.5 , 2.5 ], 'b' ) pylab . plot([ 1.5 , 1.5 ], [ 0.5 , 3.5 ], 'b' ) pylab . plot([ 2.5 , 2.5 ], [ 0.5 , 3.5 ], 'b' ) return grider() sigma = 0.4 # sigma and s_map are needed for the graphical output s_map = [( 1.0 , 1.0 ), ( 2.0 , 1.0 ), ( 3.0 , 1.0 ), ( 1.0 , 2.0 ), ( 2.0 , 2.0 ), ( 3.0 , 2.0 ), ( 1.0 , 3.0 ), ( 2.0 , 3.0 ), ( 3.0 , 3.0 )] neighbor_o = [[ 1 , 3 , 0 , 0 ], [ 2 , 4 , 0 , 1 ], [ 2 , 5 , 1 , 2 ], [ 4 , 6 , 3 , 0 ], [ 5 , 7 , 3 , 1 ], [ 5 , 8 , 4 , 2 ], [ 7 , 6 , 6 , 3 ], [ 8 , 7 , 6 , 4 ], [ 8 , 8 , 7 , 5 ]] site = 8 N_runs = 10 for run in range (N_runs): if run < 10 : number_string = '0' + str (run) else : number_string = str (run) # Begin of graphical output cir = pylab . Circle(s_map[site], radius = sigma, fc = 'r' ) pylab . subplot( 5 , 2 ,run + 1 ) pylab . gca() . add_patch(cir) grider() pylab . title( 't = ' + number_string) pylab . axis( 'scaled' ) pylab . axis([ 0.5 , 3.5 , 0.5 , 3.5 ]) pylab . xticks([]) pylab . yticks([]) #pylab.savefig('peeble_movie/pebble_basic_movie_'+number_string+'.png', transparent=False) #pylab.show() #pylab.clf() # End of graphical output site = neighbor_o[site][ random . randint( 0 , 3 )] pylab . show()","title":"Pebble Multirun"},{"location":"Montecarlo/GettingStarted/intro/#peeble-dual","text":"def double_grider (): pylab . axis([ 0.5 , 6.5 , - 2.5 , 3.5 ]) pylab . plot([ 0.5 , 3.5 ], [ 0.5 , 0.5 ], 'r' ) pylab . plot([ 0.5 , 3.5 ], [ 1.5 , 1.5 ], 'r' ) pylab . plot([ 0.5 , 3.5 ], [ 2.5 , 2.5 ], 'r' ) pylab . plot([ 1.5 , 1.5 ], [ 0.5 , 3.5 ], 'r' ) pylab . plot([ 2.5 , 2.5 ], [ 0.5 , 3.5 ], 'r' ) pylab . plot([ 3.5 , 3.5 ], [ 0.5 , 3.5 ], 'r' ) pylab . plot([ 0.5 + offset, 3.5 + offset], [ 1.5 - offset, 1.5 - offset], 'b' ) pylab . plot([ 0.5 + offset, 3.5 + offset], [ 2.5 - offset, 2.5 - offset], 'b' ) pylab . plot([ 0.5 + offset, 3.5 + offset], [ 3.5 - offset, 3.5 - offset], 'b' ) pylab . plot([ 0.5 + offset, 0.5 + offset], [ 0.5 - offset, 3.5 - offset], 'b' ) pylab . plot([ 1.5 + offset, 1.5 + offset], [ 0.5 - offset, 3.5 - offset], 'b' ) pylab . plot([ 2.5 + offset, 2.5 + offset], [ 0.5 - offset, 3.5 - offset], 'b' ) return double_grider() Pebble transfer strategy transfer = np . zeros(( 9 , 9 )) for k in range ( 9 ): for neigh in range ( 4 ): transfer[neighbor_o[k][neigh], k] += 0.25 position = np . zeros( 9 ) position[ 8 ] = 1.0 for t in range ( 10 ): print t, ' ' ,[ \" %0.5f \" % abs (i - 1.0 / 9.0 ) for i in position] position = np . dot(transfer, position) 0 ['0.11111', '0.11111', '0.11111', '0.11111', '0.11111', '0.11111', '0.11111', '0.11111', '0.88889'] 1 ['0.11111', '0.11111', '0.11111', '0.11111', '0.11111', '0.13889', '0.11111', '0.13889', '0.38889'] 2 ['0.11111', '0.11111', '0.04861', '0.11111', '0.01389', '0.07639', '0.04861', '0.07639', '0.26389'] 3 ['0.11111', '0.06424', '0.03299', '0.06424', '0.01736', '0.07639', '0.03299', '0.07639', '0.17014'] 4 ['0.08767', '0.05642', '0.01345', '0.05642', '0.00608', '0.04905', '0.01345', '0.04905', '0.12326'] 5 ['0.07205', '0.03787', '0.00857', '0.03787', '0.00369', '0.04123', '0.00857', '0.04123', '0.08615'] 6 ['0.05496', '0.03054', '0.00345', '0.03054', '0.00168', '0.02878', '0.00345', '0.02878', '0.06369'] 7 ['0.04275', '0.02182', '0.00216', '0.02182', '0.00088', '0.02268', '0.00216', '0.02268', '0.04624'] 8 ['0.03228', '0.01690', '0.00087', '0.01690', '0.00043', '0.01647', '0.00087', '0.01647', '0.03446'] 9 ['0.02459', '0.01241', '0.00054', '0.01241', '0.00022', '0.01262', '0.00054', '0.01262', '0.02546'] Pebble transfer Eigen import numpy neighbor = [[ 1 , 3 , 0 , 0 ], [ 2 , 4 , 0 , 1 ], [ 2 , 5 , 1 , 2 ], [ 4 , 6 , 3 , 0 ], [ 5 , 7 , 3 , 1 ], [ 5 , 8 , 4 , 2 ], [ 7 , 6 , 6 , 3 ], [ 8 , 7 , 6 , 4 ], [ 8 , 8 , 7 , 5 ]] transfer = numpy . zeros(( 18 , 18 )) for k in range ( 9 ): for neigh in range ( 4 ): transfer[neighbor[k][neigh], k] += 0.25 # red pebble game transfer[neighbor[k][neigh] + 9 , k + 9 ] += 0.25 # blue pebble game # small transition epsilon between red 2 and blue 6 epsilon = 0.04 transfer[ 6 + 9 , 2 ] = transfer[ 2 , 6 + 9 ] = epsilon transfer[ 2 , 2 ] -= epsilon transfer[ 6 + 9 , 6 + 9 ] -= epsilon eigenvalues, eigenvectors = numpy . linalg . eig(transfer) print eigenvalues # you may print the eigenvectors by uncommenting the following four lines #for iter in range(18): # print eigenvalues[iter] # for i in range(18): # print eigenvectors[i][iter] [ -5.02430015e-01 -5.00000000e-01 1.00000000e+00 9.92451031e-01 7.25649298e-01 5.00000000e-01 4.79023434e-01 -1.50050555e-02 2.40311308e-01 7.50000000e-01 7.50000000e-01 1.52303605e-17 7.50000000e-01 -1.04083409e-16 1.07326675e-17 2.50000000e-01 2.50000000e-01 2.50000000e-01] random . seed( '1234' ) sigma = 0.4 epsilon = 0.4 # probability to switch from red to blue pebble, and vice versa pylab . figure() s_map_red = [( 1.0 , 1.0 ), ( 2.0 , 1.0 ), ( 3.0 , 1.0 ), ( 1.0 , 2.0 ), ( 2.0 , 2.0 ), ( 3.0 , 2.0 ), ( 1.0 , 3.0 ), ( 2.0 , 3.0 ), ( 3.0 , 3.0 )] offset = 3.0 s_map_blue = [(x + offset,y - offset) for (x,y) in s_map_red] color = 'red' #chose 'red' or 'blue' site = 8 tmax = 10 for iter in range (tmax): period = 4 if ( iter % period) == 0 : # Begin of graphical output maxlength = len ( str (tmax - 1 )) number_string = str ( iter ) . zfill(maxlength) if color == 'red' : cir = pylab . Circle(s_map_red[site], radius = sigma, fc = 'r' ) if color == 'blue' : cir = pylab . Circle(s_map_blue[site], radius = sigma, fc = 'b' ) pylab . figure() #pylab.subplot(2,2,iter) pylab . gca() . add_patch(cir) double_grider() pylab . title( 't = ' + number_string) pylab . axis( 'scaled' ) pylab . axis([ 0.5 , 6.5 , - 2.5 , 3.5 ]) pylab . xticks([]) pylab . yticks([]) number_string_filename = str ( iter / period) . zfill( 3 ) #pylab.savefig('peeble_dual/pebble_dual_movie_epsilon_'+number_string_filename+'.png', transparent=True) #pylab.clf() #pylab.close() pylab . show() # End of graphical output newsite = neighbor_o[site][ random . randint( 0 , 3 )] newcolor = color if (color == 'red' ) and (site == 2 ) and (newsite == 2 ): if random . random() < epsilon: newcolor = 'blue' newsite = 6 print \"transition red->blue at time = \" , iter if (color == 'blue' ) and (site == 6 ) and (newsite == 6 ): if random . random() < epsilon: newcolor = 'red' newsite = 2 print \"transition blue->red at time = \" , iter site = newsite color = newcolor &lt;matplotlib.figure.Figure at 0x10aa4cd50&gt; Pebble Dual Eigen import numpy neighbor = [[ 1 , 3 , 0 , 0 ], [ 2 , 4 , 0 , 1 ], [ 2 , 5 , 1 , 2 ], [ 4 , 6 , 3 , 0 ], [ 5 , 7 , 3 , 1 ], [ 5 , 8 , 4 , 2 ], [ 7 , 6 , 6 , 3 ], [ 8 , 7 , 6 , 4 ], [ 8 , 8 , 7 , 5 ]] transfer = numpy . zeros(( 18 , 18 )) for k in range ( 9 ): for neigh in range ( 4 ): transfer[neighbor[k][neigh], k] += 0.25 # red pebble game transfer[neighbor[k][neigh] + 9 , k + 9 ] += 0.25 # blue pebble game # small transition epsilon between red 2 and blue 6 epsilon = 0.04 transfer[ 6 + 9 , 2 ] = transfer[ 2 , 6 + 9 ] = epsilon transfer[ 2 , 2 ] -= epsilon transfer[ 6 + 9 , 6 + 9 ] -= epsilon eigenvalues, eigenvectors = numpy . linalg . eig(transfer) print eigenvalues # you may print the eigenvectors by uncommenting the following four lines #for iter in range(18): # print eigenvalues[iter] # for i in range(18): # print eigenvectors[i][iter] [ -5.02430015e-01 -5.00000000e-01 1.00000000e+00 9.92451031e-01 7.25649298e-01 5.00000000e-01 4.79023434e-01 -1.50050555e-02 2.40311308e-01 7.50000000e-01 7.50000000e-01 1.52303605e-17 7.50000000e-01 -1.04083409e-16 1.07326675e-17 2.50000000e-01 2.50000000e-01 2.50000000e-01] Pebble Recrrunt Movie import math , random , pylab sigma = 0.4 epsilon = 0.1 pylab . figure() s_map = [( 1.0 , 1.0 ), ( 2.0 , 1.0 )] neighbor = [[ 1 ], [ 0 ]] pos = 0 tmax = 5 for iter in range (tmax): # Begin of the graphics output pylab . figure() number_string = str ( iter ) . zfill( len ( str (tmax))) cir = pylab . Circle(s_map[pos], radius = sigma, fc = 'r' ) pylab . gca() . add_patch(cir) pylab . plot([ 1.5 , 1.5 ], [ 0.5 , 1.5 ], 'b' ) pylab . title( 't = ' + number_string) pylab . axis( 'scaled' ) pylab . axis([ 0.5 , 2.5 , 0.5 , 1.5 ]) pylab . xticks([]) pylab . yticks([]) pylab . savefig( 'recurrent/2x1pebble_epsilon' + number_string + '.png' , transparent = True ) #pylab.close() pylab . show() # End of the graphics output newpos = neighbor[pos][ 0 ] if random . random() < epsilon: newpos = pos pos = newpos &lt;matplotlib.figure.Figure at 0x10a282e10&gt; import numpy epsilon = 0.01 transfer = [[ epsilon, 1.0 - epsilon ], [ 1.0 - epsilon, epsilon ]] eigenvalues, eigenvectors = numpy . linalg . eig(transfer) print eigenvalues # you may print the eigenvectors by uncommenting the following lines... #for iter in range(2): # print eigenvalues[iter] # for i in range(2): # print eigenvectors[i][iter] [ 1. -0.98]","title":"Peeble-Dual"},{"location":"Montecarlo/HardDisk/hd/","text":"From Classical to Statistical Mechanics Molecular Dynamics of Hard Disk Direct Disc Box import random , math N = 4 sigma = 0.2 condition = False while condition == False : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma))] for k in range ( 1 , N): a = (random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) min_dist = min (math . sqrt((a[ 0 ] - b[ 0 ]) ** 2 + (a[ 1 ] - b[ 1 ]) ** 2 ) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True print L [(0.7040822912665547, 0.2838326710047917), (0.39342373803132735, 0.7421281133983488), (0.22142950612928214, 0.3458410218455974), (0.7925829007636611, 0.7013410752456171)] Direct Disk Box Multirun import random , math def direct_disks_box (N, sigma): condition = False while condition == False : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma))] for k in range ( 1 , N): a = (random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) min_dist = min (math . sqrt((a[ 0 ] - b[ 0 ]) ** 2 + (a[ 1 ] - b[ 1 ]) ** 2 ) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return L N = 4 sigma = 0.2 n_runs = 10 for run in range (n_runs): print run, direct_disks_box(N, sigma) 0 [(0.751356313701969, 0.7908289343521684), (0.24313895825655835, 0.7973141414323697), (0.7507021517199071, 0.2714537639453098), (0.3426034108818664, 0.25674882938107063)] 1 [(0.7001130563019435, 0.712536202933747), (0.7789122711097405, 0.21613491258078213), (0.26983653980009353, 0.2199783600278326), (0.25072808927037593, 0.6851623784867935)] 2 [(0.27105063881736857, 0.6886358310439302), (0.7644440210934729, 0.284338623092072), (0.7010507662892869, 0.6836895516220605), (0.26760130925261805, 0.2011960174940446)] 3 [(0.7117322082996034, 0.7923158146795577), (0.20576363915920695, 0.33938157321671625), (0.6867409813215277, 0.3649824434229453), (0.2923911189377729, 0.7825731272388934)] 4 [(0.6574676789386877, 0.6868976023198012), (0.2380039193149221, 0.21289805532217043), (0.7500703097734738, 0.2596580338864641), (0.2526218011018484, 0.6277752777754828)] 5 [(0.7644607478477052, 0.7887798072013239), (0.3913939422967541, 0.6150405110722064), (0.791845121739368, 0.37567457535107485), (0.27690058656665545, 0.22580973987400982)] 6 [(0.7883698163715596, 0.3078375245763364), (0.20119330613086495, 0.6697044533868605), (0.2766166755457118, 0.22309290996928166), (0.6054862825572884, 0.7994464708554057)] 7 [(0.389813730050234, 0.7708075320063368), (0.6868787305435617, 0.2611610652253845), (0.2654758128109487, 0.24841543305461442), (0.7983355323897738, 0.7423829503625712)] 8 [(0.339797971819223, 0.7785840995102176), (0.22143753469214858, 0.23470027601609306), (0.7785801571980291, 0.774135930262885), (0.7506325168837178, 0.2827089622089741)] 9 [(0.24318601622049738, 0.3458768932480638), (0.2964140949544102, 0.7758479941402523), (0.6929994951070302, 0.2861686259992965), (0.7290840925214166, 0.7150475327560442)] Direct Disk Box Movie % matplotlib inline import random , math , os , pylab output_dir = 'direct_disks_box_movie' def direct_disks_box (N, sigma): condition = False while condition == False : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma))] for k in range ( 1 , N): a = (random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) min_dist = min (math . sqrt((a[ 0 ] - b[ 0 ]) ** 2 + (a[ 1 ] - b[ 1 ]) ** 2 ) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return L img = 0 if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (pos, colors): global img pylab . subplots_adjust(left = 0.10 , right = 0.90 , top = 0.90 , bottom = 0.10 ) pylab . gcf() . set_size_inches( 6 , 6 ) pylab . axis([ 0 , 1 , 0 , 1 ]) pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ]) for (x, y), c in zip (pos, colors): circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) #pylab.savefig(os.path.join(output_dir, '%d.png' % img), transparent=True) #pylab.close() pylab . show() img += 1 N = 4 colors = [ 'r' , 'b' , 'g' , 'orange' ] sigma = 0.2 n_runs = 4 for run in range (n_runs): pos = direct_disks_box(N, sigma) snapshot(pos, colors) Marcov Disk Box import random L = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] sigma = 0.15 sigma_sq = sigma ** 2 delta = 0.1 n_steps = 1000 for steps in range (n_steps): a = random . choice(L) b = [a[ 0 ] + random . uniform( - delta, delta), a[ 1 ] + random . uniform( - delta, delta)] min_dist = min ((b[ 0 ] - c[ 0 ]) ** 2 + (b[ 1 ] - c[ 1 ]) ** 2 for c in L if c != a) box_cond = min (b[ 0 ], b[ 1 ]) < sigma or max (b[ 0 ], b[ 1 ]) > 1.0 - sigma if not (box_cond or min_dist < 4.0 * sigma ** 2 ): a[:] = b print L [[0.45422994214163115, 0.3713914635605748], [0.7844238520523379, 0.4224856102112645], [0.15518208223429647, 0.5396419610447033], [0.7314291546873124, 0.842673491596291]] Marcove Disk Box Movie import random , os , pylab output_dir = 'markov_disks_box_movie' img = 0 if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (pos, colors): global img pylab . subplots_adjust(left = 0.10 , right = 0.90 , top = 0.90 , bottom = 0.10 ) pylab . gcf() . set_size_inches( 6 , 6 ) pylab . axis([ 0 , 1 , 0 , 1 ]) pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ]) for (x, y), c in zip (pos, colors): circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) #pylab.savefig(os.path.join(output_dir, '%d.png' % img), transparent=True) #pylab.close() pylab . show() img += 1 L = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] sigma = 0.15 sigma_sq = sigma ** 2 delta = 0.1 colors = [ 'r' , 'b' , 'g' , 'orange' ] n_steps = 5 for step in range (n_steps): snapshot(L, colors) a = random . choice(L) b = [a[ 0 ] + random . uniform( - delta, delta), a[ 1 ] + random . uniform( - delta, delta)] min_dist = min ((b[ 0 ] - c[ 0 ]) ** 2 + (b[ 1 ] - c[ 1 ]) ** 2 for c in L if c != a) box_cond = min (b[ 0 ], b[ 1 ]) < sigma or max (b[ 0 ], b[ 1 ]) > 1.0 - sigma if not (box_cond or min_dist < 4.0 * sigma ** 2 ): a[:] = b Event Disk Box import math def wall_time (pos_a, vel_a, sigma): if vel_a > 0.0 : del_t = ( 1.0 - sigma - pos_a) / vel_a elif vel_a < 0.0 : del_t = (pos_a - sigma) / abs (vel_a) else : del_t = float ( 'inf' ) return del_t def pair_time (pos_a, vel_a, pos_b, vel_b, sigma): del_x = [pos_b[ 0 ] - pos_a[ 0 ], pos_b[ 1 ] - pos_a[ 1 ]] del_x_sq = del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 del_v = [vel_b[ 0 ] - vel_a[ 0 ], vel_b[ 1 ] - vel_a[ 1 ]] del_v_sq = del_v[ 0 ] ** 2 + del_v[ 1 ] ** 2 scal = del_v[ 0 ] * del_x[ 0 ] + del_v[ 1 ] * del_x[ 1 ] Upsilon = scal ** 2 - del_v_sq * ( del_x_sq - 4.0 * sigma ** 2 ) if Upsilon > 0.0 and scal < 0.0 : del_t = - (scal + math . sqrt(Upsilon)) / del_v_sq else : del_t = float ( 'inf' ) return del_t pos = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] vel = [[ 0.21 , 0.12 ], [ 0.71 , 0.18 ], [ - 0.23 , - 0.79 ], [ 0.78 , 0.1177 ]] singles = [( 0 , 0 ), ( 0 , 1 ), ( 1 , 0 ), ( 1 , 1 ), ( 2 , 0 ), ( 2 , 1 ), ( 3 , 0 ), ( 3 , 1 )] pairs = [( 0 , 1 ), ( 0 , 2 ), ( 0 , 3 ), ( 1 , 2 ), ( 1 , 3 ), ( 2 , 3 )] sigma = 0.15 t = 0.0 n_events = 10 for event in range (n_events): wall_times = [wall_time(pos[k][l], vel[k][l], sigma) for k, l in singles] pair_times = [pair_time(pos[k], vel[k], pos[l], vel[l], sigma) for k, l in pairs] next_event = min (wall_times + pair_times) t += next_event for k, l in singles: pos[k][l] += vel[k][l] * next_event if min (wall_times) < min (pair_times): collision_disk, direction = singles[wall_times . index(next_event)] vel[collision_disk][direction] *= - 1.0 else : a, b = pairs[pair_times . index(next_event)] del_x = [pos[b][ 0 ] - pos[a][ 0 ], pos[b][ 1 ] - pos[a][ 1 ]] abs_x = math . sqrt(del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 ) e_perp = [c / abs_x for c in del_x] del_v = [vel[b][ 0 ] - vel[a][ 0 ], vel[b][ 1 ] - vel[a][ 1 ]] scal = del_v[ 0 ] * e_perp[ 0 ] + del_v[ 1 ] * e_perp[ 1 ] for k in range ( 2 ): vel[a][k] += e_perp[k] * scal vel[b][k] -= e_perp[k] * scal print 'event' , event print 'time' , t print 'pos' , pos print 'vel' , vel event 0 time 0.128205128205 pos [[0.27692307692307694, 0.2653846153846154], [0.841025641025641, 0.27307692307692305], [0.2205128205128205, 0.6487179487179487], [0.85, 0.7650897435897436]] vel [[0.21, 0.12], [0.71, 0.18], [-0.23, -0.79], [-0.78, 0.1177]] event 1 time 0.140845070423 pos [[0.2795774647887324, 0.2669014084507042], [0.85, 0.2753521126760563], [0.21760563380281692, 0.6387323943661972], [0.8401408450704225, 0.7665774647887323]] vel [[0.21, 0.12], [-0.71, 0.18], [-0.23, -0.79], [-0.78, 0.1177]] event 2 time 0.241075114766 pos [[0.30062577410096064, 0.2789290137719775], [0.7788366685157999, 0.2933935206579662], [0.19455272360370984, 0.5595506593344816], [0.7619614104821464, 0.7783745410080145]] vel [[0.4559640224861213, -0.5307103210067202], [-0.71, 0.18], [-0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 3 time 0.334680348563 pos [[0.34330639302873317, 0.229251750095734], [0.7123769525200255, 0.31024246274140194], [0.15, 0.5465124163668252], [0.6889493281205914, 0.7893918770259055]] vel [[0.4559640224861213, -0.5307103210067202], [-0.71, 0.18], [0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 4 time 0.426596320324 pos [[0.38521676924328674, 0.18047099521717305], [0.6471166125702025, 0.3267873376582585], [0.19374869564975986, 0.5337094701659757], [0.6172548701475463, 0.8002103869020945]] vel [[-0.13004345387140676, -0.8580968115619534], [-0.12399252364247193, 0.5073864905552332], [0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 5 time 0.462106294031 pos [[0.38059892961546266, 0.15], [0.6427136413157146, 0.3448046185974856], [0.2106501655740237, 0.528763297327179], [0.5895570906555886, 0.8043899108074835]] vel [[-0.13004345387140676, 0.8580968115619534], [-0.12399252364247193, 0.5073864905552332], [0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 6 time 0.56183325768 pos [[0.36763009081848935, 0.23557538953362597], [0.6303482434177226, 0.39540473269688253], [0.2581166123425427, 0.5148723605735898], [0.5117700590096738, 0.8161277744289247]] vel [[0.2896767021129778, -0.21233369509579214], [-0.12399252364247193, 0.5073864905552332], [0.05624386650173674, 0.9311408276644657], [-0.78, 0.1177]] event 7 time 0.642779758788 pos [[0.3910784063071447, 0.21838771984821145], [0.6203114824652683, 0.43647589381698054], [0.26266935654466417, 0.5902449526121742], [0.44863178814515003, 0.8256551776093791]] vel [[0.2896767021129778, -0.21233369509579214], [-0.12399252364247193, 0.5073864905552332], [-0.6607492297641436, 0.023497791053664008], [-0.06300690373411966, 1.0253430366108016]] event 8 time 0.666522858923 pos [[0.39795622925208957, 0.2133462596635909], [0.6173675155604766, 0.4485228220692043], [0.24698112141847836, 0.5908028630181046], [0.44713580892061633, 0.85]] vel [[0.2896767021129778, -0.21233369509579214], [-0.12399252364247193, 0.5073864905552332], [-0.6607492297641436, 0.023497791053664008], [-0.06300690373411966, -1.0253430366108016]] event 9 time 0.764669954349 pos [[0.4263871561770383, 0.19250632422888558], [0.6051980095104381, 0.4983213323755524], [0.1821305037122126, 0.5931091029589469], [0.4409518643273318, 0.7493655591414552]] vel [[0.2896767021129778, -0.21233369509579214], [0.596499748925584, -0.5938596011324015], [-0.6607492297641436, 0.023497791053664008], [-0.7834991763021756, 0.07590305507683315]] Event Disk Box Movie import os , math , pylab output_dir = \"event_disks_box_movie\" colors = [ 'r' , 'b' , 'g' , 'orange' ] def wall_time (pos_a, vel_a, sigma): if vel_a > 0.0 : del_t = ( 1.0 - sigma - pos_a) / vel_a elif vel_a < 0.0 : del_t = (pos_a - sigma) / abs (vel_a) else : del_t = float ( 'inf' ) return del_t def pair_time (pos_a, vel_a, pos_b, vel_b, sigma): del_x = [pos_b[ 0 ] - pos_a[ 0 ], pos_b[ 1 ] - pos_a[ 1 ]] del_x_sq = del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 del_v = [vel_b[ 0 ] - vel_a[ 0 ], vel_b[ 1 ] - vel_a[ 1 ]] del_v_sq = del_v[ 0 ] ** 2 + del_v[ 1 ] ** 2 scal = del_v[ 0 ] * del_x[ 0 ] + del_v[ 1 ] * del_x[ 1 ] Upsilon = scal ** 2 - del_v_sq * (del_x_sq - 4.0 * sigma ** 2 ) if Upsilon > 0.0 and scal < 0.0 : del_t = - (scal + math . sqrt(Upsilon)) / del_v_sq else : del_t = float ( 'inf' ) return del_t def min_arg (l): return min ( zip (l, range ( len (l)))) def compute_next_event (pos, vel): wall_times = [wall_time(pos[k][l], vel[k][l], sigma) for k, l in singles] pair_times = [pair_time(pos[k], vel[k], pos[l], vel[l], sigma) for k, l in pairs] return min_arg(wall_times + pair_times) def compute_new_velocities (pos, vel, next_event_arg): if next_event_arg < len (singles): collision_disk, direction = singles[next_event_arg] vel[collision_disk][direction] *= - 1.0 else : a, b = pairs[next_event_arg - len (singles)] del_x = [pos[b][ 0 ] - pos[a][ 0 ], pos[b][ 1 ] - pos[a][ 1 ]] abs_x = math . sqrt(del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 ) e_perp = [c / abs_x for c in del_x] del_v = [vel[b][ 0 ] - vel[a][ 0 ], vel[b][ 1 ] - vel[a][ 1 ]] scal = del_v[ 0 ] * e_perp[ 0 ] + del_v[ 1 ] * e_perp[ 1 ] for k in range ( 2 ): vel[a][k] += e_perp[k] * scal vel[b][k] -= e_perp[k] * scal pylab . subplots_adjust(left = 0.10 , right = 0.90 , top = 0.90 , bottom = 0.10 ) pylab . gcf() . set_size_inches( 6 , 6 ) img = 0 if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (t, pos, vel, colors, arrow_scale =. 2 ): global img pylab . cla() pylab . axis([ 0 , 1 , 0 , 1 ]) pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ]) for (x, y), (dx, dy), c in zip (pos, vel, colors): dx *= arrow_scale dy *= arrow_scale circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) pylab . arrow( x, y, dx, dy, fc = \"k\" , ec = \"k\" , head_width = 0.05 , head_length = 0.05 ) pylab . text( . 5 , 1.03 , 't = %.2f ' % t, ha = 'center' ) pylab . savefig(os . path . join(output_dir, ' %d .png' % img)) img += 1 pos = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] vel = [[ 0.21 , 0.12 ], [ 0.71 , 0.18 ], [ - 0.23 , - 0.79 ], [ 0.78 , 0.1177 ]] singles = [( 0 , 0 ), ( 0 , 1 ), ( 1 , 0 ), ( 1 , 1 ), ( 2 , 0 ), ( 2 , 1 ), ( 3 , 0 ), ( 3 , 1 )] pairs = [( 0 , 1 ), ( 0 , 2 ), ( 0 , 3 ), ( 1 , 2 ), ( 1 , 3 ), ( 2 , 3 )] sigma = 0.15 t = 0.0 dt = 0.02 # dt=0 corresponds to event-to-event animation n_steps = 5 next_event, next_event_arg = compute_next_event(pos, vel) snapshot(t, pos, vel, colors) for step in range (n_steps): if dt: next_t = t + dt else : next_t = t + next_event while t + next_event <= next_t: t += next_event for k, l in singles: pos[k][l] += vel[k][l] * next_event compute_new_velocities(pos, vel, next_event_arg) next_event, next_event_arg = compute_next_event(pos, vel) remain_t = next_t - t for k, l in singles: pos[k][l] += vel[k][l] * remain_t t += remain_t next_event -= remain_t snapshot(t, pos, vel, colors) print 'time' ,t print ( 'Producing animation.gif using ImageMagick...' ) os . system( \"convert -delay 1 -dispose Background +page \" + str (output_dir) + \"/*.png -loop 0 \" + str (output_dir) + \"/animation.gif\" ) time 0.02 time 0.04 time 0.06 time 0.08 time 0.1 Producing animation.gif using ImageMagick... 32512 TUTORIAL Direct Discrete import random configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 10000 for run in range (n_runs): while True : red_rod = random . randint( 0 , 4 ) blue_rod = random . randint( 0 , 4 ) if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.1606 c 0.1744 b 0.1651 e 0.1688 d 0.1666 f 0.1645 Direct Disk Any import random configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 10000 for i in range (n_runs): red_rod = random . randint( 0 , 3 ) if red_rod >= 2 : red_rod += 1 while True : blue_rod = random . randint( 0 , 4 ) if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.125 c 0.2535 b 0.1282 e 0.1236 d 0.2448 f 0.1249 Direct Disk Slow import random N = 4 sigma = 0.2 pairs = [(i, j) for i in range (N - 1 ) for j in range (i + 1 , N)] while True : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) for k in range (N)] if min ((L[i][ 0 ] - L[j][ 0 ]) ** 2 + (L[i][ 1 ] - L[j][ 1 ]) ** 2 for i, j in pairs) > 4.0 * sigma ** 2 : break print L [(0.21551840405127012, 0.6946062982572399), (0.7165001545926342, 0.7818232246535084), (0.23604717555981464, 0.20175467827936644), (0.7369665863408736, 0.22746836079162713)] Direct Disk Multy Run import random , math def dist (x,y): d_x = abs (x[ 0 ] - y[ 0 ]) % 1.0 d_x = min (d_x, 1.0 - d_x) d_y = abs (x[ 1 ] - y[ 1 ]) % 1.0 d_y = min (d_y, 1.0 - d_y) return math . sqrt(d_x ** 2 + d_y ** 2 ) def direct_disks (N, sigma): n_iter = 0 condition = False while condition == False : n_iter += 1 L = [(random . random(), random . random())] for k in range ( 1 , N): a = (random . random(), random . random()) min_dist = min (dist(a, b) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return n_iter, L N = 16 eta = 0.26 sigma = math . sqrt(eta / N / math . pi) n_runs = 3 print 'Note that this program might take a while!' for run in range (n_runs): iterations, config = direct_disks(N, sigma) print 'run' ,run print iterations - 1 , 'tabula rasa wipe-outs before producing the following configuration' print config print Note that this program might take a while! run 0 31605 tabula rasa wipe-outs before producing the following configuration [(0.194889385979373, 0.39881902164303773), (0.2422007285687603, 0.7366374459128198), (0.35318282136090084, 0.5379884266619391), (0.5010455241583772, 0.4351768931362382), (0.6651055976532885, 0.4638578576617244), (0.9930426536472047, 0.4807095480519158), (0.17504742382982807, 0.10058142284791849), (0.055224973814334, 0.8728958780045791), (0.8132249354226135, 0.976570654646086), (0.6479652398072496, 0.05414388830919192), (0.01589908172878507, 0.2662968574596569), (0.6838513187488974, 0.19681773278090198), (0.9368744315347303, 0.685040874598465), (0.6148616792388668, 0.8576188696976752), (0.38396787071111793, 0.9725957113091733), (0.7881129382924161, 0.6785640836009906)] run 1 15954 tabula rasa wipe-outs before producing the following configuration [(0.4314049494382257, 0.6098720262344923), (0.017147469087248735, 0.04156012115642216), (0.36056156266147066, 0.848096088241863), (0.8125158065154952, 0.17366599388221793), (0.23732974230881831, 0.7494139151797977), (0.8348176875378838, 0.9989865343591413), (0.9598695317665644, 0.5346727546971781), (0.9745750478535258, 0.9026397096818709), (0.5788447208944535, 0.9892731652141654), (0.43368740080388346, 0.39188323415156523), (0.1026937138183539, 0.4900126255806251), (0.15313471644384324, 0.3225265326989947), (0.24881039713052955, 0.6005423814016275), (0.09841408880804847, 0.6398251433990972), (0.9254533880596515, 0.7439429279989943), (0.30040196508760963, 0.20692775996149626)] run 2 52422 tabula rasa wipe-outs before producing the following configuration [(0.5873980387542752, 0.03679282835548914), (0.11907075962976255, 0.44081971114056717), (0.9080215465908837, 0.671213015105709), (0.09022299677404289, 0.9507269787134838), (0.3001832219134687, 0.9687529174595204), (0.024158935597102804, 0.8117170627395138), (0.8457396014770665, 0.45224114982654495), (0.28763080699756904, 0.523078745591618), (0.8915709907417944, 0.1654529589377659), (0.205399596915937, 0.14035571179162276), (0.9776855981260978, 0.37045935309310907), (0.22316762060964956, 0.3302967536169472), (0.3872637064501423, 0.7600916230737015), (0.7138292384724666, 0.11545586820923892), (0.46404649182910096, 0.8999851793352671), (0.15322468771280318, 0.7070784377536645)] Direct Disk Multirun Movie import random , math , pylab , os def dist (x,y): d_x = abs (x[ 0 ] - y[ 0 ]) % 1.0 d_x = min (d_x, 1.0 - d_x) d_y = abs (x[ 1 ] - y[ 1 ]) % 1.0 d_y = min (d_y, 1.0 - d_y) return math . sqrt(d_x ** 2 + d_y ** 2 ) def direct_disks (N, sigma): n_iter = 0 condition = False while condition == False : n_iter += 1 L = [(random . random(), random . random())] for k in range ( 1 , N): a = (random . random(), random . random()) min_dist = min (dist(a, b) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return n_iter, L img = 0 output_dir = 'direct_disks_multirun_movie' if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (pos, colors, border_color = 'k' ): global img pylab . figure() pylab . axis([ 0 , 1 , 0 , 1 ]) [i . set_linewidth( 2 ) for i in pylab . gca() . spines . itervalues()] [i . set_color(border_color) for i in pylab . gca() . spines . itervalues()] pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ], aspect = 'equal' ) for (x, y), c in zip (pos, colors): circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) #pylab.savefig(output_dir+'/snapshot_%03i.png'%img) #pylab.close() pylab . show() img += 1 def periodicize (config): images = [ - 1.0 , 0.0 , 1.0 ] return [(x + dx, y + dy) for (x,y) in config for dx in images for dy in images] N = 16 eta = 0.28 sigma = math . sqrt(eta / N / math . pi) n_runs = 4 colors = [ 'r' for i in range ( 8 * N)] for run in range (n_runs): iterations, config = direct_disks(N, sigma) print 'run' ,run print iterations - 1 , 'tabula rasa wipe-outs before producing the following configuration' print config print config_per = periodicize(config) snapshot(config_per, colors, border_color = 'k' ) run 0 131155 tabula rasa wipe-outs before producing the following configuration [(0.37751482770484623, 0.09826945819054489), (0.9042803838379859, 0.9899090068252806), (0.6599172275086992, 0.13514484949079997), (0.3069710953434255, 0.9492470432337818), (0.812561619375132, 0.40987724481013443), (0.08056164082415274, 0.9742623716403652), (0.17768767689521647, 0.36507790353189173), (0.7472387120689303, 0.6515254273168409), (0.4823057447690441, 0.966105763619611), (0.8439633788642334, 0.22358147605283396), (0.2773016015309173, 0.5814435581054298), (0.9889618140696187, 0.1438503101976658), (0.14326378711556154, 0.7477166886625792), (0.9583168761426655, 0.7453819253487872), (0.6958450554989644, 0.833667878473739), (0.03867224868418362, 0.45119012797766134)] run 1 151638 tabula rasa wipe-outs before producing the following configuration [(0.06663014301020642, 0.031012554991157848), (0.964969664612716, 0.3118932568228565), (0.5264170452307265, 0.21975704506305127), (0.6756537746594122, 0.4041417433687611), (0.29476393772557075, 0.48140722828952787), (0.04654217216799017, 0.7996306905990145), (0.3608861327100239, 0.977618260879936), (0.6681113244137261, 0.6090611715960019), (0.12110126452367742, 0.22017356776253005), (0.8799686683355867, 0.6697177890430397), (0.5562558075938777, 0.010767930248896995), (0.47925142273497534, 0.6082991245007762), (0.8951272729365909, 0.868123465117719), (0.7441835171796956, 0.20179368489656824), (0.29000010977447666, 0.2067871038708291), (0.10233368264294007, 0.54745216577934)] run 2 40762 tabula rasa wipe-outs before producing the following configuration [(0.3260865108779446, 0.3148486233563623), (0.17803174008736766, 0.871851631193864), (0.8642532654525102, 0.08718797467709805), (0.4535702388344728, 0.1972919882412194), (0.07246890805097073, 0.5355473801360247), (0.3167501018585722, 0.7681798596800488), (0.671929948288115, 0.08427537345070424), (0.8644955101334825, 0.41613572562559775), (0.9021147383601401, 0.23196647448286645), (0.1780243297944175, 0.07236748708775964), (0.9632055830413773, 0.920103872618813), (0.90024339362327, 0.6917231317784356), (0.6185771240906243, 0.5665103724765188), (0.6793688570302557, 0.7331932103505989), (0.5239912054538993, 0.9604405020823239), (0.07573035699193864, 0.21241500055444595)] run 3 1734 tabula rasa wipe-outs before producing the following configuration [(0.2969684910325956, 0.7370119193950877), (0.9483844593486023, 0.6061018303643925), (0.1845637095681364, 0.11755918194051718), (0.9224199053841572, 0.869609425930199), (0.8519294493087842, 0.10902428512765583), (0.5101493777903654, 0.2872301781881832), (0.9875828733480082, 0.04180666162781088), (0.6831331006373645, 0.8465660961464345), (0.6993010504747139, 0.6378153765843604), (0.5672049317965627, 0.5350506678949322), (0.36850545523016154, 0.4642146828212168), (0.39988375455206737, 0.862433823125543), (0.7437881541243506, 0.3123760520673676), (0.6030356510965643, 0.10933875059004539), (0.9864351374492086, 0.2778717125787915), (0.16589795291507614, 0.5442153195383387)] Random Sequential Discrete import random configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 10000 for i in range (n_runs): red_rod = random . randint( 0 , 3 ) if red_rod >= 2 : red_rod += 1 while True : blue_rod = random . randint( 0 , 4 ) if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.1281 c 0.2548 b 0.122 e 0.1238 d 0.2474 f 0.1239 Random Sequential Discrete Movie import random , pylab , os output_dir = 'random_sequential_discrete_movie' if not os . path . exists(output_dir): os . makedirs(output_dir) def show_rods (red_rod, blue_rod, run, trial, frame): fig, ax = pylab . subplots() ax . set_xticks([ 0 , 1 , 2 , 3 , 4 ]) ax . set_yticks([]) height = 1.0 redrect = pylab . Rectangle((red_rod - 1.5 , 0.0 ), 3.0 , 1.1 * height, fc = 'r' ) pylab . gca() . add_patch(redrect) bluerect = pylab . Rectangle((blue_rod - 1.5 , 0.0 ), 3.0 , height, fc = 'b' ) pylab . gca() . add_patch(bluerect) pylab . axis( 'scaled' ) pylab . axis([ - 1.5 , 5.5 , 0.0 , 2.5 * height]) pylab . xlabel( \"x\" ) if abs (red_rod - blue_rod) > 2 : pylab . title( 'run %d , trial %d (ACCEPTED!)' % (run, trial)) else : pylab . title( 'run %d , trial %d (REJECTED!)' % (run, trial)) #pylab.savefig(output_dir+'/random_sequential_discrete_frame%d.png' % (frame)) pylab . show() configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 5 frame = 0 trial = 0 for run in range (n_runs): red_rod = random . randint( 0 , 3 ) if red_rod >= 2 : red_rod += 1 trial = 0 while True : blue_rod = random . randint( 0 , 4 ) show_rods(red_rod, blue_rod, run, trial, frame) trial += 1 frame += 1 if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.4 c 0.2 b 0.0 e 0.2 d 0.2 f 0.0","title":"Hard Disk"},{"location":"Montecarlo/HardDisk/hd/#from-classical-to-statistical-mechanics","text":"","title":"From Classical to Statistical Mechanics"},{"location":"Montecarlo/HardDisk/hd/#molecular-dynamics-of-hard-disk","text":"Direct Disc Box import random , math N = 4 sigma = 0.2 condition = False while condition == False : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma))] for k in range ( 1 , N): a = (random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) min_dist = min (math . sqrt((a[ 0 ] - b[ 0 ]) ** 2 + (a[ 1 ] - b[ 1 ]) ** 2 ) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True print L [(0.7040822912665547, 0.2838326710047917), (0.39342373803132735, 0.7421281133983488), (0.22142950612928214, 0.3458410218455974), (0.7925829007636611, 0.7013410752456171)] Direct Disk Box Multirun import random , math def direct_disks_box (N, sigma): condition = False while condition == False : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma))] for k in range ( 1 , N): a = (random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) min_dist = min (math . sqrt((a[ 0 ] - b[ 0 ]) ** 2 + (a[ 1 ] - b[ 1 ]) ** 2 ) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return L N = 4 sigma = 0.2 n_runs = 10 for run in range (n_runs): print run, direct_disks_box(N, sigma) 0 [(0.751356313701969, 0.7908289343521684), (0.24313895825655835, 0.7973141414323697), (0.7507021517199071, 0.2714537639453098), (0.3426034108818664, 0.25674882938107063)] 1 [(0.7001130563019435, 0.712536202933747), (0.7789122711097405, 0.21613491258078213), (0.26983653980009353, 0.2199783600278326), (0.25072808927037593, 0.6851623784867935)] 2 [(0.27105063881736857, 0.6886358310439302), (0.7644440210934729, 0.284338623092072), (0.7010507662892869, 0.6836895516220605), (0.26760130925261805, 0.2011960174940446)] 3 [(0.7117322082996034, 0.7923158146795577), (0.20576363915920695, 0.33938157321671625), (0.6867409813215277, 0.3649824434229453), (0.2923911189377729, 0.7825731272388934)] 4 [(0.6574676789386877, 0.6868976023198012), (0.2380039193149221, 0.21289805532217043), (0.7500703097734738, 0.2596580338864641), (0.2526218011018484, 0.6277752777754828)] 5 [(0.7644607478477052, 0.7887798072013239), (0.3913939422967541, 0.6150405110722064), (0.791845121739368, 0.37567457535107485), (0.27690058656665545, 0.22580973987400982)] 6 [(0.7883698163715596, 0.3078375245763364), (0.20119330613086495, 0.6697044533868605), (0.2766166755457118, 0.22309290996928166), (0.6054862825572884, 0.7994464708554057)] 7 [(0.389813730050234, 0.7708075320063368), (0.6868787305435617, 0.2611610652253845), (0.2654758128109487, 0.24841543305461442), (0.7983355323897738, 0.7423829503625712)] 8 [(0.339797971819223, 0.7785840995102176), (0.22143753469214858, 0.23470027601609306), (0.7785801571980291, 0.774135930262885), (0.7506325168837178, 0.2827089622089741)] 9 [(0.24318601622049738, 0.3458768932480638), (0.2964140949544102, 0.7758479941402523), (0.6929994951070302, 0.2861686259992965), (0.7290840925214166, 0.7150475327560442)] Direct Disk Box Movie % matplotlib inline import random , math , os , pylab output_dir = 'direct_disks_box_movie' def direct_disks_box (N, sigma): condition = False while condition == False : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma))] for k in range ( 1 , N): a = (random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) min_dist = min (math . sqrt((a[ 0 ] - b[ 0 ]) ** 2 + (a[ 1 ] - b[ 1 ]) ** 2 ) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return L img = 0 if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (pos, colors): global img pylab . subplots_adjust(left = 0.10 , right = 0.90 , top = 0.90 , bottom = 0.10 ) pylab . gcf() . set_size_inches( 6 , 6 ) pylab . axis([ 0 , 1 , 0 , 1 ]) pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ]) for (x, y), c in zip (pos, colors): circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) #pylab.savefig(os.path.join(output_dir, '%d.png' % img), transparent=True) #pylab.close() pylab . show() img += 1 N = 4 colors = [ 'r' , 'b' , 'g' , 'orange' ] sigma = 0.2 n_runs = 4 for run in range (n_runs): pos = direct_disks_box(N, sigma) snapshot(pos, colors) Marcov Disk Box import random L = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] sigma = 0.15 sigma_sq = sigma ** 2 delta = 0.1 n_steps = 1000 for steps in range (n_steps): a = random . choice(L) b = [a[ 0 ] + random . uniform( - delta, delta), a[ 1 ] + random . uniform( - delta, delta)] min_dist = min ((b[ 0 ] - c[ 0 ]) ** 2 + (b[ 1 ] - c[ 1 ]) ** 2 for c in L if c != a) box_cond = min (b[ 0 ], b[ 1 ]) < sigma or max (b[ 0 ], b[ 1 ]) > 1.0 - sigma if not (box_cond or min_dist < 4.0 * sigma ** 2 ): a[:] = b print L [[0.45422994214163115, 0.3713914635605748], [0.7844238520523379, 0.4224856102112645], [0.15518208223429647, 0.5396419610447033], [0.7314291546873124, 0.842673491596291]] Marcove Disk Box Movie import random , os , pylab output_dir = 'markov_disks_box_movie' img = 0 if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (pos, colors): global img pylab . subplots_adjust(left = 0.10 , right = 0.90 , top = 0.90 , bottom = 0.10 ) pylab . gcf() . set_size_inches( 6 , 6 ) pylab . axis([ 0 , 1 , 0 , 1 ]) pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ]) for (x, y), c in zip (pos, colors): circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) #pylab.savefig(os.path.join(output_dir, '%d.png' % img), transparent=True) #pylab.close() pylab . show() img += 1 L = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] sigma = 0.15 sigma_sq = sigma ** 2 delta = 0.1 colors = [ 'r' , 'b' , 'g' , 'orange' ] n_steps = 5 for step in range (n_steps): snapshot(L, colors) a = random . choice(L) b = [a[ 0 ] + random . uniform( - delta, delta), a[ 1 ] + random . uniform( - delta, delta)] min_dist = min ((b[ 0 ] - c[ 0 ]) ** 2 + (b[ 1 ] - c[ 1 ]) ** 2 for c in L if c != a) box_cond = min (b[ 0 ], b[ 1 ]) < sigma or max (b[ 0 ], b[ 1 ]) > 1.0 - sigma if not (box_cond or min_dist < 4.0 * sigma ** 2 ): a[:] = b Event Disk Box import math def wall_time (pos_a, vel_a, sigma): if vel_a > 0.0 : del_t = ( 1.0 - sigma - pos_a) / vel_a elif vel_a < 0.0 : del_t = (pos_a - sigma) / abs (vel_a) else : del_t = float ( 'inf' ) return del_t def pair_time (pos_a, vel_a, pos_b, vel_b, sigma): del_x = [pos_b[ 0 ] - pos_a[ 0 ], pos_b[ 1 ] - pos_a[ 1 ]] del_x_sq = del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 del_v = [vel_b[ 0 ] - vel_a[ 0 ], vel_b[ 1 ] - vel_a[ 1 ]] del_v_sq = del_v[ 0 ] ** 2 + del_v[ 1 ] ** 2 scal = del_v[ 0 ] * del_x[ 0 ] + del_v[ 1 ] * del_x[ 1 ] Upsilon = scal ** 2 - del_v_sq * ( del_x_sq - 4.0 * sigma ** 2 ) if Upsilon > 0.0 and scal < 0.0 : del_t = - (scal + math . sqrt(Upsilon)) / del_v_sq else : del_t = float ( 'inf' ) return del_t pos = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] vel = [[ 0.21 , 0.12 ], [ 0.71 , 0.18 ], [ - 0.23 , - 0.79 ], [ 0.78 , 0.1177 ]] singles = [( 0 , 0 ), ( 0 , 1 ), ( 1 , 0 ), ( 1 , 1 ), ( 2 , 0 ), ( 2 , 1 ), ( 3 , 0 ), ( 3 , 1 )] pairs = [( 0 , 1 ), ( 0 , 2 ), ( 0 , 3 ), ( 1 , 2 ), ( 1 , 3 ), ( 2 , 3 )] sigma = 0.15 t = 0.0 n_events = 10 for event in range (n_events): wall_times = [wall_time(pos[k][l], vel[k][l], sigma) for k, l in singles] pair_times = [pair_time(pos[k], vel[k], pos[l], vel[l], sigma) for k, l in pairs] next_event = min (wall_times + pair_times) t += next_event for k, l in singles: pos[k][l] += vel[k][l] * next_event if min (wall_times) < min (pair_times): collision_disk, direction = singles[wall_times . index(next_event)] vel[collision_disk][direction] *= - 1.0 else : a, b = pairs[pair_times . index(next_event)] del_x = [pos[b][ 0 ] - pos[a][ 0 ], pos[b][ 1 ] - pos[a][ 1 ]] abs_x = math . sqrt(del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 ) e_perp = [c / abs_x for c in del_x] del_v = [vel[b][ 0 ] - vel[a][ 0 ], vel[b][ 1 ] - vel[a][ 1 ]] scal = del_v[ 0 ] * e_perp[ 0 ] + del_v[ 1 ] * e_perp[ 1 ] for k in range ( 2 ): vel[a][k] += e_perp[k] * scal vel[b][k] -= e_perp[k] * scal print 'event' , event print 'time' , t print 'pos' , pos print 'vel' , vel event 0 time 0.128205128205 pos [[0.27692307692307694, 0.2653846153846154], [0.841025641025641, 0.27307692307692305], [0.2205128205128205, 0.6487179487179487], [0.85, 0.7650897435897436]] vel [[0.21, 0.12], [0.71, 0.18], [-0.23, -0.79], [-0.78, 0.1177]] event 1 time 0.140845070423 pos [[0.2795774647887324, 0.2669014084507042], [0.85, 0.2753521126760563], [0.21760563380281692, 0.6387323943661972], [0.8401408450704225, 0.7665774647887323]] vel [[0.21, 0.12], [-0.71, 0.18], [-0.23, -0.79], [-0.78, 0.1177]] event 2 time 0.241075114766 pos [[0.30062577410096064, 0.2789290137719775], [0.7788366685157999, 0.2933935206579662], [0.19455272360370984, 0.5595506593344816], [0.7619614104821464, 0.7783745410080145]] vel [[0.4559640224861213, -0.5307103210067202], [-0.71, 0.18], [-0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 3 time 0.334680348563 pos [[0.34330639302873317, 0.229251750095734], [0.7123769525200255, 0.31024246274140194], [0.15, 0.5465124163668252], [0.6889493281205914, 0.7893918770259055]] vel [[0.4559640224861213, -0.5307103210067202], [-0.71, 0.18], [0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 4 time 0.426596320324 pos [[0.38521676924328674, 0.18047099521717305], [0.6471166125702025, 0.3267873376582585], [0.19374869564975986, 0.5337094701659757], [0.6172548701475463, 0.8002103869020945]] vel [[-0.13004345387140676, -0.8580968115619534], [-0.12399252364247193, 0.5073864905552332], [0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 5 time 0.462106294031 pos [[0.38059892961546266, 0.15], [0.6427136413157146, 0.3448046185974856], [0.2106501655740237, 0.528763297327179], [0.5895570906555886, 0.8043899108074835]] vel [[-0.13004345387140676, 0.8580968115619534], [-0.12399252364247193, 0.5073864905552332], [0.4759640224861213, -0.13928967899327982], [-0.78, 0.1177]] event 6 time 0.56183325768 pos [[0.36763009081848935, 0.23557538953362597], [0.6303482434177226, 0.39540473269688253], [0.2581166123425427, 0.5148723605735898], [0.5117700590096738, 0.8161277744289247]] vel [[0.2896767021129778, -0.21233369509579214], [-0.12399252364247193, 0.5073864905552332], [0.05624386650173674, 0.9311408276644657], [-0.78, 0.1177]] event 7 time 0.642779758788 pos [[0.3910784063071447, 0.21838771984821145], [0.6203114824652683, 0.43647589381698054], [0.26266935654466417, 0.5902449526121742], [0.44863178814515003, 0.8256551776093791]] vel [[0.2896767021129778, -0.21233369509579214], [-0.12399252364247193, 0.5073864905552332], [-0.6607492297641436, 0.023497791053664008], [-0.06300690373411966, 1.0253430366108016]] event 8 time 0.666522858923 pos [[0.39795622925208957, 0.2133462596635909], [0.6173675155604766, 0.4485228220692043], [0.24698112141847836, 0.5908028630181046], [0.44713580892061633, 0.85]] vel [[0.2896767021129778, -0.21233369509579214], [-0.12399252364247193, 0.5073864905552332], [-0.6607492297641436, 0.023497791053664008], [-0.06300690373411966, -1.0253430366108016]] event 9 time 0.764669954349 pos [[0.4263871561770383, 0.19250632422888558], [0.6051980095104381, 0.4983213323755524], [0.1821305037122126, 0.5931091029589469], [0.4409518643273318, 0.7493655591414552]] vel [[0.2896767021129778, -0.21233369509579214], [0.596499748925584, -0.5938596011324015], [-0.6607492297641436, 0.023497791053664008], [-0.7834991763021756, 0.07590305507683315]] Event Disk Box Movie import os , math , pylab output_dir = \"event_disks_box_movie\" colors = [ 'r' , 'b' , 'g' , 'orange' ] def wall_time (pos_a, vel_a, sigma): if vel_a > 0.0 : del_t = ( 1.0 - sigma - pos_a) / vel_a elif vel_a < 0.0 : del_t = (pos_a - sigma) / abs (vel_a) else : del_t = float ( 'inf' ) return del_t def pair_time (pos_a, vel_a, pos_b, vel_b, sigma): del_x = [pos_b[ 0 ] - pos_a[ 0 ], pos_b[ 1 ] - pos_a[ 1 ]] del_x_sq = del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 del_v = [vel_b[ 0 ] - vel_a[ 0 ], vel_b[ 1 ] - vel_a[ 1 ]] del_v_sq = del_v[ 0 ] ** 2 + del_v[ 1 ] ** 2 scal = del_v[ 0 ] * del_x[ 0 ] + del_v[ 1 ] * del_x[ 1 ] Upsilon = scal ** 2 - del_v_sq * (del_x_sq - 4.0 * sigma ** 2 ) if Upsilon > 0.0 and scal < 0.0 : del_t = - (scal + math . sqrt(Upsilon)) / del_v_sq else : del_t = float ( 'inf' ) return del_t def min_arg (l): return min ( zip (l, range ( len (l)))) def compute_next_event (pos, vel): wall_times = [wall_time(pos[k][l], vel[k][l], sigma) for k, l in singles] pair_times = [pair_time(pos[k], vel[k], pos[l], vel[l], sigma) for k, l in pairs] return min_arg(wall_times + pair_times) def compute_new_velocities (pos, vel, next_event_arg): if next_event_arg < len (singles): collision_disk, direction = singles[next_event_arg] vel[collision_disk][direction] *= - 1.0 else : a, b = pairs[next_event_arg - len (singles)] del_x = [pos[b][ 0 ] - pos[a][ 0 ], pos[b][ 1 ] - pos[a][ 1 ]] abs_x = math . sqrt(del_x[ 0 ] ** 2 + del_x[ 1 ] ** 2 ) e_perp = [c / abs_x for c in del_x] del_v = [vel[b][ 0 ] - vel[a][ 0 ], vel[b][ 1 ] - vel[a][ 1 ]] scal = del_v[ 0 ] * e_perp[ 0 ] + del_v[ 1 ] * e_perp[ 1 ] for k in range ( 2 ): vel[a][k] += e_perp[k] * scal vel[b][k] -= e_perp[k] * scal pylab . subplots_adjust(left = 0.10 , right = 0.90 , top = 0.90 , bottom = 0.10 ) pylab . gcf() . set_size_inches( 6 , 6 ) img = 0 if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (t, pos, vel, colors, arrow_scale =. 2 ): global img pylab . cla() pylab . axis([ 0 , 1 , 0 , 1 ]) pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ]) for (x, y), (dx, dy), c in zip (pos, vel, colors): dx *= arrow_scale dy *= arrow_scale circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) pylab . arrow( x, y, dx, dy, fc = \"k\" , ec = \"k\" , head_width = 0.05 , head_length = 0.05 ) pylab . text( . 5 , 1.03 , 't = %.2f ' % t, ha = 'center' ) pylab . savefig(os . path . join(output_dir, ' %d .png' % img)) img += 1 pos = [[ 0.25 , 0.25 ], [ 0.75 , 0.25 ], [ 0.25 , 0.75 ], [ 0.75 , 0.75 ]] vel = [[ 0.21 , 0.12 ], [ 0.71 , 0.18 ], [ - 0.23 , - 0.79 ], [ 0.78 , 0.1177 ]] singles = [( 0 , 0 ), ( 0 , 1 ), ( 1 , 0 ), ( 1 , 1 ), ( 2 , 0 ), ( 2 , 1 ), ( 3 , 0 ), ( 3 , 1 )] pairs = [( 0 , 1 ), ( 0 , 2 ), ( 0 , 3 ), ( 1 , 2 ), ( 1 , 3 ), ( 2 , 3 )] sigma = 0.15 t = 0.0 dt = 0.02 # dt=0 corresponds to event-to-event animation n_steps = 5 next_event, next_event_arg = compute_next_event(pos, vel) snapshot(t, pos, vel, colors) for step in range (n_steps): if dt: next_t = t + dt else : next_t = t + next_event while t + next_event <= next_t: t += next_event for k, l in singles: pos[k][l] += vel[k][l] * next_event compute_new_velocities(pos, vel, next_event_arg) next_event, next_event_arg = compute_next_event(pos, vel) remain_t = next_t - t for k, l in singles: pos[k][l] += vel[k][l] * remain_t t += remain_t next_event -= remain_t snapshot(t, pos, vel, colors) print 'time' ,t print ( 'Producing animation.gif using ImageMagick...' ) os . system( \"convert -delay 1 -dispose Background +page \" + str (output_dir) + \"/*.png -loop 0 \" + str (output_dir) + \"/animation.gif\" ) time 0.02 time 0.04 time 0.06 time 0.08 time 0.1 Producing animation.gif using ImageMagick... 32512","title":"Molecular Dynamics of Hard Disk"},{"location":"Montecarlo/HardDisk/hd/#tutorial","text":"Direct Discrete import random configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 10000 for run in range (n_runs): while True : red_rod = random . randint( 0 , 4 ) blue_rod = random . randint( 0 , 4 ) if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.1606 c 0.1744 b 0.1651 e 0.1688 d 0.1666 f 0.1645 Direct Disk Any import random configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 10000 for i in range (n_runs): red_rod = random . randint( 0 , 3 ) if red_rod >= 2 : red_rod += 1 while True : blue_rod = random . randint( 0 , 4 ) if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.125 c 0.2535 b 0.1282 e 0.1236 d 0.2448 f 0.1249 Direct Disk Slow import random N = 4 sigma = 0.2 pairs = [(i, j) for i in range (N - 1 ) for j in range (i + 1 , N)] while True : L = [(random . uniform(sigma, 1.0 - sigma), random . uniform(sigma, 1.0 - sigma)) for k in range (N)] if min ((L[i][ 0 ] - L[j][ 0 ]) ** 2 + (L[i][ 1 ] - L[j][ 1 ]) ** 2 for i, j in pairs) > 4.0 * sigma ** 2 : break print L [(0.21551840405127012, 0.6946062982572399), (0.7165001545926342, 0.7818232246535084), (0.23604717555981464, 0.20175467827936644), (0.7369665863408736, 0.22746836079162713)] Direct Disk Multy Run import random , math def dist (x,y): d_x = abs (x[ 0 ] - y[ 0 ]) % 1.0 d_x = min (d_x, 1.0 - d_x) d_y = abs (x[ 1 ] - y[ 1 ]) % 1.0 d_y = min (d_y, 1.0 - d_y) return math . sqrt(d_x ** 2 + d_y ** 2 ) def direct_disks (N, sigma): n_iter = 0 condition = False while condition == False : n_iter += 1 L = [(random . random(), random . random())] for k in range ( 1 , N): a = (random . random(), random . random()) min_dist = min (dist(a, b) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return n_iter, L N = 16 eta = 0.26 sigma = math . sqrt(eta / N / math . pi) n_runs = 3 print 'Note that this program might take a while!' for run in range (n_runs): iterations, config = direct_disks(N, sigma) print 'run' ,run print iterations - 1 , 'tabula rasa wipe-outs before producing the following configuration' print config print Note that this program might take a while! run 0 31605 tabula rasa wipe-outs before producing the following configuration [(0.194889385979373, 0.39881902164303773), (0.2422007285687603, 0.7366374459128198), (0.35318282136090084, 0.5379884266619391), (0.5010455241583772, 0.4351768931362382), (0.6651055976532885, 0.4638578576617244), (0.9930426536472047, 0.4807095480519158), (0.17504742382982807, 0.10058142284791849), (0.055224973814334, 0.8728958780045791), (0.8132249354226135, 0.976570654646086), (0.6479652398072496, 0.05414388830919192), (0.01589908172878507, 0.2662968574596569), (0.6838513187488974, 0.19681773278090198), (0.9368744315347303, 0.685040874598465), (0.6148616792388668, 0.8576188696976752), (0.38396787071111793, 0.9725957113091733), (0.7881129382924161, 0.6785640836009906)] run 1 15954 tabula rasa wipe-outs before producing the following configuration [(0.4314049494382257, 0.6098720262344923), (0.017147469087248735, 0.04156012115642216), (0.36056156266147066, 0.848096088241863), (0.8125158065154952, 0.17366599388221793), (0.23732974230881831, 0.7494139151797977), (0.8348176875378838, 0.9989865343591413), (0.9598695317665644, 0.5346727546971781), (0.9745750478535258, 0.9026397096818709), (0.5788447208944535, 0.9892731652141654), (0.43368740080388346, 0.39188323415156523), (0.1026937138183539, 0.4900126255806251), (0.15313471644384324, 0.3225265326989947), (0.24881039713052955, 0.6005423814016275), (0.09841408880804847, 0.6398251433990972), (0.9254533880596515, 0.7439429279989943), (0.30040196508760963, 0.20692775996149626)] run 2 52422 tabula rasa wipe-outs before producing the following configuration [(0.5873980387542752, 0.03679282835548914), (0.11907075962976255, 0.44081971114056717), (0.9080215465908837, 0.671213015105709), (0.09022299677404289, 0.9507269787134838), (0.3001832219134687, 0.9687529174595204), (0.024158935597102804, 0.8117170627395138), (0.8457396014770665, 0.45224114982654495), (0.28763080699756904, 0.523078745591618), (0.8915709907417944, 0.1654529589377659), (0.205399596915937, 0.14035571179162276), (0.9776855981260978, 0.37045935309310907), (0.22316762060964956, 0.3302967536169472), (0.3872637064501423, 0.7600916230737015), (0.7138292384724666, 0.11545586820923892), (0.46404649182910096, 0.8999851793352671), (0.15322468771280318, 0.7070784377536645)] Direct Disk Multirun Movie import random , math , pylab , os def dist (x,y): d_x = abs (x[ 0 ] - y[ 0 ]) % 1.0 d_x = min (d_x, 1.0 - d_x) d_y = abs (x[ 1 ] - y[ 1 ]) % 1.0 d_y = min (d_y, 1.0 - d_y) return math . sqrt(d_x ** 2 + d_y ** 2 ) def direct_disks (N, sigma): n_iter = 0 condition = False while condition == False : n_iter += 1 L = [(random . random(), random . random())] for k in range ( 1 , N): a = (random . random(), random . random()) min_dist = min (dist(a, b) for b in L) if min_dist < 2.0 * sigma: condition = False break else : L . append(a) condition = True return n_iter, L img = 0 output_dir = 'direct_disks_multirun_movie' if not os . path . exists(output_dir): os . makedirs(output_dir) def snapshot (pos, colors, border_color = 'k' ): global img pylab . figure() pylab . axis([ 0 , 1 , 0 , 1 ]) [i . set_linewidth( 2 ) for i in pylab . gca() . spines . itervalues()] [i . set_color(border_color) for i in pylab . gca() . spines . itervalues()] pylab . setp(pylab . gca(), xticks = [ 0 , 1 ], yticks = [ 0 , 1 ], aspect = 'equal' ) for (x, y), c in zip (pos, colors): circle = pylab . Circle((x, y), radius = sigma, fc = c) pylab . gca() . add_patch(circle) #pylab.savefig(output_dir+'/snapshot_%03i.png'%img) #pylab.close() pylab . show() img += 1 def periodicize (config): images = [ - 1.0 , 0.0 , 1.0 ] return [(x + dx, y + dy) for (x,y) in config for dx in images for dy in images] N = 16 eta = 0.28 sigma = math . sqrt(eta / N / math . pi) n_runs = 4 colors = [ 'r' for i in range ( 8 * N)] for run in range (n_runs): iterations, config = direct_disks(N, sigma) print 'run' ,run print iterations - 1 , 'tabula rasa wipe-outs before producing the following configuration' print config print config_per = periodicize(config) snapshot(config_per, colors, border_color = 'k' ) run 0 131155 tabula rasa wipe-outs before producing the following configuration [(0.37751482770484623, 0.09826945819054489), (0.9042803838379859, 0.9899090068252806), (0.6599172275086992, 0.13514484949079997), (0.3069710953434255, 0.9492470432337818), (0.812561619375132, 0.40987724481013443), (0.08056164082415274, 0.9742623716403652), (0.17768767689521647, 0.36507790353189173), (0.7472387120689303, 0.6515254273168409), (0.4823057447690441, 0.966105763619611), (0.8439633788642334, 0.22358147605283396), (0.2773016015309173, 0.5814435581054298), (0.9889618140696187, 0.1438503101976658), (0.14326378711556154, 0.7477166886625792), (0.9583168761426655, 0.7453819253487872), (0.6958450554989644, 0.833667878473739), (0.03867224868418362, 0.45119012797766134)] run 1 151638 tabula rasa wipe-outs before producing the following configuration [(0.06663014301020642, 0.031012554991157848), (0.964969664612716, 0.3118932568228565), (0.5264170452307265, 0.21975704506305127), (0.6756537746594122, 0.4041417433687611), (0.29476393772557075, 0.48140722828952787), (0.04654217216799017, 0.7996306905990145), (0.3608861327100239, 0.977618260879936), (0.6681113244137261, 0.6090611715960019), (0.12110126452367742, 0.22017356776253005), (0.8799686683355867, 0.6697177890430397), (0.5562558075938777, 0.010767930248896995), (0.47925142273497534, 0.6082991245007762), (0.8951272729365909, 0.868123465117719), (0.7441835171796956, 0.20179368489656824), (0.29000010977447666, 0.2067871038708291), (0.10233368264294007, 0.54745216577934)] run 2 40762 tabula rasa wipe-outs before producing the following configuration [(0.3260865108779446, 0.3148486233563623), (0.17803174008736766, 0.871851631193864), (0.8642532654525102, 0.08718797467709805), (0.4535702388344728, 0.1972919882412194), (0.07246890805097073, 0.5355473801360247), (0.3167501018585722, 0.7681798596800488), (0.671929948288115, 0.08427537345070424), (0.8644955101334825, 0.41613572562559775), (0.9021147383601401, 0.23196647448286645), (0.1780243297944175, 0.07236748708775964), (0.9632055830413773, 0.920103872618813), (0.90024339362327, 0.6917231317784356), (0.6185771240906243, 0.5665103724765188), (0.6793688570302557, 0.7331932103505989), (0.5239912054538993, 0.9604405020823239), (0.07573035699193864, 0.21241500055444595)] run 3 1734 tabula rasa wipe-outs before producing the following configuration [(0.2969684910325956, 0.7370119193950877), (0.9483844593486023, 0.6061018303643925), (0.1845637095681364, 0.11755918194051718), (0.9224199053841572, 0.869609425930199), (0.8519294493087842, 0.10902428512765583), (0.5101493777903654, 0.2872301781881832), (0.9875828733480082, 0.04180666162781088), (0.6831331006373645, 0.8465660961464345), (0.6993010504747139, 0.6378153765843604), (0.5672049317965627, 0.5350506678949322), (0.36850545523016154, 0.4642146828212168), (0.39988375455206737, 0.862433823125543), (0.7437881541243506, 0.3123760520673676), (0.6030356510965643, 0.10933875059004539), (0.9864351374492086, 0.2778717125787915), (0.16589795291507614, 0.5442153195383387)] Random Sequential Discrete import random configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 10000 for i in range (n_runs): red_rod = random . randint( 0 , 3 ) if red_rod >= 2 : red_rod += 1 while True : blue_rod = random . randint( 0 , 4 ) if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.1281 c 0.2548 b 0.122 e 0.1238 d 0.2474 f 0.1239 Random Sequential Discrete Movie import random , pylab , os output_dir = 'random_sequential_discrete_movie' if not os . path . exists(output_dir): os . makedirs(output_dir) def show_rods (red_rod, blue_rod, run, trial, frame): fig, ax = pylab . subplots() ax . set_xticks([ 0 , 1 , 2 , 3 , 4 ]) ax . set_yticks([]) height = 1.0 redrect = pylab . Rectangle((red_rod - 1.5 , 0.0 ), 3.0 , 1.1 * height, fc = 'r' ) pylab . gca() . add_patch(redrect) bluerect = pylab . Rectangle((blue_rod - 1.5 , 0.0 ), 3.0 , height, fc = 'b' ) pylab . gca() . add_patch(bluerect) pylab . axis( 'scaled' ) pylab . axis([ - 1.5 , 5.5 , 0.0 , 2.5 * height]) pylab . xlabel( \"x\" ) if abs (red_rod - blue_rod) > 2 : pylab . title( 'run %d , trial %d (ACCEPTED!)' % (run, trial)) else : pylab . title( 'run %d , trial %d (REJECTED!)' % (run, trial)) #pylab.savefig(output_dir+'/random_sequential_discrete_frame%d.png' % (frame)) pylab . show() configurations = {( 0 , 3 ): 'a' , ( 0 , 4 ): 'b' , ( 1 , 4 ): 'c' , ( 3 , 0 ): 'd' , ( 4 , 0 ): 'e' , ( 4 , 1 ): 'f' } counts = { 'a' : 0 , 'b' : 0 , 'c' : 0 , 'd' : 0 , 'e' : 0 , 'f' : 0 } n_runs = 5 frame = 0 trial = 0 for run in range (n_runs): red_rod = random . randint( 0 , 3 ) if red_rod >= 2 : red_rod += 1 trial = 0 while True : blue_rod = random . randint( 0 , 4 ) show_rods(red_rod, blue_rod, run, trial, frame) trial += 1 frame += 1 if abs (red_rod - blue_rod) > 2 : break conf = configurations[(red_rod, blue_rod)] counts[conf] += 1 for conf in counts: print conf, counts[conf] / float (n_runs) a 0.4 c 0.2 b 0.0 e 0.2 d 0.2 f 0.0","title":"TUTORIAL"},{"location":"Montecarlo/IdealGas/IdealGas/","text":"Maxwell's distribution of speed. Import import math as math import random as random import numpy as np import matplotlib.pyplot as plt Global constants m = 3.2 # mass is in unit of Kb Kb = 1.0 Input parameters N = 100 u0 = 150.00 dv = 1.0 Starter def starter (key): u = [ 0.0 for k in range (N)] if key == 0 : return u else : for k in range (N): u[k] = u0 return u Hamiltonian def hamiltonian (u): H = 0.0 for k in range (N): H = H + 0.5 * u[k] ** 2 return H Pick a particle and change def pick_random_particle (printkey): n = random . randint( 0 , N - 1 ) if printkey == 1 : print \"particle picked at\" ,n return n Thermalization def thermalize (u,T,nruns,printkey): irun = 0 h_stor = [ 0.0 for k in range (nrun)] while irun < nrun: L = len (u) h_old = hamiltonian(u) n = pick_random_particle(printkey) ov = u[n] du = random . uniform( - dv,dv) u[n] = u[n] + du h_new = hamiltonian(u) dh = 0.5 * m * (u[n] ** 2 - ov ** 2 ) if printkey == 1 : print \"=================\" , irun, \"====================\" if dh < 0 : if printkey == 1 : print irun, \"Energy decreased! It is accepted!\" ,dh if printkey == 1 : print irun, \"old speed = \" , ov, \"replaced by\" ,u[n] h_stor[irun] = h_new else : if printkey == 1 : print irun, \"Energy increased!\" ,dh frac = math . exp( - dh / (Kb * T)) b = random . uniform( 0.0 , 1.0 ) if printkey == 1 : print \"frac =\" ,frac, \"b =\" ,b if b < frac: if printkey == 1 : print irun, \"You Lucky\" h_stor[irun] = h_new else : if printkey == 1 : print irun, \"Loser\" if printkey == 1 : print \"speed restablished at\" , n, \":\" ,u[n], \"by\" ,u[n] - du, \"which is old\" ,ov u[n] = u[n] - du h_stor[irun] = h_old if u[n] != ov : if printkey == 1 : print \"Warning! speed changed at\" ,n, \":\" , ov, \" replaced by\" , u[n] if printkey == 1 : print \"---------------info-closed----------------\" if printkey == 1 : print \"\" if printkey == 2 : print irun, h_stor[irun] irun = irun + 1 return h_stor,u Simulation Test N = 10 u = starter( 1 ) T = 300.0 nrun = 100 H,u = thermalize(u,T,nrun, 1 ) particle picked at 2 ================= 0 ==================== 0 Energy increased! 5.16166800614 frac = 0.982941610369 b = 0.296378524508 0 You Lucky Warning! speed changed at 2 : 300.0 replaced by 300.017205067 ---------------info-closed---------------- particle picked at 0 ================= 1 ==================== 1 Energy increased! 23.3951734115 frac = 0.924979308072 b = 0.607024790315 1 You Lucky Warning! speed changed at 0 : 300.0 replaced by 300.077973778 ---------------info-closed---------------- particle picked at 8 ================= 2 ==================== 2 Energy decreased! It is accepted! -28.9376550483 2 old speed = 300.0 replaced by 299.903525638 Warning! speed changed at 8 : 300.0 replaced by 299.903525638 ---------------info-closed---------------- particle picked at 0 ================= 3 ==================== 3 Energy increased! 17.437958518 frac = 0.943530556478 b = 0.639751221503 3 You Lucky Warning! speed changed at 0 : 300.077973778 replaced by 300.136079577 ---------------info-closed---------------- particle picked at 6 ================= 4 ==================== 4 Energy decreased! It is accepted! -4.76002312716 4 old speed = 300.0 replaced by 299.984132837 Warning! speed changed at 6 : 300.0 replaced by 299.984132837 ---------------info-closed---------------- particle picked at 4 ================= 5 ==================== 5 Energy decreased! It is accepted! -23.0744788723 5 old speed = 300.0 replaced by 299.923075208 Warning! speed changed at 4 : 300.0 replaced by 299.923075208 ---------------info-closed---------------- particle picked at 4 ================= 6 ==================== 6 Energy decreased! It is accepted! -25.1873042255 6 old speed = 299.923075208 replaced by 299.839084233 Warning! speed changed at 4 : 299.923075208 replaced by 299.839084233 ---------------info-closed---------------- particle picked at 8 ================= 7 ==================== 7 Energy decreased! It is accepted! -23.5188848983 7 old speed = 299.903525638 replaced by 299.82509388 Warning! speed changed at 8 : 299.903525638 replaced by 299.82509388 ---------------info-closed---------------- particle picked at 4 ================= 8 ==================== 8 Energy increased! 3.66195450823 frac = 0.987867682273 b = 0.901236906352 8 You Lucky Warning! speed changed at 4 : 299.839084233 replaced by 299.85129705 ---------------info-closed---------------- particle picked at 0 ================= 9 ==================== 9 Energy decreased! It is accepted! -9.42665565287 9 old speed = 300.136079577 replaced by 300.104669995 Warning! speed changed at 0 : 300.136079577 replaced by 300.104669995 ---------------info-closed---------------- particle picked at 4 ================= 10 ==================== 10 Energy decreased! It is accepted! -1.94555000914 10 old speed = 299.85129705 replaced by 299.844808597 Warning! speed changed at 4 : 299.85129705 replaced by 299.844808597 ---------------info-closed---------------- particle picked at 2 ================= 11 ==================== 11 Energy decreased! It is accepted! -27.8179773732 11 old speed = 300.017205067 replaced by 299.924469461 Warning! speed changed at 2 : 300.017205067 replaced by 299.924469461 ---------------info-closed---------------- particle picked at 7 ================= 12 ==================== 12 Energy decreased! It is accepted! -15.7483746502 12 old speed = 300.0 replaced by 299.947500824 Warning! speed changed at 7 : 300.0 replaced by 299.947500824 ---------------info-closed---------------- particle picked at 7 ================= 13 ==================== 13 Energy increased! 16.6569944456 frac = 0.945989967829 b = 0.855436607854 13 You Lucky Warning! speed changed at 7 : 299.947500824 replaced by 300.003028717 ---------------info-closed---------------- particle picked at 5 ================= 14 ==================== 14 Energy increased! 13.5605829688 frac = 0.955804444106 b = 0.462274377115 14 You Lucky Warning! speed changed at 5 : 300.0 replaced by 300.045198538 ---------------info-closed---------------- particle picked at 2 ================= 15 ==================== 15 Energy decreased! It is accepted! -10.1659196052 15 old speed = 299.924469461 replaced by 299.890572613 Warning! speed changed at 2 : 299.924469461 replaced by 299.890572613 ---------------info-closed---------------- particle picked at 2 ================= 16 ==================== 16 Energy increased! 13.1461147765 frac = 0.957125858504 b = 0.0764044163788 16 You Lucky Warning! speed changed at 2 : 299.890572613 replaced by 299.934405782 ---------------info-closed---------------- particle picked at 6 ================= 17 ==================== 17 Energy increased! 16.0662962599 frac = 0.947854451331 b = 0.311728441504 17 You Lucky Warning! speed changed at 6 : 299.984132837 replaced by 300.03768521 ---------------info-closed---------------- particle picked at 0 ================= 18 ==================== 18 Energy increased! 14.9157901932 frac = 0.951496471466 b = 0.778044719102 18 You Lucky Warning! speed changed at 0 : 300.104669995 replaced by 300.154367839 ---------------info-closed---------------- particle picked at 5 ================= 19 ==================== 19 Energy increased! 0.212891347102 frac = 0.99929061391 b = 0.600347076825 19 You Lucky Warning! speed changed at 5 : 300.045198538 replaced by 300.045908068 ---------------info-closed---------------- particle picked at 7 ================= 20 ==================== 20 Energy increased! 5.6356927141 frac = 0.981389708059 b = 0.962471313504 20 You Lucky Warning! speed changed at 7 : 300.003028717 replaced by 300.021813582 ---------------info-closed---------------- particle picked at 8 ================= 21 ==================== 21 Energy decreased! It is accepted! -0.361216020458 21 old speed = 299.82509388 replaced by 299.823889122 Warning! speed changed at 8 : 299.82509388 replaced by 299.823889122 ---------------info-closed---------------- particle picked at 8 ================= 22 ==================== 22 Energy increased! 9.18340368766 frac = 0.969852437229 b = 0.910312616567 22 You Lucky Warning! speed changed at 8 : 299.823889122 replaced by 299.854516884 ---------------info-closed---------------- particle picked at 2 ================= 23 ==================== 23 Energy decreased! It is accepted! -15.3415660895 23 old speed = 299.934405782 replaced by 299.883251682 Warning! speed changed at 2 : 299.934405782 replaced by 299.883251682 ---------------info-closed---------------- particle picked at 3 ================= 24 ==================== 24 Energy decreased! It is accepted! -29.9420272373 24 old speed = 300.0 replaced by 299.900176635 Warning! speed changed at 3 : 300.0 replaced by 299.900176635 ---------------info-closed---------------- particle picked at 1 ================= 25 ==================== 25 Energy increased! 3.67190862696 frac = 0.987834904977 b = 0.85142877576 25 You Lucky Warning! speed changed at 1 : 300.0 replaced by 300.012239446 ---------------info-closed---------------- particle picked at 0 ================= 26 ==================== 26 Energy decreased! It is accepted! -28.9294825618 26 old speed = 300.154367839 replaced by 300.057970345 Warning! speed changed at 0 : 300.154367839 replaced by 300.057970345 ---------------info-closed---------------- particle picked at 0 ================= 27 ==================== 27 Energy decreased! It is accepted! -17.5218772821 27 old speed = 300.057970345 replaced by 299.999569688 Warning! speed changed at 0 : 300.057970345 replaced by 299.999569688 ---------------info-closed---------------- particle picked at 1 ================= 28 ==================== 28 Energy increased! 10.987743112 frac = 0.964036800437 b = 0.354706880466 28 You Lucky Warning! speed changed at 1 : 300.012239446 replaced by 300.048861527 ---------------info-closed---------------- particle picked at 2 ================= 29 ==================== 29 Energy decreased! It is accepted! -23.0555321212 29 old speed = 299.883251682 replaced by 299.806360131 Warning! speed changed at 2 : 299.883251682 replaced by 299.806360131 ---------------info-closed---------------- particle picked at 0 ================= 30 ==================== 30 Energy increased! 14.56813825 frac = 0.95259974259 b = 0.992217091382 30 Loser speed restablished at 0 : 300.048126289 by 299.999569688 which is old 299.999569688 ---------------info-closed---------------- particle picked at 4 ================= 31 ==================== 31 Energy decreased! It is accepted! -19.1459640601 31 old speed = 299.844808597 replaced by 299.780948885 Warning! speed changed at 4 : 299.844808597 replaced by 299.780948885 ---------------info-closed---------------- particle picked at 2 ================= 32 ==================== 32 Energy increased! 10.3893583094 frac = 0.965961602654 b = 0.0652759977248 32 You Lucky Warning! speed changed at 2 : 299.806360131 replaced by 299.841011691 ---------------info-closed---------------- particle picked at 5 ================= 33 ==================== 33 Energy increased! 27.6413736072 frac = 0.911979367951 b = 0.925790017225 33 Loser speed restablished at 5 : 300.138017745 by 300.045908068 which is old 300.045908068 ---------------info-closed---------------- particle picked at 3 ================= 34 ==================== 34 Energy increased! 6.48585504453 frac = 0.978612509829 b = 0.639748903698 34 You Lucky Warning! speed changed at 3 : 299.900176635 replaced by 299.921802568 ---------------info-closed---------------- particle picked at 5 ================= 35 ==================== 35 Energy decreased! It is accepted! -26.3949101618 35 old speed = 300.045908068 replaced by 299.957925597 Warning! speed changed at 5 : 300.045908068 replaced by 299.957925597 ---------------info-closed---------------- particle picked at 5 ================= 36 ==================== 36 Energy increased! 13.992910126 frac = 0.954428035382 b = 0.00198934609112 36 You Lucky Warning! speed changed at 5 : 299.957925597 replaced by 300.004571546 ---------------info-closed---------------- particle picked at 5 ================= 37 ==================== 37 Energy decreased! It is accepted! -18.5791926362 37 old speed = 300.004571546 replaced by 299.942635454 Warning! speed changed at 5 : 300.004571546 replaced by 299.942635454 ---------------info-closed---------------- particle picked at 5 ================= 38 ==================== 38 Energy increased! 19.0993831631 frac = 0.93831964928 b = 0.684421660523 38 You Lucky Warning! speed changed at 5 : 299.942635454 replaced by 300.006305483 ---------------info-closed---------------- particle picked at 3 ================= 39 ==================== 39 Energy increased! 12.6217197065 frac = 0.958800361851 b = 0.978536469383 39 Loser speed restablished at 3 : 299.963882984 by 299.921802568 which is old 299.921802568 ---------------info-closed---------------- particle picked at 0 ================= 40 ==================== 40 Energy decreased! It is accepted! -24.2180688647 40 old speed = 299.999569688 replaced by 299.918831812 Warning! speed changed at 0 : 299.999569688 replaced by 299.918831812 ---------------info-closed---------------- particle picked at 3 ================= 41 ==================== 41 Energy decreased! It is accepted! -4.27460233111 41 old speed = 299.921802568 replaced by 299.90754984 Warning! speed changed at 3 : 299.921802568 replaced by 299.90754984 ---------------info-closed---------------- particle picked at 3 ================= 42 ==================== 42 Energy increased! 10.8331681318 frac = 0.964533648324 b = 0.980522343152 42 Loser speed restablished at 3 : 299.943669357 by 299.90754984 which is old 299.90754984 ---------------info-closed---------------- particle picked at 2 ================= 43 ==================== 43 Energy decreased! It is accepted! -0.620556065638 43 old speed = 299.841011691 replaced by 299.838942067 Warning! speed changed at 2 : 299.841011691 replaced by 299.838942067 ---------------info-closed---------------- particle picked at 3 ================= 44 ==================== 44 Energy increased! 21.5404667892 frac = 0.930715572441 b = 0.255181673312 44 You Lucky Warning! speed changed at 3 : 299.90754984 replaced by 299.979364931 ---------------info-closed---------------- particle picked at 4 ================= 45 ==================== 45 Energy increased! 6.331827505 frac = 0.979115083092 b = 0.535424245741 45 You Lucky Warning! speed changed at 4 : 299.780948885 replaced by 299.802069655 ---------------info-closed---------------- particle picked at 4 ================= 46 ==================== 46 Energy increased! 9.67196917396 frac = 0.968274267884 b = 0.448130433025 46 You Lucky Warning! speed changed at 4 : 299.802069655 replaced by 299.834329102 ---------------info-closed---------------- particle picked at 1 ================= 47 ==================== 47 Energy decreased! It is accepted! -22.1880505342 47 old speed = 300.048861527 replaced by 299.974904288 Warning! speed changed at 1 : 300.048861527 replaced by 299.974904288 ---------------info-closed---------------- particle picked at 0 ================= 48 ==================== 48 Energy decreased! It is accepted! -26.4379926945 48 old speed = 299.918831812 replaced by 299.830668362 Warning! speed changed at 0 : 299.918831812 replaced by 299.830668362 ---------------info-closed---------------- particle picked at 5 ================= 49 ==================== 49 Energy decreased! It is accepted! -17.6255352389 49 old speed = 300.006305483 replaced by 299.94754918 Warning! speed changed at 5 : 300.006305483 replaced by 299.94754918 ---------------info-closed---------------- particle picked at 5 ================= 50 ==================== 50 Energy increased! 26.9557187349 frac = 0.914066095325 b = 0.216679528733 50 You Lucky Warning! speed changed at 5 : 299.94754918 replaced by 300.037403829 ---------------info-closed---------------- particle picked at 8 ================= 51 ==================== 51 Energy decreased! It is accepted! -27.966674026 51 old speed = 299.854516884 replaced by 299.761234898 Warning! speed changed at 8 : 299.854516884 replaced by 299.761234898 ---------------info-closed---------------- particle picked at 2 ================= 52 ==================== 52 Energy decreased! It is accepted! -22.2578037851 52 old speed = 299.838942067 replaced by 299.764700344 Warning! speed changed at 2 : 299.838942067 replaced by 299.764700344 ---------------info-closed---------------- particle picked at 1 ================= 53 ==================== 53 Energy increased! 1.8452384392 frac = 0.993868082617 b = 0.932817295881 53 You Lucky Warning! speed changed at 1 : 299.974904288 replaced by 299.981055534 ---------------info-closed---------------- particle picked at 6 ================= 54 ==================== 54 Energy increased! 12.3385972816 frac = 0.959705648574 b = 0.262262734931 54 You Lucky Warning! speed changed at 6 : 300.03768521 replaced by 300.078805884 ---------------info-closed---------------- particle picked at 4 ================= 55 ==================== 55 Energy increased! 17.1512405735 frac = 0.944432744672 b = 0.868938895111 55 You Lucky Warning! speed changed at 4 : 299.834329102 replaced by 299.891526038 ---------------info-closed---------------- particle picked at 5 ================= 56 ==================== 56 Energy decreased! It is accepted! -1.43622642083 56 old speed = 300.037403829 replaced by 300.032616966 Warning! speed changed at 5 : 300.037403829 replaced by 300.032616966 ---------------info-closed---------------- particle picked at 3 ================= 57 ==================== 57 Energy decreased! It is accepted! -26.2834912367 57 old speed = 299.979364931 replaced by 299.891734468 Warning! speed changed at 3 : 299.979364931 replaced by 299.891734468 ---------------info-closed---------------- particle picked at 5 ================= 58 ==================== 58 Energy increased! 10.2306393701 frac = 0.966472792538 b = 0.0967580124621 58 You Lucky Warning! speed changed at 5 : 300.032616966 replaced by 300.066713453 ---------------info-closed---------------- particle picked at 4 ================= 59 ==================== 59 Energy decreased! It is accepted! -14.4982905504 59 old speed = 299.891526038 replaced by 299.843177024 Warning! speed changed at 4 : 299.891526038 replaced by 299.843177024 ---------------info-closed---------------- particle picked at 7 ================= 60 ==================== 60 Energy decreased! It is accepted! -3.0215758524 60 old speed = 300.021813582 replaced by 300.011742226 Warning! speed changed at 7 : 300.021813582 replaced by 300.011742226 ---------------info-closed---------------- particle picked at 3 ================= 61 ==================== 61 Energy decreased! It is accepted! -19.1549554404 61 old speed = 299.891734468 replaced by 299.827854762 Warning! speed changed at 3 : 299.891734468 replaced by 299.827854762 ---------------info-closed---------------- particle picked at 8 ================= 62 ==================== 62 Energy decreased! It is accepted! -22.0943850821 62 old speed = 299.761234898 replaced by 299.687519222 Warning! speed changed at 8 : 299.761234898 replaced by 299.687519222 ---------------info-closed---------------- particle picked at 7 ================= 63 ==================== 63 Energy increased! 23.4692149725 frac = 0.924751046535 b = 0.598788195177 63 You Lucky Warning! speed changed at 7 : 300.011742226 replaced by 300.089959684 ---------------info-closed---------------- particle picked at 3 ================= 64 ==================== 64 Energy decreased! It is accepted! -25.1329730987 64 old speed = 299.827854762 replaced by 299.744018364 Warning! speed changed at 3 : 299.827854762 replaced by 299.744018364 ---------------info-closed---------------- particle picked at 7 ================= 65 ==================== 65 Energy decreased! It is accepted! -5.85495081207 65 old speed = 300.089959684 replaced by 300.070448398 Warning! speed changed at 7 : 300.089959684 replaced by 300.070448398 ---------------info-closed---------------- particle picked at 4 ================= 66 ==================== 66 Energy decreased! It is accepted! -11.9237115371 66 old speed = 299.843177024 replaced by 299.803407894 Warning! speed changed at 4 : 299.843177024 replaced by 299.803407894 ---------------info-closed---------------- particle picked at 3 ================= 67 ==================== 67 Energy increased! 19.6136743676 frac = 0.936712462135 b = 0.325069421187 67 You Lucky Warning! speed changed at 3 : 299.744018364 replaced by 299.809445971 ---------------info-closed---------------- particle picked at 1 ================= 68 ==================== 68 Energy increased! 7.15489674693 frac = 0.976432499664 b = 0.945742642271 68 You Lucky Warning! speed changed at 1 : 299.981055534 replaced by 300.004905748 ---------------info-closed---------------- particle picked at 5 ================= 69 ==================== 69 Energy increased! 6.05425179895 frac = 0.980021430862 b = 0.140633653769 69 You Lucky Warning! speed changed at 5 : 300.066713453 replaced by 300.086889127 ---------------info-closed---------------- particle picked at 4 ================= 70 ==================== 70 Energy increased! 8.52121746445 frac = 0.97199554466 b = 0.731585384514 70 You Lucky Warning! speed changed at 4 : 299.803407894 replaced by 299.831829231 ---------------info-closed---------------- particle picked at 5 ================= 71 ==================== 71 Energy increased! 28.7402147762 frac = 0.908645076525 b = 0.3751527247 71 You Lucky Warning! speed changed at 5 : 300.086889127 replaced by 300.182646826 ---------------info-closed---------------- particle picked at 0 ================= 72 ==================== 72 Energy decreased! It is accepted! -15.5910831236 72 old speed = 299.830668362 replaced by 299.778664224 Warning! speed changed at 0 : 299.830668362 replaced by 299.778664224 ---------------info-closed---------------- particle picked at 4 ================= 73 ==================== 73 Energy decreased! It is accepted! -1.36859774486 73 old speed = 299.831829231 replaced by 299.827264645 Warning! speed changed at 4 : 299.831829231 replaced by 299.827264645 ---------------info-closed---------------- particle picked at 7 ================= 74 ==================== 74 Energy increased! 13.8151893339 frac = 0.954993608577 b = 0.261501372311 74 You Lucky Warning! speed changed at 7 : 300.070448398 replaced by 300.116484686 ---------------info-closed---------------- particle picked at 6 ================= 75 ==================== 75 Energy decreased! It is accepted! -28.8318446459 75 old speed = 300.078805884 replaced by 299.982709588 Warning! speed changed at 6 : 300.078805884 replaced by 299.982709588 ---------------info-closed---------------- particle picked at 3 ================= 76 ==================== 76 Energy increased! 11.3434231571 frac = 0.962894515542 b = 0.106283361727 76 You Lucky Warning! speed changed at 3 : 299.809445971 replaced by 299.847279027 ---------------info-closed---------------- particle picked at 8 ================= 77 ==================== 77 Energy decreased! It is accepted! -2.85497555201 77 old speed = 299.687519222 replaced by 299.677992562 Warning! speed changed at 8 : 299.687519222 replaced by 299.677992562 ---------------info-closed---------------- particle picked at 0 ================= 78 ==================== 78 Energy decreased! It is accepted! -18.3217662101 78 old speed = 299.778664224 replaced by 299.717540347 Warning! speed changed at 0 : 299.778664224 replaced by 299.717540347 ---------------info-closed---------------- particle picked at 8 ================= 79 ==================== 79 Energy decreased! It is accepted! -10.5712767165 79 old speed = 299.677992562 replaced by 299.642715034 Warning! speed changed at 8 : 299.677992562 replaced by 299.642715034 ---------------info-closed---------------- particle picked at 6 ================= 80 ==================== 80 Energy increased! 25.8981647079 frac = 0.917294029106 b = 0.377103705486 80 You Lucky Warning! speed changed at 6 : 299.982709588 replaced by 300.06902936 ---------------info-closed---------------- particle picked at 3 ================= 81 ==================== 81 Energy increased! 3.4098065182 frac = 0.988698327469 b = 0.0312159171229 81 You Lucky Warning! speed changed at 3 : 299.847279027 replaced by 299.858650622 ---------------info-closed---------------- particle picked at 8 ================= 82 ==================== 82 Energy decreased! It is accepted! -18.4628674863 82 old speed = 299.642715034 replaced by 299.581092424 Warning! speed changed at 8 : 299.642715034 replaced by 299.581092424 ---------------info-closed---------------- particle picked at 7 ================= 83 ==================== 83 Energy decreased! It is accepted! -7.46450814405 83 old speed = 300.116484686 replaced by 300.091611619 Warning! speed changed at 7 : 300.116484686 replaced by 300.091611619 ---------------info-closed---------------- particle picked at 4 ================= 84 ==================== 84 Energy increased! 9.49589463838 frac = 0.968842729494 b = 0.108661874014 84 You Lucky Warning! speed changed at 4 : 299.827264645 replaced by 299.85893419 ---------------info-closed---------------- particle picked at 1 ================= 85 ==================== 85 Energy increased! 10.4225579484 frac = 0.965854709981 b = 0.114826465239 85 You Lucky Warning! speed changed at 1 : 300.004905748 replaced by 300.039645028 ---------------info-closed---------------- particle picked at 8 ================= 86 ==================== 86 Energy decreased! It is accepted! -22.7336433515 86 old speed = 299.581092424 replaced by 299.505198037 Warning! speed changed at 8 : 299.581092424 replaced by 299.505198037 ---------------info-closed---------------- particle picked at 0 ================= 87 ==================== 87 Energy increased! 1.00243789502 frac = 0.996664116813 b = 0.41737453119 87 You Lucky Warning! speed changed at 0 : 299.717540347 replaced by 299.720884937 ---------------info-closed---------------- particle picked at 3 ================= 88 ==================== 88 Energy decreased! It is accepted! -3.63974961165 88 old speed = 299.858650622 replaced by 299.846512159 Warning! speed changed at 3 : 299.858650622 replaced by 299.846512159 ---------------info-closed---------------- particle picked at 2 ================= 89 ==================== 89 Energy increased! 5.00314272899 frac = 0.983461151261 b = 0.258379389692 89 You Lucky Warning! speed changed at 2 : 299.764700344 replaced by 299.781390112 ---------------info-closed---------------- particle picked at 5 ================= 90 ==================== 90 Energy increased! 14.0127474497 frac = 0.954364926476 b = 0.54718777645 90 You Lucky Warning! speed changed at 5 : 300.182646826 replaced by 300.229323935 ---------------info-closed---------------- particle picked at 6 ================= 91 ==================== 91 Energy increased! 27.3160839095 frac = 0.912968762564 b = 0.466057239774 91 You Lucky Warning! speed changed at 6 : 300.06902936 replaced by 300.160048222 ---------------info-closed---------------- particle picked at 4 ================= 92 ==================== 92 Energy increased! 9.30101604776 frac = 0.969472289637 b = 0.207884505864 92 You Lucky Warning! speed changed at 4 : 299.85893419 replaced by 299.889950558 ---------------info-closed---------------- particle picked at 7 ================= 93 ==================== 93 Energy decreased! It is accepted! -17.9480064066 93 old speed = 300.091611619 replaced by 300.031797234 Warning! speed changed at 7 : 300.091611619 replaced by 300.031797234 ---------------info-closed---------------- particle picked at 8 ================= 94 ==================== 94 Energy increased! 16.6307891095 frac = 0.946072604722 b = 0.68023491431 94 You Lucky Warning! speed changed at 8 : 299.505198037 replaced by 299.560720438 ---------------info-closed---------------- particle picked at 8 ================= 95 ==================== 95 Energy decreased! It is accepted! -7.31052968793 95 old speed = 299.560720438 replaced by 299.536315277 Warning! speed changed at 8 : 299.560720438 replaced by 299.536315277 ---------------info-closed---------------- particle picked at 6 ================= 96 ==================== 96 Energy decreased! It is accepted! -17.3938902654 96 old speed = 300.160048222 replaced by 300.102093908 Warning! speed changed at 6 : 300.160048222 replaced by 300.102093908 ---------------info-closed---------------- particle picked at 5 ================= 97 ==================== 97 Energy decreased! It is accepted! -15.6593938539 97 old speed = 300.229323935 replaced by 300.177161295 Warning! speed changed at 5 : 300.229323935 replaced by 300.177161295 ---------------info-closed---------------- particle picked at 0 ================= 98 ==================== 98 Energy decreased! It is accepted! -28.3977836631 98 old speed = 299.720884937 replaced by 299.626122526 Warning! speed changed at 0 : 299.720884937 replaced by 299.626122526 ---------------info-closed---------------- particle picked at 1 ================= 99 ==================== 99 Energy decreased! It is accepted! -11.2829622779 99 old speed = 300.039645028 replaced by 300.002037767 Warning! speed changed at 1 : 300.039645028 replaced by 300.002037767 ---------------info-closed---------------- [299.6261225259406, 300.00203776661704, 299.781390112132, 299.8465121588739, 299.8899505582405, 300.1771612945372, 300.10209390845785, 300.03179723356243, 299.5363152772222, 300.0] N = 1000 u = starter( 1 ) T = 300.0 nrun = 100000 H,u = thermalize(u,T,nrun, 0 ) X = np . arange( 0 , len (H), 1 ) plt . figure( 1 ) plt . grid() plt . plot(X,H, \"-\" ) plt . show() Speed Distribution num_bins = 20 plt . figure( 1 ) plt . hist(u,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . grid() plt . show() u [152.53697392059593, 128.31327589246823, 140.436851808329, 132.80382195754856, 132.31407886817632, 135.32050027807352, 130.798459146321, 129.09134596606734, 135.03752198248986, 141.62112963823625, 138.27767642774265, 130.71831125303953, 136.86307540872224, 121.34978066101247, 132.73412663344874, 131.8941976189342, 132.94590280465187, 139.99718986540782, 126.30367606031899, 136.6624201750959, 134.71470758065294, 140.22618602838844, 128.3421710555995, 131.18971363418476, 137.2949504313762, 133.9325213791171, 132.3273444604972, 137.01728024575485, 138.7334279327667, 131.73728297436287, 142.15692647221064, 131.59890748025197, 129.69685418478122, 130.3928982697706, 133.33851141189984, 135.70859014741555, 139.5686898092376, 130.42623900237018, 138.1549314213626, 134.1047535200175, 134.11292649015837, 125.42388153155485, 124.57194118622577, 131.7017625657973, 129.20683563575193, 128.04132499785734, 130.85720902190866, 137.82826258554866, 133.4575684897915, 137.74183777291927, 132.4773493776854, 127.80113465662937, 136.75961609875358, 134.02724421675092, 135.00323622662827, 136.60789546569578, 125.35329383850176, 134.1023584734773, 137.0722197122356, 139.96349822660508, 134.11388102076194, 137.78437853184, 133.1490214372556, 138.3024293767515, 140.2474824710941, 133.1865677976496, 135.21197961798862, 130.68799268977372, 136.86249221917038, 135.78134627417637, 141.35163595663747, 138.62137316754215, 129.49970895942786, 137.80508486126357, 132.7855147828327, 132.69701198534113, 134.293914064531, 138.13570287905537, 133.93454715574518, 132.37891955733335, 136.6798469793762, 133.41276957904762, 137.51371047747227, 133.65857668805802, 123.85131731169427, 129.391466893309, 133.3909979802819, 144.06316076184086, 137.8664370849281, 128.2375880846792, 140.44862493306996, 133.08921447679677, 138.2105296201541, 135.18243128580713, 137.62782519548216, 136.27893012420037, 132.78748369907333, 136.7765860746624, 136.56845749699295, 144.22950291281842, 140.56092223209336, 130.13855757583917, 135.9198500520115, 135.11083426122389, 130.9169846736974, 132.42342214295036, 141.5334395491123, 141.4139275019023, 142.3287926940169, 126.06129381026435, 129.86281170228267, 128.40243941806722, 134.71802868838208, 134.11588977597893, 121.0692404655156, 136.3531498450009, 135.3991625542293, 138.3536916275517, 132.82970264542374, 125.9369676064337, 137.22383820845184, 123.79315137007481, 139.0822701341406, 136.42887013312557, 137.82728430971957, 132.60834897662448, 131.59156460820878, 132.35581654990125, 131.81399407592244, 134.75348804821417, 131.52496126422605, 124.41674508789325, 136.32473006853132, 134.92203448652273, 135.5202955221366, 130.39278453265538, 131.3893923018346, 129.6964667339928, 136.68971488254945, 138.40024191953412, 135.5384850909171, 135.5298128887677, 130.9681136951003, 148.9695749458498, 138.65622193713517, 134.24148627342186, 126.37290362543185, 136.52355980093503, 136.90290057754098, 135.24119406033046, 132.29185836353608, 148.02566201517843, 133.06298190744295, 129.13255682540114, 131.7476042068434, 132.49355253889348, 130.04611959809213, 132.5477545085171, 136.06793582988075, 132.24598855495316, 135.75582977601223, 129.51247977898944, 135.96978529232263, 129.60536083064153, 131.3811236689462, 130.10544346547357, 128.28536316091055, 136.31608248146253, 140.83134461569082, 134.48353554060637, 131.44857800180603, 134.78441830784197, 137.46766557631904, 134.2547355047766, 124.54224922599717, 128.15444120967302, 134.44755078830124, 131.6817151281141, 129.78294904975965, 134.40333466905466, 132.2665437777386, 136.9397146557049, 129.1586611818881, 133.31063584701496, 134.1813839443107, 128.16108159535776, 134.80904811469023, 132.52271445493943, 132.49137181783996, 132.03293517402997, 136.33036793345235, 137.8258309260236, 136.02590968257303, 130.32962196281116, 138.27507751953266, 134.8630654268092, 135.3641605111605, 133.7225134325253, 134.5240770562576, 140.04481268901048, 135.11621234725717, 133.5290903925507, 128.54389187091917, 144.08243649066947, 136.90009437815004, 137.08042161705825, 137.5507514703105, 131.28150300348216, 136.30216027648302, 139.28769630317868, 136.07652355102886, 137.6505286293463, 133.77802944457932, 135.42914314500467, 135.0123386649573, 138.967304479209, 134.93819196421714, 134.58675710133323, 138.37767631589648, 127.1681584812201, 127.47590837784763, 137.7596848891184, 128.80244195115898, 139.8951736929954, 134.7665709079596, 130.3322741583445, 129.6207703397924, 142.44704584370368, 130.69370641481623, 135.6465712262506, 129.8889015341072, 134.81586859771903, 135.29146744985704, 135.79346262431338, 127.17173591468108, 134.29163907549847, 134.31536632578704, 141.0318590152523, 138.98378041149232, 141.2453756707175, 135.33386559928624, 137.77675136889272, 142.90320603089285, 135.15957889767256, 129.58837887024563, 135.01653697822988, 138.1280611822878, 137.81286171542988, 137.87864598257548, 132.36197577637404, 135.34643613220186, 137.08802870786525, 134.25593431017526, 140.0965941012118, 136.1354531498805, 139.60173874031628, 142.1884424795718, 139.4282077859784, 140.4378223480546, 141.14394203276737, 134.80157884536197, 130.2120302488567, 133.12849755223328, 126.76422473110674, 141.29123603504758, 136.94088037629103, 131.21799468909555, 135.5830395095889, 134.42644594991577, 133.00249925370116, 134.1279227141204, 136.68806217714155, 128.3299311767685, 134.42675228077027, 134.33285848249827, 138.2004587361354, 132.5232562517257, 135.5673829013085, 136.06083792562427, 129.92612202158958, 132.2476151140744, 133.35669087064448, 137.79355670155505, 133.07295921064375, 131.30588172460003, 123.54245272298101, 131.8802736088557, 132.02313506622474, 134.01662098974492, 135.01522474996457, 129.88425787636987, 132.2947266708029, 133.26795114295314, 137.76059681837302, 140.43201451383968, 123.77164688119001, 134.5942140729307, 134.72116339724283, 137.81311383298865, 137.1993623203678, 135.50907447438172, 142.12740435659185, 130.61244669277613, 140.92486869278636, 135.79383387159103, 140.1065127468415, 131.53815255562918, 131.83792337563588, 131.8816719901831, 136.42173721657878, 140.72406761890096, 134.32033750845582, 137.4947327261507, 132.73434294925417, 134.33078877573985, 135.18754156573803, 135.45984263053802, 134.95801301354484, 135.81238348494213, 135.16313187223415, 128.4703251407475, 143.37140512194648, 131.86158306606674, 134.5572786880074, 133.37087242546468, 137.26640148054284, 142.62283719898272, 136.00583530393317, 135.95797717688635, 132.23307255718495, 139.16423396514304, 139.586720872186, 138.48591119741064, 132.13429162953187, 132.35678744150167, 135.13584027342685, 134.23846626588394, 133.60934125156294, 134.7053084065632, 132.3265435926093, 123.45189996966262, 127.2278034802087, 135.61574268403476, 134.46353912735393, 131.76295229252878, 129.66632110456493, 138.61806591326965, 139.0747427236818, 139.76970385521398, 138.08322858952988, 133.02807095717716, 133.7435520250619, 136.6894726280003, 136.6906132642527, 135.96647775504152, 134.96130805017208, 128.86350803859952, 138.20995328105911, 132.75597591971103, 128.1030187967407, 133.92147688014128, 139.99771320505448, 134.50698690293018, 141.5260708947022, 138.30126038473236, 136.02280268926395, 135.28569436060246, 133.812855718125, 128.35377565521077, 136.09772285875437, 139.6221924643782, 132.72891940931677, 149.26088055768352, 135.1535249320635, 135.35801387513814, 133.01799074681944, 135.1789223427826, 136.35260863985746, 135.20832113603288, 127.28015976092442, 137.60502507556475, 137.64613697459254, 133.66967706037607, 134.61273621807152, 135.49351896379142, 136.52156651304836, 134.73145852887276, 135.30944870432333, 139.63808492700113, 133.71192114705494, 139.11612120980905, 133.79214122763426, 134.42769640829084, 138.78810924039666, 134.67726714111905, 138.87762281450296, 131.58664890288273, 137.05327558190058, 137.72578098691966, 136.1238780857441, 145.60425617813937, 132.59136655488047, 132.0193316660917, 138.17523714822286, 134.12596127113824, 135.6810878942867, 136.23481785505697, 130.57293332629277, 139.26552496139414, 133.05012761159634, 138.30430798682954, 130.76973919701703, 133.2647569268816, 129.5507260993907, 135.9554997039271, 138.72296600609823, 135.94231573760737, 135.70644832737617, 134.36472190558422, 135.86653274026338, 133.01890766771004, 137.9382308523345, 137.08063503384642, 134.75971187845727, 129.31411100302662, 134.17252422345032, 128.2094946496243, 129.07109253828895, 134.91794062258663, 137.56092791083304, 132.29492870389925, 130.14000700057835, 132.51651052126545, 136.2790516179431, 136.50272101210112, 136.1741515154255, 132.701845362704, 131.9717824588997, 130.39084548290163, 134.37786569373995, 135.207384795766, 136.32233574806068, 137.55294890799684, 138.69534399048058, 132.91921115580956, 139.42983961916036, 132.10866258441933, 133.69674366503395, 135.93632228488926, 133.11573530784213, 137.87668329295954, 127.90822125546222, 139.95069942844862, 137.13674372877313, 132.10734586007482, 136.3366562557506, 126.36645106268543, 136.44704789773868, 133.58588153681066, 142.21144065327843, 138.0216126187682, 136.43053338077772, 129.08886498031882, 137.94402100684164, 134.0986242345506, 134.04216690104582, 131.97259196727916, 131.62913460082572, 135.94756844485983, 146.0363452890946, 141.08202354991903, 133.59468601505586, 141.24537770043773, 134.59247964676948, 130.90842785555276, 130.9341818737866, 134.97696990152417, 140.10822140640084, 132.16409454681624, 129.59062930989103, 144.37125419895654, 130.5305338938841, 122.29125060428512, 133.71501252523436, 140.7257756059714, 136.3771487243562, 134.3728346023143, 135.89419403408516, 126.56064107946888, 126.7055569201038, 133.1100581571064, 127.9019377420104, 131.61183563498415, 134.97315500400757, 138.6006225095034, 130.99937649697316, 133.7808933495595, 137.1000110663378, 134.30507116554404, 139.07835653521346, 133.3048821641821, 129.33088763598394, 128.81445950842405, 135.46168949618203, 132.28842177531052, 139.64734643241727, 129.91695021461098, 134.95353618374318, 138.48190095427648, 138.4464073000754, 139.2243545497303, 135.83248387963826, 140.43057431758695, 139.70201610087162, 143.99876773496104, 134.5517112818767, 130.58582836076675, 132.55640951384086, 132.51149571500767, 138.18900756742835, 129.90350350079663, 131.28916609123715, 119.09618172906454, 134.87741986259348, 141.3300924547582, 136.44719811563618, 136.57937530943985, 136.89511523646578, 132.232280769603, 135.76358290880825, 127.3422527288784, 135.76763204546117, 136.55232574992579, 135.25935653189188, 129.82567877197766, 148.10940410355764, 133.5621911109665, 135.80293919451097, 134.69149129456963, 130.80557884698035, 135.9845339945226, 136.84097383627767, 137.0121833744881, 128.7627074539561, 135.27266668308502, 129.97241367505458, 123.25097450366674, 132.132335473481, 132.16435914163864, 138.8924355857656, 133.71095167849438, 130.786983882348, 133.63377562906052, 140.54959979428756, 135.35662396921924, 129.83140471659883, 136.35227400550676, 140.80191674093572, 135.44648155682827, 131.84993759792755, 127.45452873285572, 130.6494090267367, 137.54004933739256, 136.12622651580145, 130.35841354272776, 138.61194830479093, 130.09354400270394, 132.9725082017072, 135.79235316988203, 136.04165100815985, 132.3912177821114, 136.57065086016613, 136.25342544453633, 147.09413652259497, 135.15813748339852, 132.62234403788665, 126.54208351602689, 129.2881634833256, 131.90390690958142, 131.6772044900074, 139.82288432464549, 135.22246739826755, 144.7236720326942, 133.2314820611611, 139.80402813566158, 140.46665774715814, 135.5152777478594, 129.08123888168393, 127.08335034116315, 136.66117699879172, 135.6049868805449, 136.5127558936456, 135.59391649293232, 134.03881091355532, 137.47365219516752, 138.35800021681243, 143.65624890813626, 134.68326004673685, 133.06841075758751, 142.30644099190602, 131.4594401570824, 131.85477751747524, 142.56129957426273, 138.7959630983813, 143.10861364865252, 123.87920554005159, 138.6397883276342, 130.742076841006, 129.9480712772871, 131.75947350335036, 133.772393227429, 131.44722768782964, 135.27121103023757, 127.9789635253643, 131.24461791228796, 134.6203225176201, 132.64537516114302, 138.48593938688936, 135.64157909922392, 138.62584256618678, 127.57829528785372, 140.77207782875425, 135.67049326074766, 130.51302746912899, 139.63921079329214, 138.82096698456436, 138.7149881412255, 139.05200691827008, 133.07075257342584, 140.02128927847198, 132.009146876271, 133.36998705144472, 135.8685101332248, 136.50190237044026, 128.78609022349968, 139.2086232477592, 138.42519806474127, 131.0421029802369, 131.7301899240713, 133.86971984551573, 133.98796018660522, 135.2278361386512, 132.81553545933303, 144.4818539390617, 140.85583120182608, 138.91166708541965, 126.52349185610174, 130.79825787081808, 141.91571308287908, 132.3621142449252, 135.8333406590108, 136.10394156409484, 126.62055393046606, 137.68523636973745, 139.40642872272326, 137.1955938132474, 126.26463436748084, 128.682704557519, 137.3083508109959, 136.66969280976156, 136.18222099482261, 138.35377095444395, 126.01403324119501, 133.41861489515082, 124.24008484467358, 129.9133922135339, 136.94139213452934, 134.50297042771933, 136.36165826115368, 128.32250494268203, 133.6122617174307, 126.4233881833026, 137.29684552749032, 132.43510120541043, 138.20233274240954, 133.44481578691997, 135.91047597491195, 124.8725338791585, 128.7666433081478, 136.75260193392944, 128.65555108636818, 135.66625538678682, 135.3534115465572, 140.4285873243591, 142.02362850420374, 127.44907521966977, 133.1710886186229, 127.05656702267213, 135.39776952472312, 129.1106421097435, 143.35341181179353, 133.99609288834878, 122.73695610002744, 131.9392289795895, 136.83292648728386, 136.5222960934844, 127.9347699233719, 128.84077769944776, 133.51971450381555, 128.76925639989167, 133.1124818909506, 135.85591690210876, 135.5494470819913, 130.93319856989743, 134.33358854390394, 134.81557975817447, 141.8984588279584, 137.78240416343453, 132.60484687543803, 131.11069066928962, 136.95244311494272, 130.46136481651652, 127.576059620146, 133.03018626872432, 134.97454321557692, 122.00474004515911, 134.62565411984133, 136.60843690485868, 131.34606185658168, 145.52170559488349, 138.15264438341285, 135.38841686995002, 128.19828127618842, 131.54750215546846, 132.42169571081808, 132.216672506366, 133.6267285014799, 136.18516463479892, 129.04417753564803, 134.42205228091404, 130.47786472952825, 131.63750193638214, 137.5078853372789, 131.19410783637133, 136.726005508451, 142.26906482817043, 132.4140459819683, 134.6780724368383, 140.9026593555656, 136.2716667978159, 133.72402948348477, 142.52473971336065, 138.56015341986424, 138.6393740351685, 133.8317011795848, 139.47379808932828, 129.76712407882445, 137.57429047769685, 133.91549600852179, 132.59831137964764, 140.0774966652549, 140.24792037592246, 142.39931788588234, 135.42791041382807, 132.20429529948393, 126.1240998013715, 122.58673249005328, 140.6200618568071, 134.52335901894804, 132.11746565852235, 131.4829637769891, 135.71192529273415, 137.73577138419043, 136.06745243251459, 135.94188967307062, 137.0705324695054, 127.95926562849507, 128.53800160513313, 129.5204139699706, 136.91649528017476, 133.62314102482034, 135.5578338219008, 134.7440233645499, 131.64404615157258, 132.8413023359382, 135.12979954841245, 142.88498879939647, 129.8249403160562, 127.57413444602723, 138.99323645819422, 131.42251098652247, 133.1678659226932, 121.34780328953772, 132.0731922642952, 136.4814119677544, 135.1470337730068, 128.1609340414459, 139.48096068243908, 132.22202294711735, 130.88346378147563, 134.91438980018813, 124.95160076747621, 129.95686806204137, 125.24092338266041, 141.24921675891184, 136.69110703317546, 138.4426495958645, 138.02529812310237, 144.4290683477014, 142.64816993487764, 139.6666041098058, 134.7436578369061, 132.53711996265707, 129.45836076627984, 135.6247964272083, 136.2432388862844, 132.8803470515392, 129.69765762698128, 131.65766059838052, 134.3712776380383, 134.02680438293964, 133.0593264648227, 134.12379352650018, 141.77195996492128, 143.03684219427169, 135.07935209061742, 138.56552345671932, 129.84507448826716, 139.50927233373656, 128.17196304143098, 131.14238275133627, 135.07632506261683, 139.2554178310775, 130.74010031064242, 134.4069025915475, 140.87111900965112, 129.7474078253252, 141.961573549611, 139.29894026980725, 143.57304922565444, 136.20283284048915, 140.0642630237586, 138.506631672365, 131.91731743223545, 139.64848357251833, 134.23959232468198, 121.22823163888397, 132.64977246584672, 136.68114749173984, 124.24114827690136, 138.61737048217586, 130.0481621707483, 135.63689433945547, 126.00574015073514, 134.83253036812346, 129.43028268223654, 131.6241990266879, 137.76201933226952, 129.74427296692062, 125.80961462638201, 137.56547105611102, 129.86973362746556, 137.2221450504167, 136.65763995062312, 134.02767163974195, 129.51278718496343, 132.53089743857478, 136.3201628140543, 138.07173908141291, 130.8896062799746, 133.82164834257108, 127.26686538774285, 128.7883445565501, 136.10179413809414, 134.70771962647686, 133.82435832373363, 131.926469651889, 137.1471960826258, 128.36167057133247, 128.15782125483435, 132.33610285493296, 127.54824468026587, 132.41821757812815, 133.42535621858923, 137.22332364668097, 133.53472835350084, 132.88948747457127, 141.38261665100654, 142.56083087850277, 133.03707505104884, 138.88945502293382, 136.38844562925914, 130.10999449897258, 131.9650025110834, 135.23322210790886, 131.98389812045386, 135.9139471757918, 134.54519477088226, 126.6993147197969, 136.92459178600026, 137.17803969456529, 135.41073403580162, 129.9760242083077, 138.61300847447205, 128.66607268254268, 132.1904498891318, 139.78661951448282, 140.54322711702991, 129.23142189318983, 138.5925755146701, 132.1259293331799, 127.96860412786656, 138.9539699486678, 135.30540579180905, 131.61952312395914, 139.22083687168143, 139.47602449675333, 131.8288186956396, 124.98771581383022, 132.76499590070603, 137.79644683542494, 131.19603526916657, 138.2220096824923, 136.56602740791925, 132.92945651678858, 129.8032059773272, 132.90892446026314, 133.44975958286886, 147.12964475662844, 135.28832370148143, 128.29681515611753, 136.94365161478743, 133.85947665590612, 132.95765273152506, 136.3117414895533, 142.73791099118037, 136.5539538621281, 142.15949627988806, 128.51364073882368, 139.3255026837532, 135.11896652005424, 129.90587655877752, 140.48919339691835, 143.64650740064062, 125.57661602798161, 138.54827523506043, 133.57262826679033, 135.8072798157492, 131.7949550971851, 138.17541236891623, 128.89633244238175, 133.50895389489378, 137.6482622773241, 134.6158288087855, 132.47156530217765, 140.69051079260004, 127.6390049365225, 133.39382295627462, 131.1813122581282, 132.45531958100878, 131.86122739110212, 131.98676084633132, 133.37991200883638, 132.47773021858737, 130.65677071682242, 144.23197137149924, 133.3774913981006, 139.1242024252893, 132.70071794705865, 136.4388701517642, 138.04656320236992, 133.74679922863655, 130.95176347328996, 135.10749785283392, 139.4869875937905, 128.28988293775492, 134.5363787667753, 131.57759175379007, 132.83614704519172, 135.87460525926997, 131.7232994260579, 136.49986648732792, 134.6858011279651, 144.70926166589473, 138.70280942618507, 143.0822918419198, 135.79676379821595, 132.80751503036083, 134.1319434390563, 131.85736309074193, 144.95459059607194, 137.964712079434, 132.6777881048469, 139.02576238193302, 136.10311864487892, 138.68620481499175, 139.55575077449538, 135.3024692862837, 137.44788386642696, 128.27720377971596, 131.1040120447158, 132.20448198384403, 138.35691216711282, 143.85787558668204, 131.7681242767676, 129.59330646579016, 133.39138736963753, 137.28959101804156, 134.5713370387848, 150.0] num_bins = 100 plt . figure( 1 ) plt . hist(u,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . grid() plt . show()","title":"Ideal Gas"},{"location":"Montecarlo/IdealGas/IdealGas/#maxwells-distribution-of-speed","text":"","title":"Maxwell's distribution of speed."},{"location":"Montecarlo/IdealGas/IdealGas/#import","text":"import math as math import random as random import numpy as np import matplotlib.pyplot as plt","title":"Import"},{"location":"Montecarlo/IdealGas/IdealGas/#global-constants","text":"m = 3.2 # mass is in unit of Kb Kb = 1.0","title":"Global constants"},{"location":"Montecarlo/IdealGas/IdealGas/#input-parameters","text":"N = 100 u0 = 150.00 dv = 1.0","title":"Input parameters"},{"location":"Montecarlo/IdealGas/IdealGas/#starter","text":"def starter (key): u = [ 0.0 for k in range (N)] if key == 0 : return u else : for k in range (N): u[k] = u0 return u","title":"Starter"},{"location":"Montecarlo/IdealGas/IdealGas/#hamiltonian","text":"def hamiltonian (u): H = 0.0 for k in range (N): H = H + 0.5 * u[k] ** 2 return H","title":"Hamiltonian"},{"location":"Montecarlo/IdealGas/IdealGas/#pick-a-particle-and-change","text":"def pick_random_particle (printkey): n = random . randint( 0 , N - 1 ) if printkey == 1 : print \"particle picked at\" ,n return n","title":"Pick a particle and change"},{"location":"Montecarlo/IdealGas/IdealGas/#thermalization","text":"def thermalize (u,T,nruns,printkey): irun = 0 h_stor = [ 0.0 for k in range (nrun)] while irun < nrun: L = len (u) h_old = hamiltonian(u) n = pick_random_particle(printkey) ov = u[n] du = random . uniform( - dv,dv) u[n] = u[n] + du h_new = hamiltonian(u) dh = 0.5 * m * (u[n] ** 2 - ov ** 2 ) if printkey == 1 : print \"=================\" , irun, \"====================\" if dh < 0 : if printkey == 1 : print irun, \"Energy decreased! It is accepted!\" ,dh if printkey == 1 : print irun, \"old speed = \" , ov, \"replaced by\" ,u[n] h_stor[irun] = h_new else : if printkey == 1 : print irun, \"Energy increased!\" ,dh frac = math . exp( - dh / (Kb * T)) b = random . uniform( 0.0 , 1.0 ) if printkey == 1 : print \"frac =\" ,frac, \"b =\" ,b if b < frac: if printkey == 1 : print irun, \"You Lucky\" h_stor[irun] = h_new else : if printkey == 1 : print irun, \"Loser\" if printkey == 1 : print \"speed restablished at\" , n, \":\" ,u[n], \"by\" ,u[n] - du, \"which is old\" ,ov u[n] = u[n] - du h_stor[irun] = h_old if u[n] != ov : if printkey == 1 : print \"Warning! speed changed at\" ,n, \":\" , ov, \" replaced by\" , u[n] if printkey == 1 : print \"---------------info-closed----------------\" if printkey == 1 : print \"\" if printkey == 2 : print irun, h_stor[irun] irun = irun + 1 return h_stor,u","title":"Thermalization"},{"location":"Montecarlo/IdealGas/IdealGas/#simulation","text":"","title":"Simulation"},{"location":"Montecarlo/IdealGas/IdealGas/#test","text":"N = 10 u = starter( 1 ) T = 300.0 nrun = 100 H,u = thermalize(u,T,nrun, 1 ) particle picked at 2 ================= 0 ==================== 0 Energy increased! 5.16166800614 frac = 0.982941610369 b = 0.296378524508 0 You Lucky Warning! speed changed at 2 : 300.0 replaced by 300.017205067 ---------------info-closed---------------- particle picked at 0 ================= 1 ==================== 1 Energy increased! 23.3951734115 frac = 0.924979308072 b = 0.607024790315 1 You Lucky Warning! speed changed at 0 : 300.0 replaced by 300.077973778 ---------------info-closed---------------- particle picked at 8 ================= 2 ==================== 2 Energy decreased! It is accepted! -28.9376550483 2 old speed = 300.0 replaced by 299.903525638 Warning! speed changed at 8 : 300.0 replaced by 299.903525638 ---------------info-closed---------------- particle picked at 0 ================= 3 ==================== 3 Energy increased! 17.437958518 frac = 0.943530556478 b = 0.639751221503 3 You Lucky Warning! speed changed at 0 : 300.077973778 replaced by 300.136079577 ---------------info-closed---------------- particle picked at 6 ================= 4 ==================== 4 Energy decreased! It is accepted! -4.76002312716 4 old speed = 300.0 replaced by 299.984132837 Warning! speed changed at 6 : 300.0 replaced by 299.984132837 ---------------info-closed---------------- particle picked at 4 ================= 5 ==================== 5 Energy decreased! It is accepted! -23.0744788723 5 old speed = 300.0 replaced by 299.923075208 Warning! speed changed at 4 : 300.0 replaced by 299.923075208 ---------------info-closed---------------- particle picked at 4 ================= 6 ==================== 6 Energy decreased! It is accepted! -25.1873042255 6 old speed = 299.923075208 replaced by 299.839084233 Warning! speed changed at 4 : 299.923075208 replaced by 299.839084233 ---------------info-closed---------------- particle picked at 8 ================= 7 ==================== 7 Energy decreased! It is accepted! -23.5188848983 7 old speed = 299.903525638 replaced by 299.82509388 Warning! speed changed at 8 : 299.903525638 replaced by 299.82509388 ---------------info-closed---------------- particle picked at 4 ================= 8 ==================== 8 Energy increased! 3.66195450823 frac = 0.987867682273 b = 0.901236906352 8 You Lucky Warning! speed changed at 4 : 299.839084233 replaced by 299.85129705 ---------------info-closed---------------- particle picked at 0 ================= 9 ==================== 9 Energy decreased! It is accepted! -9.42665565287 9 old speed = 300.136079577 replaced by 300.104669995 Warning! speed changed at 0 : 300.136079577 replaced by 300.104669995 ---------------info-closed---------------- particle picked at 4 ================= 10 ==================== 10 Energy decreased! It is accepted! -1.94555000914 10 old speed = 299.85129705 replaced by 299.844808597 Warning! speed changed at 4 : 299.85129705 replaced by 299.844808597 ---------------info-closed---------------- particle picked at 2 ================= 11 ==================== 11 Energy decreased! It is accepted! -27.8179773732 11 old speed = 300.017205067 replaced by 299.924469461 Warning! speed changed at 2 : 300.017205067 replaced by 299.924469461 ---------------info-closed---------------- particle picked at 7 ================= 12 ==================== 12 Energy decreased! It is accepted! -15.7483746502 12 old speed = 300.0 replaced by 299.947500824 Warning! speed changed at 7 : 300.0 replaced by 299.947500824 ---------------info-closed---------------- particle picked at 7 ================= 13 ==================== 13 Energy increased! 16.6569944456 frac = 0.945989967829 b = 0.855436607854 13 You Lucky Warning! speed changed at 7 : 299.947500824 replaced by 300.003028717 ---------------info-closed---------------- particle picked at 5 ================= 14 ==================== 14 Energy increased! 13.5605829688 frac = 0.955804444106 b = 0.462274377115 14 You Lucky Warning! speed changed at 5 : 300.0 replaced by 300.045198538 ---------------info-closed---------------- particle picked at 2 ================= 15 ==================== 15 Energy decreased! It is accepted! -10.1659196052 15 old speed = 299.924469461 replaced by 299.890572613 Warning! speed changed at 2 : 299.924469461 replaced by 299.890572613 ---------------info-closed---------------- particle picked at 2 ================= 16 ==================== 16 Energy increased! 13.1461147765 frac = 0.957125858504 b = 0.0764044163788 16 You Lucky Warning! speed changed at 2 : 299.890572613 replaced by 299.934405782 ---------------info-closed---------------- particle picked at 6 ================= 17 ==================== 17 Energy increased! 16.0662962599 frac = 0.947854451331 b = 0.311728441504 17 You Lucky Warning! speed changed at 6 : 299.984132837 replaced by 300.03768521 ---------------info-closed---------------- particle picked at 0 ================= 18 ==================== 18 Energy increased! 14.9157901932 frac = 0.951496471466 b = 0.778044719102 18 You Lucky Warning! speed changed at 0 : 300.104669995 replaced by 300.154367839 ---------------info-closed---------------- particle picked at 5 ================= 19 ==================== 19 Energy increased! 0.212891347102 frac = 0.99929061391 b = 0.600347076825 19 You Lucky Warning! speed changed at 5 : 300.045198538 replaced by 300.045908068 ---------------info-closed---------------- particle picked at 7 ================= 20 ==================== 20 Energy increased! 5.6356927141 frac = 0.981389708059 b = 0.962471313504 20 You Lucky Warning! speed changed at 7 : 300.003028717 replaced by 300.021813582 ---------------info-closed---------------- particle picked at 8 ================= 21 ==================== 21 Energy decreased! It is accepted! -0.361216020458 21 old speed = 299.82509388 replaced by 299.823889122 Warning! speed changed at 8 : 299.82509388 replaced by 299.823889122 ---------------info-closed---------------- particle picked at 8 ================= 22 ==================== 22 Energy increased! 9.18340368766 frac = 0.969852437229 b = 0.910312616567 22 You Lucky Warning! speed changed at 8 : 299.823889122 replaced by 299.854516884 ---------------info-closed---------------- particle picked at 2 ================= 23 ==================== 23 Energy decreased! It is accepted! -15.3415660895 23 old speed = 299.934405782 replaced by 299.883251682 Warning! speed changed at 2 : 299.934405782 replaced by 299.883251682 ---------------info-closed---------------- particle picked at 3 ================= 24 ==================== 24 Energy decreased! It is accepted! -29.9420272373 24 old speed = 300.0 replaced by 299.900176635 Warning! speed changed at 3 : 300.0 replaced by 299.900176635 ---------------info-closed---------------- particle picked at 1 ================= 25 ==================== 25 Energy increased! 3.67190862696 frac = 0.987834904977 b = 0.85142877576 25 You Lucky Warning! speed changed at 1 : 300.0 replaced by 300.012239446 ---------------info-closed---------------- particle picked at 0 ================= 26 ==================== 26 Energy decreased! It is accepted! -28.9294825618 26 old speed = 300.154367839 replaced by 300.057970345 Warning! speed changed at 0 : 300.154367839 replaced by 300.057970345 ---------------info-closed---------------- particle picked at 0 ================= 27 ==================== 27 Energy decreased! It is accepted! -17.5218772821 27 old speed = 300.057970345 replaced by 299.999569688 Warning! speed changed at 0 : 300.057970345 replaced by 299.999569688 ---------------info-closed---------------- particle picked at 1 ================= 28 ==================== 28 Energy increased! 10.987743112 frac = 0.964036800437 b = 0.354706880466 28 You Lucky Warning! speed changed at 1 : 300.012239446 replaced by 300.048861527 ---------------info-closed---------------- particle picked at 2 ================= 29 ==================== 29 Energy decreased! It is accepted! -23.0555321212 29 old speed = 299.883251682 replaced by 299.806360131 Warning! speed changed at 2 : 299.883251682 replaced by 299.806360131 ---------------info-closed---------------- particle picked at 0 ================= 30 ==================== 30 Energy increased! 14.56813825 frac = 0.95259974259 b = 0.992217091382 30 Loser speed restablished at 0 : 300.048126289 by 299.999569688 which is old 299.999569688 ---------------info-closed---------------- particle picked at 4 ================= 31 ==================== 31 Energy decreased! It is accepted! -19.1459640601 31 old speed = 299.844808597 replaced by 299.780948885 Warning! speed changed at 4 : 299.844808597 replaced by 299.780948885 ---------------info-closed---------------- particle picked at 2 ================= 32 ==================== 32 Energy increased! 10.3893583094 frac = 0.965961602654 b = 0.0652759977248 32 You Lucky Warning! speed changed at 2 : 299.806360131 replaced by 299.841011691 ---------------info-closed---------------- particle picked at 5 ================= 33 ==================== 33 Energy increased! 27.6413736072 frac = 0.911979367951 b = 0.925790017225 33 Loser speed restablished at 5 : 300.138017745 by 300.045908068 which is old 300.045908068 ---------------info-closed---------------- particle picked at 3 ================= 34 ==================== 34 Energy increased! 6.48585504453 frac = 0.978612509829 b = 0.639748903698 34 You Lucky Warning! speed changed at 3 : 299.900176635 replaced by 299.921802568 ---------------info-closed---------------- particle picked at 5 ================= 35 ==================== 35 Energy decreased! It is accepted! -26.3949101618 35 old speed = 300.045908068 replaced by 299.957925597 Warning! speed changed at 5 : 300.045908068 replaced by 299.957925597 ---------------info-closed---------------- particle picked at 5 ================= 36 ==================== 36 Energy increased! 13.992910126 frac = 0.954428035382 b = 0.00198934609112 36 You Lucky Warning! speed changed at 5 : 299.957925597 replaced by 300.004571546 ---------------info-closed---------------- particle picked at 5 ================= 37 ==================== 37 Energy decreased! It is accepted! -18.5791926362 37 old speed = 300.004571546 replaced by 299.942635454 Warning! speed changed at 5 : 300.004571546 replaced by 299.942635454 ---------------info-closed---------------- particle picked at 5 ================= 38 ==================== 38 Energy increased! 19.0993831631 frac = 0.93831964928 b = 0.684421660523 38 You Lucky Warning! speed changed at 5 : 299.942635454 replaced by 300.006305483 ---------------info-closed---------------- particle picked at 3 ================= 39 ==================== 39 Energy increased! 12.6217197065 frac = 0.958800361851 b = 0.978536469383 39 Loser speed restablished at 3 : 299.963882984 by 299.921802568 which is old 299.921802568 ---------------info-closed---------------- particle picked at 0 ================= 40 ==================== 40 Energy decreased! It is accepted! -24.2180688647 40 old speed = 299.999569688 replaced by 299.918831812 Warning! speed changed at 0 : 299.999569688 replaced by 299.918831812 ---------------info-closed---------------- particle picked at 3 ================= 41 ==================== 41 Energy decreased! It is accepted! -4.27460233111 41 old speed = 299.921802568 replaced by 299.90754984 Warning! speed changed at 3 : 299.921802568 replaced by 299.90754984 ---------------info-closed---------------- particle picked at 3 ================= 42 ==================== 42 Energy increased! 10.8331681318 frac = 0.964533648324 b = 0.980522343152 42 Loser speed restablished at 3 : 299.943669357 by 299.90754984 which is old 299.90754984 ---------------info-closed---------------- particle picked at 2 ================= 43 ==================== 43 Energy decreased! It is accepted! -0.620556065638 43 old speed = 299.841011691 replaced by 299.838942067 Warning! speed changed at 2 : 299.841011691 replaced by 299.838942067 ---------------info-closed---------------- particle picked at 3 ================= 44 ==================== 44 Energy increased! 21.5404667892 frac = 0.930715572441 b = 0.255181673312 44 You Lucky Warning! speed changed at 3 : 299.90754984 replaced by 299.979364931 ---------------info-closed---------------- particle picked at 4 ================= 45 ==================== 45 Energy increased! 6.331827505 frac = 0.979115083092 b = 0.535424245741 45 You Lucky Warning! speed changed at 4 : 299.780948885 replaced by 299.802069655 ---------------info-closed---------------- particle picked at 4 ================= 46 ==================== 46 Energy increased! 9.67196917396 frac = 0.968274267884 b = 0.448130433025 46 You Lucky Warning! speed changed at 4 : 299.802069655 replaced by 299.834329102 ---------------info-closed---------------- particle picked at 1 ================= 47 ==================== 47 Energy decreased! It is accepted! -22.1880505342 47 old speed = 300.048861527 replaced by 299.974904288 Warning! speed changed at 1 : 300.048861527 replaced by 299.974904288 ---------------info-closed---------------- particle picked at 0 ================= 48 ==================== 48 Energy decreased! It is accepted! -26.4379926945 48 old speed = 299.918831812 replaced by 299.830668362 Warning! speed changed at 0 : 299.918831812 replaced by 299.830668362 ---------------info-closed---------------- particle picked at 5 ================= 49 ==================== 49 Energy decreased! It is accepted! -17.6255352389 49 old speed = 300.006305483 replaced by 299.94754918 Warning! speed changed at 5 : 300.006305483 replaced by 299.94754918 ---------------info-closed---------------- particle picked at 5 ================= 50 ==================== 50 Energy increased! 26.9557187349 frac = 0.914066095325 b = 0.216679528733 50 You Lucky Warning! speed changed at 5 : 299.94754918 replaced by 300.037403829 ---------------info-closed---------------- particle picked at 8 ================= 51 ==================== 51 Energy decreased! It is accepted! -27.966674026 51 old speed = 299.854516884 replaced by 299.761234898 Warning! speed changed at 8 : 299.854516884 replaced by 299.761234898 ---------------info-closed---------------- particle picked at 2 ================= 52 ==================== 52 Energy decreased! It is accepted! -22.2578037851 52 old speed = 299.838942067 replaced by 299.764700344 Warning! speed changed at 2 : 299.838942067 replaced by 299.764700344 ---------------info-closed---------------- particle picked at 1 ================= 53 ==================== 53 Energy increased! 1.8452384392 frac = 0.993868082617 b = 0.932817295881 53 You Lucky Warning! speed changed at 1 : 299.974904288 replaced by 299.981055534 ---------------info-closed---------------- particle picked at 6 ================= 54 ==================== 54 Energy increased! 12.3385972816 frac = 0.959705648574 b = 0.262262734931 54 You Lucky Warning! speed changed at 6 : 300.03768521 replaced by 300.078805884 ---------------info-closed---------------- particle picked at 4 ================= 55 ==================== 55 Energy increased! 17.1512405735 frac = 0.944432744672 b = 0.868938895111 55 You Lucky Warning! speed changed at 4 : 299.834329102 replaced by 299.891526038 ---------------info-closed---------------- particle picked at 5 ================= 56 ==================== 56 Energy decreased! It is accepted! -1.43622642083 56 old speed = 300.037403829 replaced by 300.032616966 Warning! speed changed at 5 : 300.037403829 replaced by 300.032616966 ---------------info-closed---------------- particle picked at 3 ================= 57 ==================== 57 Energy decreased! It is accepted! -26.2834912367 57 old speed = 299.979364931 replaced by 299.891734468 Warning! speed changed at 3 : 299.979364931 replaced by 299.891734468 ---------------info-closed---------------- particle picked at 5 ================= 58 ==================== 58 Energy increased! 10.2306393701 frac = 0.966472792538 b = 0.0967580124621 58 You Lucky Warning! speed changed at 5 : 300.032616966 replaced by 300.066713453 ---------------info-closed---------------- particle picked at 4 ================= 59 ==================== 59 Energy decreased! It is accepted! -14.4982905504 59 old speed = 299.891526038 replaced by 299.843177024 Warning! speed changed at 4 : 299.891526038 replaced by 299.843177024 ---------------info-closed---------------- particle picked at 7 ================= 60 ==================== 60 Energy decreased! It is accepted! -3.0215758524 60 old speed = 300.021813582 replaced by 300.011742226 Warning! speed changed at 7 : 300.021813582 replaced by 300.011742226 ---------------info-closed---------------- particle picked at 3 ================= 61 ==================== 61 Energy decreased! It is accepted! -19.1549554404 61 old speed = 299.891734468 replaced by 299.827854762 Warning! speed changed at 3 : 299.891734468 replaced by 299.827854762 ---------------info-closed---------------- particle picked at 8 ================= 62 ==================== 62 Energy decreased! It is accepted! -22.0943850821 62 old speed = 299.761234898 replaced by 299.687519222 Warning! speed changed at 8 : 299.761234898 replaced by 299.687519222 ---------------info-closed---------------- particle picked at 7 ================= 63 ==================== 63 Energy increased! 23.4692149725 frac = 0.924751046535 b = 0.598788195177 63 You Lucky Warning! speed changed at 7 : 300.011742226 replaced by 300.089959684 ---------------info-closed---------------- particle picked at 3 ================= 64 ==================== 64 Energy decreased! It is accepted! -25.1329730987 64 old speed = 299.827854762 replaced by 299.744018364 Warning! speed changed at 3 : 299.827854762 replaced by 299.744018364 ---------------info-closed---------------- particle picked at 7 ================= 65 ==================== 65 Energy decreased! It is accepted! -5.85495081207 65 old speed = 300.089959684 replaced by 300.070448398 Warning! speed changed at 7 : 300.089959684 replaced by 300.070448398 ---------------info-closed---------------- particle picked at 4 ================= 66 ==================== 66 Energy decreased! It is accepted! -11.9237115371 66 old speed = 299.843177024 replaced by 299.803407894 Warning! speed changed at 4 : 299.843177024 replaced by 299.803407894 ---------------info-closed---------------- particle picked at 3 ================= 67 ==================== 67 Energy increased! 19.6136743676 frac = 0.936712462135 b = 0.325069421187 67 You Lucky Warning! speed changed at 3 : 299.744018364 replaced by 299.809445971 ---------------info-closed---------------- particle picked at 1 ================= 68 ==================== 68 Energy increased! 7.15489674693 frac = 0.976432499664 b = 0.945742642271 68 You Lucky Warning! speed changed at 1 : 299.981055534 replaced by 300.004905748 ---------------info-closed---------------- particle picked at 5 ================= 69 ==================== 69 Energy increased! 6.05425179895 frac = 0.980021430862 b = 0.140633653769 69 You Lucky Warning! speed changed at 5 : 300.066713453 replaced by 300.086889127 ---------------info-closed---------------- particle picked at 4 ================= 70 ==================== 70 Energy increased! 8.52121746445 frac = 0.97199554466 b = 0.731585384514 70 You Lucky Warning! speed changed at 4 : 299.803407894 replaced by 299.831829231 ---------------info-closed---------------- particle picked at 5 ================= 71 ==================== 71 Energy increased! 28.7402147762 frac = 0.908645076525 b = 0.3751527247 71 You Lucky Warning! speed changed at 5 : 300.086889127 replaced by 300.182646826 ---------------info-closed---------------- particle picked at 0 ================= 72 ==================== 72 Energy decreased! It is accepted! -15.5910831236 72 old speed = 299.830668362 replaced by 299.778664224 Warning! speed changed at 0 : 299.830668362 replaced by 299.778664224 ---------------info-closed---------------- particle picked at 4 ================= 73 ==================== 73 Energy decreased! It is accepted! -1.36859774486 73 old speed = 299.831829231 replaced by 299.827264645 Warning! speed changed at 4 : 299.831829231 replaced by 299.827264645 ---------------info-closed---------------- particle picked at 7 ================= 74 ==================== 74 Energy increased! 13.8151893339 frac = 0.954993608577 b = 0.261501372311 74 You Lucky Warning! speed changed at 7 : 300.070448398 replaced by 300.116484686 ---------------info-closed---------------- particle picked at 6 ================= 75 ==================== 75 Energy decreased! It is accepted! -28.8318446459 75 old speed = 300.078805884 replaced by 299.982709588 Warning! speed changed at 6 : 300.078805884 replaced by 299.982709588 ---------------info-closed---------------- particle picked at 3 ================= 76 ==================== 76 Energy increased! 11.3434231571 frac = 0.962894515542 b = 0.106283361727 76 You Lucky Warning! speed changed at 3 : 299.809445971 replaced by 299.847279027 ---------------info-closed---------------- particle picked at 8 ================= 77 ==================== 77 Energy decreased! It is accepted! -2.85497555201 77 old speed = 299.687519222 replaced by 299.677992562 Warning! speed changed at 8 : 299.687519222 replaced by 299.677992562 ---------------info-closed---------------- particle picked at 0 ================= 78 ==================== 78 Energy decreased! It is accepted! -18.3217662101 78 old speed = 299.778664224 replaced by 299.717540347 Warning! speed changed at 0 : 299.778664224 replaced by 299.717540347 ---------------info-closed---------------- particle picked at 8 ================= 79 ==================== 79 Energy decreased! It is accepted! -10.5712767165 79 old speed = 299.677992562 replaced by 299.642715034 Warning! speed changed at 8 : 299.677992562 replaced by 299.642715034 ---------------info-closed---------------- particle picked at 6 ================= 80 ==================== 80 Energy increased! 25.8981647079 frac = 0.917294029106 b = 0.377103705486 80 You Lucky Warning! speed changed at 6 : 299.982709588 replaced by 300.06902936 ---------------info-closed---------------- particle picked at 3 ================= 81 ==================== 81 Energy increased! 3.4098065182 frac = 0.988698327469 b = 0.0312159171229 81 You Lucky Warning! speed changed at 3 : 299.847279027 replaced by 299.858650622 ---------------info-closed---------------- particle picked at 8 ================= 82 ==================== 82 Energy decreased! It is accepted! -18.4628674863 82 old speed = 299.642715034 replaced by 299.581092424 Warning! speed changed at 8 : 299.642715034 replaced by 299.581092424 ---------------info-closed---------------- particle picked at 7 ================= 83 ==================== 83 Energy decreased! It is accepted! -7.46450814405 83 old speed = 300.116484686 replaced by 300.091611619 Warning! speed changed at 7 : 300.116484686 replaced by 300.091611619 ---------------info-closed---------------- particle picked at 4 ================= 84 ==================== 84 Energy increased! 9.49589463838 frac = 0.968842729494 b = 0.108661874014 84 You Lucky Warning! speed changed at 4 : 299.827264645 replaced by 299.85893419 ---------------info-closed---------------- particle picked at 1 ================= 85 ==================== 85 Energy increased! 10.4225579484 frac = 0.965854709981 b = 0.114826465239 85 You Lucky Warning! speed changed at 1 : 300.004905748 replaced by 300.039645028 ---------------info-closed---------------- particle picked at 8 ================= 86 ==================== 86 Energy decreased! It is accepted! -22.7336433515 86 old speed = 299.581092424 replaced by 299.505198037 Warning! speed changed at 8 : 299.581092424 replaced by 299.505198037 ---------------info-closed---------------- particle picked at 0 ================= 87 ==================== 87 Energy increased! 1.00243789502 frac = 0.996664116813 b = 0.41737453119 87 You Lucky Warning! speed changed at 0 : 299.717540347 replaced by 299.720884937 ---------------info-closed---------------- particle picked at 3 ================= 88 ==================== 88 Energy decreased! It is accepted! -3.63974961165 88 old speed = 299.858650622 replaced by 299.846512159 Warning! speed changed at 3 : 299.858650622 replaced by 299.846512159 ---------------info-closed---------------- particle picked at 2 ================= 89 ==================== 89 Energy increased! 5.00314272899 frac = 0.983461151261 b = 0.258379389692 89 You Lucky Warning! speed changed at 2 : 299.764700344 replaced by 299.781390112 ---------------info-closed---------------- particle picked at 5 ================= 90 ==================== 90 Energy increased! 14.0127474497 frac = 0.954364926476 b = 0.54718777645 90 You Lucky Warning! speed changed at 5 : 300.182646826 replaced by 300.229323935 ---------------info-closed---------------- particle picked at 6 ================= 91 ==================== 91 Energy increased! 27.3160839095 frac = 0.912968762564 b = 0.466057239774 91 You Lucky Warning! speed changed at 6 : 300.06902936 replaced by 300.160048222 ---------------info-closed---------------- particle picked at 4 ================= 92 ==================== 92 Energy increased! 9.30101604776 frac = 0.969472289637 b = 0.207884505864 92 You Lucky Warning! speed changed at 4 : 299.85893419 replaced by 299.889950558 ---------------info-closed---------------- particle picked at 7 ================= 93 ==================== 93 Energy decreased! It is accepted! -17.9480064066 93 old speed = 300.091611619 replaced by 300.031797234 Warning! speed changed at 7 : 300.091611619 replaced by 300.031797234 ---------------info-closed---------------- particle picked at 8 ================= 94 ==================== 94 Energy increased! 16.6307891095 frac = 0.946072604722 b = 0.68023491431 94 You Lucky Warning! speed changed at 8 : 299.505198037 replaced by 299.560720438 ---------------info-closed---------------- particle picked at 8 ================= 95 ==================== 95 Energy decreased! It is accepted! -7.31052968793 95 old speed = 299.560720438 replaced by 299.536315277 Warning! speed changed at 8 : 299.560720438 replaced by 299.536315277 ---------------info-closed---------------- particle picked at 6 ================= 96 ==================== 96 Energy decreased! It is accepted! -17.3938902654 96 old speed = 300.160048222 replaced by 300.102093908 Warning! speed changed at 6 : 300.160048222 replaced by 300.102093908 ---------------info-closed---------------- particle picked at 5 ================= 97 ==================== 97 Energy decreased! It is accepted! -15.6593938539 97 old speed = 300.229323935 replaced by 300.177161295 Warning! speed changed at 5 : 300.229323935 replaced by 300.177161295 ---------------info-closed---------------- particle picked at 0 ================= 98 ==================== 98 Energy decreased! It is accepted! -28.3977836631 98 old speed = 299.720884937 replaced by 299.626122526 Warning! speed changed at 0 : 299.720884937 replaced by 299.626122526 ---------------info-closed---------------- particle picked at 1 ================= 99 ==================== 99 Energy decreased! It is accepted! -11.2829622779 99 old speed = 300.039645028 replaced by 300.002037767 Warning! speed changed at 1 : 300.039645028 replaced by 300.002037767 ---------------info-closed---------------- [299.6261225259406, 300.00203776661704, 299.781390112132, 299.8465121588739, 299.8899505582405, 300.1771612945372, 300.10209390845785, 300.03179723356243, 299.5363152772222, 300.0] N = 1000 u = starter( 1 ) T = 300.0 nrun = 100000 H,u = thermalize(u,T,nrun, 0 ) X = np . arange( 0 , len (H), 1 ) plt . figure( 1 ) plt . grid() plt . plot(X,H, \"-\" ) plt . show()","title":"Test"},{"location":"Montecarlo/IdealGas/IdealGas/#speed-distribution","text":"num_bins = 20 plt . figure( 1 ) plt . hist(u,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . grid() plt . show() u [152.53697392059593, 128.31327589246823, 140.436851808329, 132.80382195754856, 132.31407886817632, 135.32050027807352, 130.798459146321, 129.09134596606734, 135.03752198248986, 141.62112963823625, 138.27767642774265, 130.71831125303953, 136.86307540872224, 121.34978066101247, 132.73412663344874, 131.8941976189342, 132.94590280465187, 139.99718986540782, 126.30367606031899, 136.6624201750959, 134.71470758065294, 140.22618602838844, 128.3421710555995, 131.18971363418476, 137.2949504313762, 133.9325213791171, 132.3273444604972, 137.01728024575485, 138.7334279327667, 131.73728297436287, 142.15692647221064, 131.59890748025197, 129.69685418478122, 130.3928982697706, 133.33851141189984, 135.70859014741555, 139.5686898092376, 130.42623900237018, 138.1549314213626, 134.1047535200175, 134.11292649015837, 125.42388153155485, 124.57194118622577, 131.7017625657973, 129.20683563575193, 128.04132499785734, 130.85720902190866, 137.82826258554866, 133.4575684897915, 137.74183777291927, 132.4773493776854, 127.80113465662937, 136.75961609875358, 134.02724421675092, 135.00323622662827, 136.60789546569578, 125.35329383850176, 134.1023584734773, 137.0722197122356, 139.96349822660508, 134.11388102076194, 137.78437853184, 133.1490214372556, 138.3024293767515, 140.2474824710941, 133.1865677976496, 135.21197961798862, 130.68799268977372, 136.86249221917038, 135.78134627417637, 141.35163595663747, 138.62137316754215, 129.49970895942786, 137.80508486126357, 132.7855147828327, 132.69701198534113, 134.293914064531, 138.13570287905537, 133.93454715574518, 132.37891955733335, 136.6798469793762, 133.41276957904762, 137.51371047747227, 133.65857668805802, 123.85131731169427, 129.391466893309, 133.3909979802819, 144.06316076184086, 137.8664370849281, 128.2375880846792, 140.44862493306996, 133.08921447679677, 138.2105296201541, 135.18243128580713, 137.62782519548216, 136.27893012420037, 132.78748369907333, 136.7765860746624, 136.56845749699295, 144.22950291281842, 140.56092223209336, 130.13855757583917, 135.9198500520115, 135.11083426122389, 130.9169846736974, 132.42342214295036, 141.5334395491123, 141.4139275019023, 142.3287926940169, 126.06129381026435, 129.86281170228267, 128.40243941806722, 134.71802868838208, 134.11588977597893, 121.0692404655156, 136.3531498450009, 135.3991625542293, 138.3536916275517, 132.82970264542374, 125.9369676064337, 137.22383820845184, 123.79315137007481, 139.0822701341406, 136.42887013312557, 137.82728430971957, 132.60834897662448, 131.59156460820878, 132.35581654990125, 131.81399407592244, 134.75348804821417, 131.52496126422605, 124.41674508789325, 136.32473006853132, 134.92203448652273, 135.5202955221366, 130.39278453265538, 131.3893923018346, 129.6964667339928, 136.68971488254945, 138.40024191953412, 135.5384850909171, 135.5298128887677, 130.9681136951003, 148.9695749458498, 138.65622193713517, 134.24148627342186, 126.37290362543185, 136.52355980093503, 136.90290057754098, 135.24119406033046, 132.29185836353608, 148.02566201517843, 133.06298190744295, 129.13255682540114, 131.7476042068434, 132.49355253889348, 130.04611959809213, 132.5477545085171, 136.06793582988075, 132.24598855495316, 135.75582977601223, 129.51247977898944, 135.96978529232263, 129.60536083064153, 131.3811236689462, 130.10544346547357, 128.28536316091055, 136.31608248146253, 140.83134461569082, 134.48353554060637, 131.44857800180603, 134.78441830784197, 137.46766557631904, 134.2547355047766, 124.54224922599717, 128.15444120967302, 134.44755078830124, 131.6817151281141, 129.78294904975965, 134.40333466905466, 132.2665437777386, 136.9397146557049, 129.1586611818881, 133.31063584701496, 134.1813839443107, 128.16108159535776, 134.80904811469023, 132.52271445493943, 132.49137181783996, 132.03293517402997, 136.33036793345235, 137.8258309260236, 136.02590968257303, 130.32962196281116, 138.27507751953266, 134.8630654268092, 135.3641605111605, 133.7225134325253, 134.5240770562576, 140.04481268901048, 135.11621234725717, 133.5290903925507, 128.54389187091917, 144.08243649066947, 136.90009437815004, 137.08042161705825, 137.5507514703105, 131.28150300348216, 136.30216027648302, 139.28769630317868, 136.07652355102886, 137.6505286293463, 133.77802944457932, 135.42914314500467, 135.0123386649573, 138.967304479209, 134.93819196421714, 134.58675710133323, 138.37767631589648, 127.1681584812201, 127.47590837784763, 137.7596848891184, 128.80244195115898, 139.8951736929954, 134.7665709079596, 130.3322741583445, 129.6207703397924, 142.44704584370368, 130.69370641481623, 135.6465712262506, 129.8889015341072, 134.81586859771903, 135.29146744985704, 135.79346262431338, 127.17173591468108, 134.29163907549847, 134.31536632578704, 141.0318590152523, 138.98378041149232, 141.2453756707175, 135.33386559928624, 137.77675136889272, 142.90320603089285, 135.15957889767256, 129.58837887024563, 135.01653697822988, 138.1280611822878, 137.81286171542988, 137.87864598257548, 132.36197577637404, 135.34643613220186, 137.08802870786525, 134.25593431017526, 140.0965941012118, 136.1354531498805, 139.60173874031628, 142.1884424795718, 139.4282077859784, 140.4378223480546, 141.14394203276737, 134.80157884536197, 130.2120302488567, 133.12849755223328, 126.76422473110674, 141.29123603504758, 136.94088037629103, 131.21799468909555, 135.5830395095889, 134.42644594991577, 133.00249925370116, 134.1279227141204, 136.68806217714155, 128.3299311767685, 134.42675228077027, 134.33285848249827, 138.2004587361354, 132.5232562517257, 135.5673829013085, 136.06083792562427, 129.92612202158958, 132.2476151140744, 133.35669087064448, 137.79355670155505, 133.07295921064375, 131.30588172460003, 123.54245272298101, 131.8802736088557, 132.02313506622474, 134.01662098974492, 135.01522474996457, 129.88425787636987, 132.2947266708029, 133.26795114295314, 137.76059681837302, 140.43201451383968, 123.77164688119001, 134.5942140729307, 134.72116339724283, 137.81311383298865, 137.1993623203678, 135.50907447438172, 142.12740435659185, 130.61244669277613, 140.92486869278636, 135.79383387159103, 140.1065127468415, 131.53815255562918, 131.83792337563588, 131.8816719901831, 136.42173721657878, 140.72406761890096, 134.32033750845582, 137.4947327261507, 132.73434294925417, 134.33078877573985, 135.18754156573803, 135.45984263053802, 134.95801301354484, 135.81238348494213, 135.16313187223415, 128.4703251407475, 143.37140512194648, 131.86158306606674, 134.5572786880074, 133.37087242546468, 137.26640148054284, 142.62283719898272, 136.00583530393317, 135.95797717688635, 132.23307255718495, 139.16423396514304, 139.586720872186, 138.48591119741064, 132.13429162953187, 132.35678744150167, 135.13584027342685, 134.23846626588394, 133.60934125156294, 134.7053084065632, 132.3265435926093, 123.45189996966262, 127.2278034802087, 135.61574268403476, 134.46353912735393, 131.76295229252878, 129.66632110456493, 138.61806591326965, 139.0747427236818, 139.76970385521398, 138.08322858952988, 133.02807095717716, 133.7435520250619, 136.6894726280003, 136.6906132642527, 135.96647775504152, 134.96130805017208, 128.86350803859952, 138.20995328105911, 132.75597591971103, 128.1030187967407, 133.92147688014128, 139.99771320505448, 134.50698690293018, 141.5260708947022, 138.30126038473236, 136.02280268926395, 135.28569436060246, 133.812855718125, 128.35377565521077, 136.09772285875437, 139.6221924643782, 132.72891940931677, 149.26088055768352, 135.1535249320635, 135.35801387513814, 133.01799074681944, 135.1789223427826, 136.35260863985746, 135.20832113603288, 127.28015976092442, 137.60502507556475, 137.64613697459254, 133.66967706037607, 134.61273621807152, 135.49351896379142, 136.52156651304836, 134.73145852887276, 135.30944870432333, 139.63808492700113, 133.71192114705494, 139.11612120980905, 133.79214122763426, 134.42769640829084, 138.78810924039666, 134.67726714111905, 138.87762281450296, 131.58664890288273, 137.05327558190058, 137.72578098691966, 136.1238780857441, 145.60425617813937, 132.59136655488047, 132.0193316660917, 138.17523714822286, 134.12596127113824, 135.6810878942867, 136.23481785505697, 130.57293332629277, 139.26552496139414, 133.05012761159634, 138.30430798682954, 130.76973919701703, 133.2647569268816, 129.5507260993907, 135.9554997039271, 138.72296600609823, 135.94231573760737, 135.70644832737617, 134.36472190558422, 135.86653274026338, 133.01890766771004, 137.9382308523345, 137.08063503384642, 134.75971187845727, 129.31411100302662, 134.17252422345032, 128.2094946496243, 129.07109253828895, 134.91794062258663, 137.56092791083304, 132.29492870389925, 130.14000700057835, 132.51651052126545, 136.2790516179431, 136.50272101210112, 136.1741515154255, 132.701845362704, 131.9717824588997, 130.39084548290163, 134.37786569373995, 135.207384795766, 136.32233574806068, 137.55294890799684, 138.69534399048058, 132.91921115580956, 139.42983961916036, 132.10866258441933, 133.69674366503395, 135.93632228488926, 133.11573530784213, 137.87668329295954, 127.90822125546222, 139.95069942844862, 137.13674372877313, 132.10734586007482, 136.3366562557506, 126.36645106268543, 136.44704789773868, 133.58588153681066, 142.21144065327843, 138.0216126187682, 136.43053338077772, 129.08886498031882, 137.94402100684164, 134.0986242345506, 134.04216690104582, 131.97259196727916, 131.62913460082572, 135.94756844485983, 146.0363452890946, 141.08202354991903, 133.59468601505586, 141.24537770043773, 134.59247964676948, 130.90842785555276, 130.9341818737866, 134.97696990152417, 140.10822140640084, 132.16409454681624, 129.59062930989103, 144.37125419895654, 130.5305338938841, 122.29125060428512, 133.71501252523436, 140.7257756059714, 136.3771487243562, 134.3728346023143, 135.89419403408516, 126.56064107946888, 126.7055569201038, 133.1100581571064, 127.9019377420104, 131.61183563498415, 134.97315500400757, 138.6006225095034, 130.99937649697316, 133.7808933495595, 137.1000110663378, 134.30507116554404, 139.07835653521346, 133.3048821641821, 129.33088763598394, 128.81445950842405, 135.46168949618203, 132.28842177531052, 139.64734643241727, 129.91695021461098, 134.95353618374318, 138.48190095427648, 138.4464073000754, 139.2243545497303, 135.83248387963826, 140.43057431758695, 139.70201610087162, 143.99876773496104, 134.5517112818767, 130.58582836076675, 132.55640951384086, 132.51149571500767, 138.18900756742835, 129.90350350079663, 131.28916609123715, 119.09618172906454, 134.87741986259348, 141.3300924547582, 136.44719811563618, 136.57937530943985, 136.89511523646578, 132.232280769603, 135.76358290880825, 127.3422527288784, 135.76763204546117, 136.55232574992579, 135.25935653189188, 129.82567877197766, 148.10940410355764, 133.5621911109665, 135.80293919451097, 134.69149129456963, 130.80557884698035, 135.9845339945226, 136.84097383627767, 137.0121833744881, 128.7627074539561, 135.27266668308502, 129.97241367505458, 123.25097450366674, 132.132335473481, 132.16435914163864, 138.8924355857656, 133.71095167849438, 130.786983882348, 133.63377562906052, 140.54959979428756, 135.35662396921924, 129.83140471659883, 136.35227400550676, 140.80191674093572, 135.44648155682827, 131.84993759792755, 127.45452873285572, 130.6494090267367, 137.54004933739256, 136.12622651580145, 130.35841354272776, 138.61194830479093, 130.09354400270394, 132.9725082017072, 135.79235316988203, 136.04165100815985, 132.3912177821114, 136.57065086016613, 136.25342544453633, 147.09413652259497, 135.15813748339852, 132.62234403788665, 126.54208351602689, 129.2881634833256, 131.90390690958142, 131.6772044900074, 139.82288432464549, 135.22246739826755, 144.7236720326942, 133.2314820611611, 139.80402813566158, 140.46665774715814, 135.5152777478594, 129.08123888168393, 127.08335034116315, 136.66117699879172, 135.6049868805449, 136.5127558936456, 135.59391649293232, 134.03881091355532, 137.47365219516752, 138.35800021681243, 143.65624890813626, 134.68326004673685, 133.06841075758751, 142.30644099190602, 131.4594401570824, 131.85477751747524, 142.56129957426273, 138.7959630983813, 143.10861364865252, 123.87920554005159, 138.6397883276342, 130.742076841006, 129.9480712772871, 131.75947350335036, 133.772393227429, 131.44722768782964, 135.27121103023757, 127.9789635253643, 131.24461791228796, 134.6203225176201, 132.64537516114302, 138.48593938688936, 135.64157909922392, 138.62584256618678, 127.57829528785372, 140.77207782875425, 135.67049326074766, 130.51302746912899, 139.63921079329214, 138.82096698456436, 138.7149881412255, 139.05200691827008, 133.07075257342584, 140.02128927847198, 132.009146876271, 133.36998705144472, 135.8685101332248, 136.50190237044026, 128.78609022349968, 139.2086232477592, 138.42519806474127, 131.0421029802369, 131.7301899240713, 133.86971984551573, 133.98796018660522, 135.2278361386512, 132.81553545933303, 144.4818539390617, 140.85583120182608, 138.91166708541965, 126.52349185610174, 130.79825787081808, 141.91571308287908, 132.3621142449252, 135.8333406590108, 136.10394156409484, 126.62055393046606, 137.68523636973745, 139.40642872272326, 137.1955938132474, 126.26463436748084, 128.682704557519, 137.3083508109959, 136.66969280976156, 136.18222099482261, 138.35377095444395, 126.01403324119501, 133.41861489515082, 124.24008484467358, 129.9133922135339, 136.94139213452934, 134.50297042771933, 136.36165826115368, 128.32250494268203, 133.6122617174307, 126.4233881833026, 137.29684552749032, 132.43510120541043, 138.20233274240954, 133.44481578691997, 135.91047597491195, 124.8725338791585, 128.7666433081478, 136.75260193392944, 128.65555108636818, 135.66625538678682, 135.3534115465572, 140.4285873243591, 142.02362850420374, 127.44907521966977, 133.1710886186229, 127.05656702267213, 135.39776952472312, 129.1106421097435, 143.35341181179353, 133.99609288834878, 122.73695610002744, 131.9392289795895, 136.83292648728386, 136.5222960934844, 127.9347699233719, 128.84077769944776, 133.51971450381555, 128.76925639989167, 133.1124818909506, 135.85591690210876, 135.5494470819913, 130.93319856989743, 134.33358854390394, 134.81557975817447, 141.8984588279584, 137.78240416343453, 132.60484687543803, 131.11069066928962, 136.95244311494272, 130.46136481651652, 127.576059620146, 133.03018626872432, 134.97454321557692, 122.00474004515911, 134.62565411984133, 136.60843690485868, 131.34606185658168, 145.52170559488349, 138.15264438341285, 135.38841686995002, 128.19828127618842, 131.54750215546846, 132.42169571081808, 132.216672506366, 133.6267285014799, 136.18516463479892, 129.04417753564803, 134.42205228091404, 130.47786472952825, 131.63750193638214, 137.5078853372789, 131.19410783637133, 136.726005508451, 142.26906482817043, 132.4140459819683, 134.6780724368383, 140.9026593555656, 136.2716667978159, 133.72402948348477, 142.52473971336065, 138.56015341986424, 138.6393740351685, 133.8317011795848, 139.47379808932828, 129.76712407882445, 137.57429047769685, 133.91549600852179, 132.59831137964764, 140.0774966652549, 140.24792037592246, 142.39931788588234, 135.42791041382807, 132.20429529948393, 126.1240998013715, 122.58673249005328, 140.6200618568071, 134.52335901894804, 132.11746565852235, 131.4829637769891, 135.71192529273415, 137.73577138419043, 136.06745243251459, 135.94188967307062, 137.0705324695054, 127.95926562849507, 128.53800160513313, 129.5204139699706, 136.91649528017476, 133.62314102482034, 135.5578338219008, 134.7440233645499, 131.64404615157258, 132.8413023359382, 135.12979954841245, 142.88498879939647, 129.8249403160562, 127.57413444602723, 138.99323645819422, 131.42251098652247, 133.1678659226932, 121.34780328953772, 132.0731922642952, 136.4814119677544, 135.1470337730068, 128.1609340414459, 139.48096068243908, 132.22202294711735, 130.88346378147563, 134.91438980018813, 124.95160076747621, 129.95686806204137, 125.24092338266041, 141.24921675891184, 136.69110703317546, 138.4426495958645, 138.02529812310237, 144.4290683477014, 142.64816993487764, 139.6666041098058, 134.7436578369061, 132.53711996265707, 129.45836076627984, 135.6247964272083, 136.2432388862844, 132.8803470515392, 129.69765762698128, 131.65766059838052, 134.3712776380383, 134.02680438293964, 133.0593264648227, 134.12379352650018, 141.77195996492128, 143.03684219427169, 135.07935209061742, 138.56552345671932, 129.84507448826716, 139.50927233373656, 128.17196304143098, 131.14238275133627, 135.07632506261683, 139.2554178310775, 130.74010031064242, 134.4069025915475, 140.87111900965112, 129.7474078253252, 141.961573549611, 139.29894026980725, 143.57304922565444, 136.20283284048915, 140.0642630237586, 138.506631672365, 131.91731743223545, 139.64848357251833, 134.23959232468198, 121.22823163888397, 132.64977246584672, 136.68114749173984, 124.24114827690136, 138.61737048217586, 130.0481621707483, 135.63689433945547, 126.00574015073514, 134.83253036812346, 129.43028268223654, 131.6241990266879, 137.76201933226952, 129.74427296692062, 125.80961462638201, 137.56547105611102, 129.86973362746556, 137.2221450504167, 136.65763995062312, 134.02767163974195, 129.51278718496343, 132.53089743857478, 136.3201628140543, 138.07173908141291, 130.8896062799746, 133.82164834257108, 127.26686538774285, 128.7883445565501, 136.10179413809414, 134.70771962647686, 133.82435832373363, 131.926469651889, 137.1471960826258, 128.36167057133247, 128.15782125483435, 132.33610285493296, 127.54824468026587, 132.41821757812815, 133.42535621858923, 137.22332364668097, 133.53472835350084, 132.88948747457127, 141.38261665100654, 142.56083087850277, 133.03707505104884, 138.88945502293382, 136.38844562925914, 130.10999449897258, 131.9650025110834, 135.23322210790886, 131.98389812045386, 135.9139471757918, 134.54519477088226, 126.6993147197969, 136.92459178600026, 137.17803969456529, 135.41073403580162, 129.9760242083077, 138.61300847447205, 128.66607268254268, 132.1904498891318, 139.78661951448282, 140.54322711702991, 129.23142189318983, 138.5925755146701, 132.1259293331799, 127.96860412786656, 138.9539699486678, 135.30540579180905, 131.61952312395914, 139.22083687168143, 139.47602449675333, 131.8288186956396, 124.98771581383022, 132.76499590070603, 137.79644683542494, 131.19603526916657, 138.2220096824923, 136.56602740791925, 132.92945651678858, 129.8032059773272, 132.90892446026314, 133.44975958286886, 147.12964475662844, 135.28832370148143, 128.29681515611753, 136.94365161478743, 133.85947665590612, 132.95765273152506, 136.3117414895533, 142.73791099118037, 136.5539538621281, 142.15949627988806, 128.51364073882368, 139.3255026837532, 135.11896652005424, 129.90587655877752, 140.48919339691835, 143.64650740064062, 125.57661602798161, 138.54827523506043, 133.57262826679033, 135.8072798157492, 131.7949550971851, 138.17541236891623, 128.89633244238175, 133.50895389489378, 137.6482622773241, 134.6158288087855, 132.47156530217765, 140.69051079260004, 127.6390049365225, 133.39382295627462, 131.1813122581282, 132.45531958100878, 131.86122739110212, 131.98676084633132, 133.37991200883638, 132.47773021858737, 130.65677071682242, 144.23197137149924, 133.3774913981006, 139.1242024252893, 132.70071794705865, 136.4388701517642, 138.04656320236992, 133.74679922863655, 130.95176347328996, 135.10749785283392, 139.4869875937905, 128.28988293775492, 134.5363787667753, 131.57759175379007, 132.83614704519172, 135.87460525926997, 131.7232994260579, 136.49986648732792, 134.6858011279651, 144.70926166589473, 138.70280942618507, 143.0822918419198, 135.79676379821595, 132.80751503036083, 134.1319434390563, 131.85736309074193, 144.95459059607194, 137.964712079434, 132.6777881048469, 139.02576238193302, 136.10311864487892, 138.68620481499175, 139.55575077449538, 135.3024692862837, 137.44788386642696, 128.27720377971596, 131.1040120447158, 132.20448198384403, 138.35691216711282, 143.85787558668204, 131.7681242767676, 129.59330646579016, 133.39138736963753, 137.28959101804156, 134.5713370387848, 150.0] num_bins = 100 plt . figure( 1 ) plt . hist(u,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . grid() plt . show()","title":"Speed Distribution"},{"location":"Montecarlo/IzingModel/Izing2D/","text":"Ising Model - 2D using Importance Sampling First of all we import the required libraries: Date - Oct -9-2015 import matplotlib.pyplot as plt import math as math import random as random import pylab as pylab import numpy as np Global parameters Then we set some global variables: Kb = 1.0 JJ = 1.0 Cold Start and Hot Start Before begining simulation, if we select all spin up or all spin down then it is called cold configuration. def cold_start(L): U = [[1.0 for k in range(L)]for l in range(L)] return U We can make a plot of this cold configuration by the help of Uplotter : CU = cold_start(10) Uplotter(CU) if we select spin randomly up or down then it is called cold configuration def hot_start(L): U = [[0.0 for i in range(L)]for j in range(L)] for i in range(L): for j in range(L): t = random.sample([-1,1],1) U[i][j] = t[0] return U Similarly we can plot thishot configuration as well. HU = hot_start(10) Uplotter(HU) Hamiltonian Hamiltonian of L by L lattice is given by $$H = - J \\sum_{i\\neq j} S_{i}S_{j}$$ def Hamiltonian(U): H = 0.0 L = len(U) for i in range(L): for j in range(L): ni = 0;nj =0; if i == 0: ni = L if j == 0: nj = L H = H - 0.5*JJ*U[i][j]*(U[i][(j-1)+nj] \\ + U[(i+1)%L][j] \\ + U[i][(j+1)%L] \\ + U[(i-1)+ni][j]) return H One can check what are hamiltonian for hot and cold start: Hamiltonian(CU) -200.0 Hamiltonian(HU) 12.0 Mangnetization One can calculate magnetization by simply taking average over all spins: def magnetization(U): m = 0.0 L = len(U) for i in range(L): for j in range(L): m = m + U[i][j] m = m/float(L*L) return m magnetization(HU) 0.02 magnetization(CU) 1.0 Spin Flipper def ld(k,L): if k == 0: return L else: return 0 def spin_flipper(U,printkey): L = len(U) i = random.randint(0, L-1) j = random.randint(0, L-1) if printkey ==1:print \"flipped at\", i,j U[i][j] = -U[i][j] dH = -2.0*JJ*U[i][j]*(U[i][(j-1)+ld(j,L)] \\ + U[(i+1)%L][j] \\ + U[i][(j+1)%L] \\ + U[(i-1)+ld(i,L)][j]) return U,dH,i,j Thermalization def Thermalization(U,T,nrun,printkey) : M = [0.0 for k in range(nrun)] irun = 0 while irun < nrun: V = U w = magnetization(U) U,dH,p,q = spin_flipper(U,printkey) if dH < 0: if printkey ==1: print irun, \"E decreased! You are accepted !\",dH M[irun] = magnetization(U) else: if printkey ==1:print irun, \"E increased!\",dH frac = math.exp(-dH/(Kb*T)) b = random.uniform(0.0,1.0) if printkey ==1:print \"frac =\",frac,\"b=\",b,\"dH = \",dH if b < frac: if printkey ==1:print irun, \" You Lucky!\" M[irun] = magnetization(U) else: if printkey ==1: print irun, \"Loser!\" if printkey ==1: print \"spin restablished at\",p,q U[p][q] = -U[p][q] M[irun] = w for i in range(L): for j in range(L): if U[i][j] != V[i][i]: if printkey ==1: print\"Warning!spin is changed!\", i,j if printkey ==2 : print irun, M[irun] irun = irun +1 return M,U Lets print out some measurements of m nrun = 100 T = 1.0 L = 10 U = cold_start(L) M,U = Thermalization(U,T,nrun, 1) flipped at 2 6 0 E increased! 8.0 frac = 0.000335462627903 b= 0.200945442416 dH = 8.0 0 Loser! spin restablished at 2 6 flipped at 5 3 1 E increased! 8.0 frac = 0.000335462627903 b= 0.208228177318 dH = 8.0 1 Loser! spin restablished at 5 3 flipped at 3 9 2 E increased! 8.0 frac = 0.000335462627903 b= 0.518140057869 dH = 8.0 2 Loser! spin restablished at 3 9 flipped at 7 2 3 E increased! 8.0 frac = 0.000335462627903 b= 0.453525585218 dH = 8.0 3 Loser! spin restablished at 7 2 flipped at 4 2 4 E increased! 8.0 frac = 0.000335462627903 b= 0.301315970059 dH = 8.0 4 Loser! spin restablished at 4 2 flipped at 1 1 5 E increased! 8.0 frac = 0.000335462627903 b= 0.559871016385 dH = 8.0 5 Loser! spin restablished at 1 1 flipped at 3 7 6 E increased! 8.0 frac = 0.000335462627903 b= 0.364710311714 dH = 8.0 6 Loser! spin restablished at 3 7 flipped at 4 9 7 E increased! 8.0 frac = 0.000335462627903 b= 0.589989052706 dH = 8.0 7 Loser! spin restablished at 4 9 flipped at 5 7 8 E increased! 8.0 frac = 0.000335462627903 b= 0.00373832879324 dH = 8.0 8 Loser! spin restablished at 5 7 flipped at 7 8 9 E increased! 8.0 frac = 0.000335462627903 b= 0.667080358921 dH = 8.0 9 Loser! spin restablished at 7 8 flipped at 2 8 10 E increased! 8.0 frac = 0.000335462627903 b= 0.958643303676 dH = 8.0 10 Loser! spin restablished at 2 8 flipped at 2 0 11 E increased! 8.0 frac = 0.000335462627903 b= 0.117960949982 dH = 8.0 11 Loser! spin restablished at 2 0 flipped at 1 7 12 E increased! 8.0 frac = 0.000335462627903 b= 0.128279159058 dH = 8.0 12 Loser! spin restablished at 1 7 flipped at 1 6 13 E increased! 8.0 frac = 0.000335462627903 b= 0.41237756183 dH = 8.0 13 Loser! spin restablished at 1 6 flipped at 3 4 14 E increased! 8.0 frac = 0.000335462627903 b= 0.208921911192 dH = 8.0 14 Loser! spin restablished at 3 4 flipped at 5 4 15 E increased! 8.0 frac = 0.000335462627903 b= 0.121113318063 dH = 8.0 15 Loser! spin restablished at 5 4 flipped at 2 1 16 E increased! 8.0 frac = 0.000335462627903 b= 0.91059155363 dH = 8.0 16 Loser! spin restablished at 2 1 flipped at 2 2 17 E increased! 8.0 frac = 0.000335462627903 b= 0.0312121693169 dH = 8.0 17 Loser! spin restablished at 2 2 flipped at 7 5 18 E increased! 8.0 frac = 0.000335462627903 b= 0.44423543869 dH = 8.0 18 Loser! spin restablished at 7 5 flipped at 9 8 19 E increased! 8.0 frac = 0.000335462627903 b= 0.838164630904 dH = 8.0 19 Loser! spin restablished at 9 8 flipped at 4 4 20 E increased! 8.0 frac = 0.000335462627903 b= 0.978984488947 dH = 8.0 20 Loser! spin restablished at 4 4 flipped at 9 1 21 E increased! 8.0 frac = 0.000335462627903 b= 0.660100062089 dH = 8.0 21 Loser! spin restablished at 9 1 flipped at 0 9 22 E increased! 8.0 frac = 0.000335462627903 b= 0.384350846156 dH = 8.0 22 Loser! spin restablished at 0 9 flipped at 8 3 23 E increased! 8.0 frac = 0.000335462627903 b= 0.147521237768 dH = 8.0 23 Loser! spin restablished at 8 3 flipped at 1 2 24 E increased! 8.0 frac = 0.000335462627903 b= 0.245418005023 dH = 8.0 24 Loser! spin restablished at 1 2 flipped at 7 4 25 E increased! 8.0 frac = 0.000335462627903 b= 0.566226070388 dH = 8.0 25 Loser! spin restablished at 7 4 flipped at 8 6 26 E increased! 8.0 frac = 0.000335462627903 b= 0.470824511812 dH = 8.0 26 Loser! spin restablished at 8 6 flipped at 9 1 27 E increased! 8.0 frac = 0.000335462627903 b= 0.468902208133 dH = 8.0 27 Loser! spin restablished at 9 1 flipped at 3 3 28 E increased! 8.0 frac = 0.000335462627903 b= 0.956164659389 dH = 8.0 28 Loser! spin restablished at 3 3 flipped at 7 5 29 E increased! 8.0 frac = 0.000335462627903 b= 0.427388520837 dH = 8.0 29 Loser! spin restablished at 7 5 flipped at 9 2 30 E increased! 8.0 frac = 0.000335462627903 b= 0.043987391181 dH = 8.0 30 Loser! spin restablished at 9 2 flipped at 7 8 31 E increased! 8.0 frac = 0.000335462627903 b= 0.666327053159 dH = 8.0 31 Loser! spin restablished at 7 8 flipped at 7 0 32 E increased! 8.0 frac = 0.000335462627903 b= 0.515433733306 dH = 8.0 32 Loser! spin restablished at 7 0 flipped at 2 8 33 E increased! 8.0 frac = 0.000335462627903 b= 0.167613150653 dH = 8.0 33 Loser! spin restablished at 2 8 flipped at 0 3 34 E increased! 8.0 frac = 0.000335462627903 b= 0.345178826725 dH = 8.0 34 Loser! spin restablished at 0 3 flipped at 0 1 35 E increased! 8.0 frac = 0.000335462627903 b= 0.513958539065 dH = 8.0 35 Loser! spin restablished at 0 1 flipped at 6 8 36 E increased! 8.0 frac = 0.000335462627903 b= 0.4871901386 dH = 8.0 36 Loser! spin restablished at 6 8 flipped at 7 2 37 E increased! 8.0 frac = 0.000335462627903 b= 0.59898662047 dH = 8.0 37 Loser! spin restablished at 7 2 flipped at 4 9 38 E increased! 8.0 frac = 0.000335462627903 b= 0.0847937443966 dH = 8.0 38 Loser! spin restablished at 4 9 flipped at 5 6 39 E increased! 8.0 frac = 0.000335462627903 b= 0.098801882584 dH = 8.0 39 Loser! spin restablished at 5 6 flipped at 2 4 40 E increased! 8.0 frac = 0.000335462627903 b= 0.653577770213 dH = 8.0 40 Loser! spin restablished at 2 4 flipped at 7 3 41 E increased! 8.0 frac = 0.000335462627903 b= 0.302675497483 dH = 8.0 41 Loser! spin restablished at 7 3 flipped at 2 6 42 E increased! 8.0 frac = 0.000335462627903 b= 0.46557731556 dH = 8.0 42 Loser! spin restablished at 2 6 flipped at 1 0 43 E increased! 8.0 frac = 0.000335462627903 b= 0.0854198113429 dH = 8.0 43 Loser! spin restablished at 1 0 flipped at 1 9 44 E increased! 8.0 frac = 0.000335462627903 b= 0.666489537978 dH = 8.0 44 Loser! spin restablished at 1 9 flipped at 5 0 45 E increased! 8.0 frac = 0.000335462627903 b= 0.214381681158 dH = 8.0 45 Loser! spin restablished at 5 0 flipped at 0 1 46 E increased! 8.0 frac = 0.000335462627903 b= 0.947652883231 dH = 8.0 46 Loser! spin restablished at 0 1 flipped at 2 7 47 E increased! 8.0 frac = 0.000335462627903 b= 0.224155338588 dH = 8.0 47 Loser! spin restablished at 2 7 flipped at 1 1 48 E increased! 8.0 frac = 0.000335462627903 b= 0.922718106128 dH = 8.0 48 Loser! spin restablished at 1 1 flipped at 3 0 49 E increased! 8.0 frac = 0.000335462627903 b= 0.226445418861 dH = 8.0 49 Loser! spin restablished at 3 0 flipped at 6 6 50 E increased! 8.0 frac = 0.000335462627903 b= 0.859615061628 dH = 8.0 50 Loser! spin restablished at 6 6 flipped at 4 6 51 E increased! 8.0 frac = 0.000335462627903 b= 0.104605351213 dH = 8.0 51 Loser! spin restablished at 4 6 flipped at 9 8 52 E increased! 8.0 frac = 0.000335462627903 b= 0.762546438422 dH = 8.0 52 Loser! spin restablished at 9 8 flipped at 5 6 53 E increased! 8.0 frac = 0.000335462627903 b= 0.37637421483 dH = 8.0 53 Loser! spin restablished at 5 6 flipped at 0 4 54 E increased! 8.0 frac = 0.000335462627903 b= 0.22018392926 dH = 8.0 54 Loser! spin restablished at 0 4 flipped at 6 3 55 E increased! 8.0 frac = 0.000335462627903 b= 0.559080327422 dH = 8.0 55 Loser! spin restablished at 6 3 flipped at 0 4 56 E increased! 8.0 frac = 0.000335462627903 b= 0.067818661091 dH = 8.0 56 Loser! spin restablished at 0 4 flipped at 0 1 57 E increased! 8.0 frac = 0.000335462627903 b= 0.592962993336 dH = 8.0 57 Loser! spin restablished at 0 1 flipped at 7 5 58 E increased! 8.0 frac = 0.000335462627903 b= 0.359231837157 dH = 8.0 58 Loser! spin restablished at 7 5 flipped at 9 7 59 E increased! 8.0 frac = 0.000335462627903 b= 0.365371314382 dH = 8.0 59 Loser! spin restablished at 9 7 flipped at 1 4 60 E increased! 8.0 frac = 0.000335462627903 b= 0.0238130043524 dH = 8.0 60 Loser! spin restablished at 1 4 flipped at 1 2 61 E increased! 8.0 frac = 0.000335462627903 b= 0.171939714452 dH = 8.0 61 Loser! spin restablished at 1 2 flipped at 1 4 62 E increased! 8.0 frac = 0.000335462627903 b= 0.798151394609 dH = 8.0 62 Loser! spin restablished at 1 4 flipped at 5 9 63 E increased! 8.0 frac = 0.000335462627903 b= 0.521864864986 dH = 8.0 63 Loser! spin restablished at 5 9 flipped at 4 8 64 E increased! 8.0 frac = 0.000335462627903 b= 0.039200037808 dH = 8.0 64 Loser! spin restablished at 4 8 flipped at 9 3 65 E increased! 8.0 frac = 0.000335462627903 b= 0.907378398139 dH = 8.0 65 Loser! spin restablished at 9 3 flipped at 3 9 66 E increased! 8.0 frac = 0.000335462627903 b= 0.786255454713 dH = 8.0 66 Loser! spin restablished at 3 9 flipped at 1 8 67 E increased! 8.0 frac = 0.000335462627903 b= 0.151408860995 dH = 8.0 67 Loser! spin restablished at 1 8 flipped at 2 7 68 E increased! 8.0 frac = 0.000335462627903 b= 0.677180391392 dH = 8.0 68 Loser! spin restablished at 2 7 flipped at 7 5 69 E increased! 8.0 frac = 0.000335462627903 b= 0.626863122695 dH = 8.0 69 Loser! spin restablished at 7 5 flipped at 2 1 70 E increased! 8.0 frac = 0.000335462627903 b= 0.66123249829 dH = 8.0 70 Loser! spin restablished at 2 1 flipped at 0 4 71 E increased! 8.0 frac = 0.000335462627903 b= 0.293850188133 dH = 8.0 71 Loser! spin restablished at 0 4 flipped at 3 4 72 E increased! 8.0 frac = 0.000335462627903 b= 0.594377916307 dH = 8.0 72 Loser! spin restablished at 3 4 flipped at 0 2 73 E increased! 8.0 frac = 0.000335462627903 b= 0.2981661573 dH = 8.0 73 Loser! spin restablished at 0 2 flipped at 0 6 74 E increased! 8.0 frac = 0.000335462627903 b= 0.632308851963 dH = 8.0 74 Loser! spin restablished at 0 6 flipped at 3 4 75 E increased! 8.0 frac = 0.000335462627903 b= 0.0121514733002 dH = 8.0 75 Loser! spin restablished at 3 4 flipped at 4 5 76 E increased! 8.0 frac = 0.000335462627903 b= 0.264421186353 dH = 8.0 76 Loser! spin restablished at 4 5 flipped at 2 4 77 E increased! 8.0 frac = 0.000335462627903 b= 0.824902228556 dH = 8.0 77 Loser! spin restablished at 2 4 flipped at 0 7 78 E increased! 8.0 frac = 0.000335462627903 b= 0.0214405875202 dH = 8.0 78 Loser! spin restablished at 0 7 flipped at 1 5 79 E increased! 8.0 frac = 0.000335462627903 b= 0.210900739425 dH = 8.0 79 Loser! spin restablished at 1 5 flipped at 4 5 80 E increased! 8.0 frac = 0.000335462627903 b= 0.574664768366 dH = 8.0 80 Loser! spin restablished at 4 5 flipped at 2 7 81 E increased! 8.0 frac = 0.000335462627903 b= 0.847649373404 dH = 8.0 81 Loser! spin restablished at 2 7 flipped at 7 3 82 E increased! 8.0 frac = 0.000335462627903 b= 0.832491150391 dH = 8.0 82 Loser! spin restablished at 7 3 flipped at 1 2 83 E increased! 8.0 frac = 0.000335462627903 b= 0.855154490886 dH = 8.0 83 Loser! spin restablished at 1 2 flipped at 8 7 84 E increased! 8.0 frac = 0.000335462627903 b= 0.655322271761 dH = 8.0 84 Loser! spin restablished at 8 7 flipped at 0 1 85 E increased! 8.0 frac = 0.000335462627903 b= 0.406890106087 dH = 8.0 85 Loser! spin restablished at 0 1 flipped at 1 2 86 E increased! 8.0 frac = 0.000335462627903 b= 0.000673501357872 dH = 8.0 86 Loser! spin restablished at 1 2 flipped at 3 5 87 E increased! 8.0 frac = 0.000335462627903 b= 0.507304936668 dH = 8.0 87 Loser! spin restablished at 3 5 flipped at 2 0 88 E increased! 8.0 frac = 0.000335462627903 b= 0.245869405573 dH = 8.0 88 Loser! spin restablished at 2 0 flipped at 0 3 89 E increased! 8.0 frac = 0.000335462627903 b= 0.718536865241 dH = 8.0 89 Loser! spin restablished at 0 3 flipped at 1 5 90 E increased! 8.0 frac = 0.000335462627903 b= 0.736465815937 dH = 8.0 90 Loser! spin restablished at 1 5 flipped at 4 7 91 E increased! 8.0 frac = 0.000335462627903 b= 0.265875688904 dH = 8.0 91 Loser! spin restablished at 4 7 flipped at 1 1 92 E increased! 8.0 frac = 0.000335462627903 b= 0.954550813922 dH = 8.0 92 Loser! spin restablished at 1 1 flipped at 5 3 93 E increased! 8.0 frac = 0.000335462627903 b= 0.0460167879754 dH = 8.0 93 Loser! spin restablished at 5 3 flipped at 6 9 94 E increased! 8.0 frac = 0.000335462627903 b= 0.198101449804 dH = 8.0 94 Loser! spin restablished at 6 9 flipped at 5 1 95 E increased! 8.0 frac = 0.000335462627903 b= 0.725967185102 dH = 8.0 95 Loser! spin restablished at 5 1 flipped at 4 5 96 E increased! 8.0 frac = 0.000335462627903 b= 0.985048609735 dH = 8.0 96 Loser! spin restablished at 4 5 flipped at 4 9 97 E increased! 8.0 frac = 0.000335462627903 b= 0.530198025988 dH = 8.0 97 Loser! spin restablished at 4 9 flipped at 0 7 98 E increased! 8.0 frac = 0.000335462627903 b= 0.291920780419 dH = 8.0 98 Loser! spin restablished at 0 7 flipped at 9 5 99 E increased! 8.0 frac = 0.000335462627903 b= 0.885533031239 dH = 8.0 99 Loser! spin restablished at 9 5 Mplotter def thrmal_plotter(M,nrun) : X = np.arange(0,len(M),1) plt.figure(1) plt.grid() plt.plot(X,M,\"-\") plt.axis([0,nrun,-1.2,1.2]) plt.show() return L = 20 nrun = 10000 T = 2.4 U = cold_start(L) M,U = Thermalization(U,T,nrun, 0) thrmal_plotter(M,nrun) #Uplotter(U) We can plot both run with hot and cold start together: L =20 nrun = 10000 T = 5.0 U1 = cold_start(L) U2 = hot_start(L) M1,U1 = Thermalization(U1,T,nrun,0) M2,U2 = Thermalization(U2,T,nrun,0) X = np.arange(0,len(M1),1) plt.figure(1) plt.grid() plt.plot(X,M1,\"-\") plt.plot(X,M2,\"-\") plt.axis([0,nrun,-1,1]) plt.show() Phase Transition L = 32 nrun = 10000 Tn = 100 avm = [] KT = [] for t in range(1,Tn+1): T = 0.1*t KT.append(T) U = cold_start(L) M,U = Thermalization(U,T,nrun,0) nM = M[1000:nrun-1] avm.append(np.mean(nM)) plt.figure() plt.scatter(KT,avm) #plt.axis([0,1,-1,1]) plt.grid() plt.show() Uplotter def Uplotter(List): '''List = List to be plotted dim = dimension of matrix tics = x and y tics applied''' dim = len(List[0]) tics = 1 tt = 1.0 s_map = [(float(p),float(q)) for p in range(dim) for q in range(dim)] site = 0 for p in range(dim): for q in range(dim): if List[p][q] == -1 : rtgl = pylab.Rectangle(s_map[site], tt,tt, fc='white') pylab.gca().add_patch(rtgl) if List[p][q] == 1 : rtgl = pylab.Rectangle(s_map[site], tt,tt, fc='red') pylab.gca().add_patch(rtgl) site = site+1 Dx = float(dim) Dy = float(dim) pylab.axis('scaled') pylab.axis([0.0,Dx,0.0,Dy]) #pylab.xticks([(tics)*k for k in range(int(dim/tics))]) #pylab.yticks([(tics)*k for k in range(int(dim/tics))]) pylab.show() return","title":"Ising Model"},{"location":"Montecarlo/IzingModel/Izing2D/#ising-model-2d-using-importance-sampling","text":"First of all we import the required libraries: Date - Oct -9-2015 import matplotlib.pyplot as plt import math as math import random as random import pylab as pylab import numpy as np","title":"Ising Model - 2D using Importance Sampling"},{"location":"Montecarlo/IzingModel/Izing2D/#global-parameters","text":"Then we set some global variables: Kb = 1.0 JJ = 1.0","title":"Global parameters"},{"location":"Montecarlo/IzingModel/Izing2D/#cold-start-and-hot-start","text":"Before begining simulation, if we select all spin up or all spin down then it is called cold configuration. def cold_start(L): U = [[1.0 for k in range(L)]for l in range(L)] return U We can make a plot of this cold configuration by the help of Uplotter : CU = cold_start(10) Uplotter(CU) if we select spin randomly up or down then it is called cold configuration def hot_start(L): U = [[0.0 for i in range(L)]for j in range(L)] for i in range(L): for j in range(L): t = random.sample([-1,1],1) U[i][j] = t[0] return U Similarly we can plot thishot configuration as well. HU = hot_start(10) Uplotter(HU)","title":"Cold Start and Hot Start"},{"location":"Montecarlo/IzingModel/Izing2D/#hamiltonian","text":"Hamiltonian of L by L lattice is given by $$H = - J \\sum_{i\\neq j} S_{i}S_{j}$$ def Hamiltonian(U): H = 0.0 L = len(U) for i in range(L): for j in range(L): ni = 0;nj =0; if i == 0: ni = L if j == 0: nj = L H = H - 0.5*JJ*U[i][j]*(U[i][(j-1)+nj] \\ + U[(i+1)%L][j] \\ + U[i][(j+1)%L] \\ + U[(i-1)+ni][j]) return H One can check what are hamiltonian for hot and cold start: Hamiltonian(CU) -200.0 Hamiltonian(HU) 12.0","title":"Hamiltonian"},{"location":"Montecarlo/IzingModel/Izing2D/#mangnetization","text":"One can calculate magnetization by simply taking average over all spins: def magnetization(U): m = 0.0 L = len(U) for i in range(L): for j in range(L): m = m + U[i][j] m = m/float(L*L) return m magnetization(HU) 0.02 magnetization(CU) 1.0","title":"Mangnetization"},{"location":"Montecarlo/IzingModel/Izing2D/#spin-flipper","text":"def ld(k,L): if k == 0: return L else: return 0 def spin_flipper(U,printkey): L = len(U) i = random.randint(0, L-1) j = random.randint(0, L-1) if printkey ==1:print \"flipped at\", i,j U[i][j] = -U[i][j] dH = -2.0*JJ*U[i][j]*(U[i][(j-1)+ld(j,L)] \\ + U[(i+1)%L][j] \\ + U[i][(j+1)%L] \\ + U[(i-1)+ld(i,L)][j]) return U,dH,i,j","title":"Spin Flipper"},{"location":"Montecarlo/IzingModel/Izing2D/#thermalization","text":"def Thermalization(U,T,nrun,printkey) : M = [0.0 for k in range(nrun)] irun = 0 while irun < nrun: V = U w = magnetization(U) U,dH,p,q = spin_flipper(U,printkey) if dH < 0: if printkey ==1: print irun, \"E decreased! You are accepted !\",dH M[irun] = magnetization(U) else: if printkey ==1:print irun, \"E increased!\",dH frac = math.exp(-dH/(Kb*T)) b = random.uniform(0.0,1.0) if printkey ==1:print \"frac =\",frac,\"b=\",b,\"dH = \",dH if b < frac: if printkey ==1:print irun, \" You Lucky!\" M[irun] = magnetization(U) else: if printkey ==1: print irun, \"Loser!\" if printkey ==1: print \"spin restablished at\",p,q U[p][q] = -U[p][q] M[irun] = w for i in range(L): for j in range(L): if U[i][j] != V[i][i]: if printkey ==1: print\"Warning!spin is changed!\", i,j if printkey ==2 : print irun, M[irun] irun = irun +1 return M,U Lets print out some measurements of m nrun = 100 T = 1.0 L = 10 U = cold_start(L) M,U = Thermalization(U,T,nrun, 1) flipped at 2 6 0 E increased! 8.0 frac = 0.000335462627903 b= 0.200945442416 dH = 8.0 0 Loser! spin restablished at 2 6 flipped at 5 3 1 E increased! 8.0 frac = 0.000335462627903 b= 0.208228177318 dH = 8.0 1 Loser! spin restablished at 5 3 flipped at 3 9 2 E increased! 8.0 frac = 0.000335462627903 b= 0.518140057869 dH = 8.0 2 Loser! spin restablished at 3 9 flipped at 7 2 3 E increased! 8.0 frac = 0.000335462627903 b= 0.453525585218 dH = 8.0 3 Loser! spin restablished at 7 2 flipped at 4 2 4 E increased! 8.0 frac = 0.000335462627903 b= 0.301315970059 dH = 8.0 4 Loser! spin restablished at 4 2 flipped at 1 1 5 E increased! 8.0 frac = 0.000335462627903 b= 0.559871016385 dH = 8.0 5 Loser! spin restablished at 1 1 flipped at 3 7 6 E increased! 8.0 frac = 0.000335462627903 b= 0.364710311714 dH = 8.0 6 Loser! spin restablished at 3 7 flipped at 4 9 7 E increased! 8.0 frac = 0.000335462627903 b= 0.589989052706 dH = 8.0 7 Loser! spin restablished at 4 9 flipped at 5 7 8 E increased! 8.0 frac = 0.000335462627903 b= 0.00373832879324 dH = 8.0 8 Loser! spin restablished at 5 7 flipped at 7 8 9 E increased! 8.0 frac = 0.000335462627903 b= 0.667080358921 dH = 8.0 9 Loser! spin restablished at 7 8 flipped at 2 8 10 E increased! 8.0 frac = 0.000335462627903 b= 0.958643303676 dH = 8.0 10 Loser! spin restablished at 2 8 flipped at 2 0 11 E increased! 8.0 frac = 0.000335462627903 b= 0.117960949982 dH = 8.0 11 Loser! spin restablished at 2 0 flipped at 1 7 12 E increased! 8.0 frac = 0.000335462627903 b= 0.128279159058 dH = 8.0 12 Loser! spin restablished at 1 7 flipped at 1 6 13 E increased! 8.0 frac = 0.000335462627903 b= 0.41237756183 dH = 8.0 13 Loser! spin restablished at 1 6 flipped at 3 4 14 E increased! 8.0 frac = 0.000335462627903 b= 0.208921911192 dH = 8.0 14 Loser! spin restablished at 3 4 flipped at 5 4 15 E increased! 8.0 frac = 0.000335462627903 b= 0.121113318063 dH = 8.0 15 Loser! spin restablished at 5 4 flipped at 2 1 16 E increased! 8.0 frac = 0.000335462627903 b= 0.91059155363 dH = 8.0 16 Loser! spin restablished at 2 1 flipped at 2 2 17 E increased! 8.0 frac = 0.000335462627903 b= 0.0312121693169 dH = 8.0 17 Loser! spin restablished at 2 2 flipped at 7 5 18 E increased! 8.0 frac = 0.000335462627903 b= 0.44423543869 dH = 8.0 18 Loser! spin restablished at 7 5 flipped at 9 8 19 E increased! 8.0 frac = 0.000335462627903 b= 0.838164630904 dH = 8.0 19 Loser! spin restablished at 9 8 flipped at 4 4 20 E increased! 8.0 frac = 0.000335462627903 b= 0.978984488947 dH = 8.0 20 Loser! spin restablished at 4 4 flipped at 9 1 21 E increased! 8.0 frac = 0.000335462627903 b= 0.660100062089 dH = 8.0 21 Loser! spin restablished at 9 1 flipped at 0 9 22 E increased! 8.0 frac = 0.000335462627903 b= 0.384350846156 dH = 8.0 22 Loser! spin restablished at 0 9 flipped at 8 3 23 E increased! 8.0 frac = 0.000335462627903 b= 0.147521237768 dH = 8.0 23 Loser! spin restablished at 8 3 flipped at 1 2 24 E increased! 8.0 frac = 0.000335462627903 b= 0.245418005023 dH = 8.0 24 Loser! spin restablished at 1 2 flipped at 7 4 25 E increased! 8.0 frac = 0.000335462627903 b= 0.566226070388 dH = 8.0 25 Loser! spin restablished at 7 4 flipped at 8 6 26 E increased! 8.0 frac = 0.000335462627903 b= 0.470824511812 dH = 8.0 26 Loser! spin restablished at 8 6 flipped at 9 1 27 E increased! 8.0 frac = 0.000335462627903 b= 0.468902208133 dH = 8.0 27 Loser! spin restablished at 9 1 flipped at 3 3 28 E increased! 8.0 frac = 0.000335462627903 b= 0.956164659389 dH = 8.0 28 Loser! spin restablished at 3 3 flipped at 7 5 29 E increased! 8.0 frac = 0.000335462627903 b= 0.427388520837 dH = 8.0 29 Loser! spin restablished at 7 5 flipped at 9 2 30 E increased! 8.0 frac = 0.000335462627903 b= 0.043987391181 dH = 8.0 30 Loser! spin restablished at 9 2 flipped at 7 8 31 E increased! 8.0 frac = 0.000335462627903 b= 0.666327053159 dH = 8.0 31 Loser! spin restablished at 7 8 flipped at 7 0 32 E increased! 8.0 frac = 0.000335462627903 b= 0.515433733306 dH = 8.0 32 Loser! spin restablished at 7 0 flipped at 2 8 33 E increased! 8.0 frac = 0.000335462627903 b= 0.167613150653 dH = 8.0 33 Loser! spin restablished at 2 8 flipped at 0 3 34 E increased! 8.0 frac = 0.000335462627903 b= 0.345178826725 dH = 8.0 34 Loser! spin restablished at 0 3 flipped at 0 1 35 E increased! 8.0 frac = 0.000335462627903 b= 0.513958539065 dH = 8.0 35 Loser! spin restablished at 0 1 flipped at 6 8 36 E increased! 8.0 frac = 0.000335462627903 b= 0.4871901386 dH = 8.0 36 Loser! spin restablished at 6 8 flipped at 7 2 37 E increased! 8.0 frac = 0.000335462627903 b= 0.59898662047 dH = 8.0 37 Loser! spin restablished at 7 2 flipped at 4 9 38 E increased! 8.0 frac = 0.000335462627903 b= 0.0847937443966 dH = 8.0 38 Loser! spin restablished at 4 9 flipped at 5 6 39 E increased! 8.0 frac = 0.000335462627903 b= 0.098801882584 dH = 8.0 39 Loser! spin restablished at 5 6 flipped at 2 4 40 E increased! 8.0 frac = 0.000335462627903 b= 0.653577770213 dH = 8.0 40 Loser! spin restablished at 2 4 flipped at 7 3 41 E increased! 8.0 frac = 0.000335462627903 b= 0.302675497483 dH = 8.0 41 Loser! spin restablished at 7 3 flipped at 2 6 42 E increased! 8.0 frac = 0.000335462627903 b= 0.46557731556 dH = 8.0 42 Loser! spin restablished at 2 6 flipped at 1 0 43 E increased! 8.0 frac = 0.000335462627903 b= 0.0854198113429 dH = 8.0 43 Loser! spin restablished at 1 0 flipped at 1 9 44 E increased! 8.0 frac = 0.000335462627903 b= 0.666489537978 dH = 8.0 44 Loser! spin restablished at 1 9 flipped at 5 0 45 E increased! 8.0 frac = 0.000335462627903 b= 0.214381681158 dH = 8.0 45 Loser! spin restablished at 5 0 flipped at 0 1 46 E increased! 8.0 frac = 0.000335462627903 b= 0.947652883231 dH = 8.0 46 Loser! spin restablished at 0 1 flipped at 2 7 47 E increased! 8.0 frac = 0.000335462627903 b= 0.224155338588 dH = 8.0 47 Loser! spin restablished at 2 7 flipped at 1 1 48 E increased! 8.0 frac = 0.000335462627903 b= 0.922718106128 dH = 8.0 48 Loser! spin restablished at 1 1 flipped at 3 0 49 E increased! 8.0 frac = 0.000335462627903 b= 0.226445418861 dH = 8.0 49 Loser! spin restablished at 3 0 flipped at 6 6 50 E increased! 8.0 frac = 0.000335462627903 b= 0.859615061628 dH = 8.0 50 Loser! spin restablished at 6 6 flipped at 4 6 51 E increased! 8.0 frac = 0.000335462627903 b= 0.104605351213 dH = 8.0 51 Loser! spin restablished at 4 6 flipped at 9 8 52 E increased! 8.0 frac = 0.000335462627903 b= 0.762546438422 dH = 8.0 52 Loser! spin restablished at 9 8 flipped at 5 6 53 E increased! 8.0 frac = 0.000335462627903 b= 0.37637421483 dH = 8.0 53 Loser! spin restablished at 5 6 flipped at 0 4 54 E increased! 8.0 frac = 0.000335462627903 b= 0.22018392926 dH = 8.0 54 Loser! spin restablished at 0 4 flipped at 6 3 55 E increased! 8.0 frac = 0.000335462627903 b= 0.559080327422 dH = 8.0 55 Loser! spin restablished at 6 3 flipped at 0 4 56 E increased! 8.0 frac = 0.000335462627903 b= 0.067818661091 dH = 8.0 56 Loser! spin restablished at 0 4 flipped at 0 1 57 E increased! 8.0 frac = 0.000335462627903 b= 0.592962993336 dH = 8.0 57 Loser! spin restablished at 0 1 flipped at 7 5 58 E increased! 8.0 frac = 0.000335462627903 b= 0.359231837157 dH = 8.0 58 Loser! spin restablished at 7 5 flipped at 9 7 59 E increased! 8.0 frac = 0.000335462627903 b= 0.365371314382 dH = 8.0 59 Loser! spin restablished at 9 7 flipped at 1 4 60 E increased! 8.0 frac = 0.000335462627903 b= 0.0238130043524 dH = 8.0 60 Loser! spin restablished at 1 4 flipped at 1 2 61 E increased! 8.0 frac = 0.000335462627903 b= 0.171939714452 dH = 8.0 61 Loser! spin restablished at 1 2 flipped at 1 4 62 E increased! 8.0 frac = 0.000335462627903 b= 0.798151394609 dH = 8.0 62 Loser! spin restablished at 1 4 flipped at 5 9 63 E increased! 8.0 frac = 0.000335462627903 b= 0.521864864986 dH = 8.0 63 Loser! spin restablished at 5 9 flipped at 4 8 64 E increased! 8.0 frac = 0.000335462627903 b= 0.039200037808 dH = 8.0 64 Loser! spin restablished at 4 8 flipped at 9 3 65 E increased! 8.0 frac = 0.000335462627903 b= 0.907378398139 dH = 8.0 65 Loser! spin restablished at 9 3 flipped at 3 9 66 E increased! 8.0 frac = 0.000335462627903 b= 0.786255454713 dH = 8.0 66 Loser! spin restablished at 3 9 flipped at 1 8 67 E increased! 8.0 frac = 0.000335462627903 b= 0.151408860995 dH = 8.0 67 Loser! spin restablished at 1 8 flipped at 2 7 68 E increased! 8.0 frac = 0.000335462627903 b= 0.677180391392 dH = 8.0 68 Loser! spin restablished at 2 7 flipped at 7 5 69 E increased! 8.0 frac = 0.000335462627903 b= 0.626863122695 dH = 8.0 69 Loser! spin restablished at 7 5 flipped at 2 1 70 E increased! 8.0 frac = 0.000335462627903 b= 0.66123249829 dH = 8.0 70 Loser! spin restablished at 2 1 flipped at 0 4 71 E increased! 8.0 frac = 0.000335462627903 b= 0.293850188133 dH = 8.0 71 Loser! spin restablished at 0 4 flipped at 3 4 72 E increased! 8.0 frac = 0.000335462627903 b= 0.594377916307 dH = 8.0 72 Loser! spin restablished at 3 4 flipped at 0 2 73 E increased! 8.0 frac = 0.000335462627903 b= 0.2981661573 dH = 8.0 73 Loser! spin restablished at 0 2 flipped at 0 6 74 E increased! 8.0 frac = 0.000335462627903 b= 0.632308851963 dH = 8.0 74 Loser! spin restablished at 0 6 flipped at 3 4 75 E increased! 8.0 frac = 0.000335462627903 b= 0.0121514733002 dH = 8.0 75 Loser! spin restablished at 3 4 flipped at 4 5 76 E increased! 8.0 frac = 0.000335462627903 b= 0.264421186353 dH = 8.0 76 Loser! spin restablished at 4 5 flipped at 2 4 77 E increased! 8.0 frac = 0.000335462627903 b= 0.824902228556 dH = 8.0 77 Loser! spin restablished at 2 4 flipped at 0 7 78 E increased! 8.0 frac = 0.000335462627903 b= 0.0214405875202 dH = 8.0 78 Loser! spin restablished at 0 7 flipped at 1 5 79 E increased! 8.0 frac = 0.000335462627903 b= 0.210900739425 dH = 8.0 79 Loser! spin restablished at 1 5 flipped at 4 5 80 E increased! 8.0 frac = 0.000335462627903 b= 0.574664768366 dH = 8.0 80 Loser! spin restablished at 4 5 flipped at 2 7 81 E increased! 8.0 frac = 0.000335462627903 b= 0.847649373404 dH = 8.0 81 Loser! spin restablished at 2 7 flipped at 7 3 82 E increased! 8.0 frac = 0.000335462627903 b= 0.832491150391 dH = 8.0 82 Loser! spin restablished at 7 3 flipped at 1 2 83 E increased! 8.0 frac = 0.000335462627903 b= 0.855154490886 dH = 8.0 83 Loser! spin restablished at 1 2 flipped at 8 7 84 E increased! 8.0 frac = 0.000335462627903 b= 0.655322271761 dH = 8.0 84 Loser! spin restablished at 8 7 flipped at 0 1 85 E increased! 8.0 frac = 0.000335462627903 b= 0.406890106087 dH = 8.0 85 Loser! spin restablished at 0 1 flipped at 1 2 86 E increased! 8.0 frac = 0.000335462627903 b= 0.000673501357872 dH = 8.0 86 Loser! spin restablished at 1 2 flipped at 3 5 87 E increased! 8.0 frac = 0.000335462627903 b= 0.507304936668 dH = 8.0 87 Loser! spin restablished at 3 5 flipped at 2 0 88 E increased! 8.0 frac = 0.000335462627903 b= 0.245869405573 dH = 8.0 88 Loser! spin restablished at 2 0 flipped at 0 3 89 E increased! 8.0 frac = 0.000335462627903 b= 0.718536865241 dH = 8.0 89 Loser! spin restablished at 0 3 flipped at 1 5 90 E increased! 8.0 frac = 0.000335462627903 b= 0.736465815937 dH = 8.0 90 Loser! spin restablished at 1 5 flipped at 4 7 91 E increased! 8.0 frac = 0.000335462627903 b= 0.265875688904 dH = 8.0 91 Loser! spin restablished at 4 7 flipped at 1 1 92 E increased! 8.0 frac = 0.000335462627903 b= 0.954550813922 dH = 8.0 92 Loser! spin restablished at 1 1 flipped at 5 3 93 E increased! 8.0 frac = 0.000335462627903 b= 0.0460167879754 dH = 8.0 93 Loser! spin restablished at 5 3 flipped at 6 9 94 E increased! 8.0 frac = 0.000335462627903 b= 0.198101449804 dH = 8.0 94 Loser! spin restablished at 6 9 flipped at 5 1 95 E increased! 8.0 frac = 0.000335462627903 b= 0.725967185102 dH = 8.0 95 Loser! spin restablished at 5 1 flipped at 4 5 96 E increased! 8.0 frac = 0.000335462627903 b= 0.985048609735 dH = 8.0 96 Loser! spin restablished at 4 5 flipped at 4 9 97 E increased! 8.0 frac = 0.000335462627903 b= 0.530198025988 dH = 8.0 97 Loser! spin restablished at 4 9 flipped at 0 7 98 E increased! 8.0 frac = 0.000335462627903 b= 0.291920780419 dH = 8.0 98 Loser! spin restablished at 0 7 flipped at 9 5 99 E increased! 8.0 frac = 0.000335462627903 b= 0.885533031239 dH = 8.0 99 Loser! spin restablished at 9 5","title":"Thermalization"},{"location":"Montecarlo/IzingModel/Izing2D/#mplotter","text":"def thrmal_plotter(M,nrun) : X = np.arange(0,len(M),1) plt.figure(1) plt.grid() plt.plot(X,M,\"-\") plt.axis([0,nrun,-1.2,1.2]) plt.show() return L = 20 nrun = 10000 T = 2.4 U = cold_start(L) M,U = Thermalization(U,T,nrun, 0) thrmal_plotter(M,nrun) #Uplotter(U) We can plot both run with hot and cold start together: L =20 nrun = 10000 T = 5.0 U1 = cold_start(L) U2 = hot_start(L) M1,U1 = Thermalization(U1,T,nrun,0) M2,U2 = Thermalization(U2,T,nrun,0) X = np.arange(0,len(M1),1) plt.figure(1) plt.grid() plt.plot(X,M1,\"-\") plt.plot(X,M2,\"-\") plt.axis([0,nrun,-1,1]) plt.show()","title":"Mplotter"},{"location":"Montecarlo/IzingModel/Izing2D/#phase-transition","text":"L = 32 nrun = 10000 Tn = 100 avm = [] KT = [] for t in range(1,Tn+1): T = 0.1*t KT.append(T) U = cold_start(L) M,U = Thermalization(U,T,nrun,0) nM = M[1000:nrun-1] avm.append(np.mean(nM)) plt.figure() plt.scatter(KT,avm) #plt.axis([0,1,-1,1]) plt.grid() plt.show()","title":"Phase Transition"},{"location":"Montecarlo/IzingModel/Izing2D/#uplotter","text":"def Uplotter(List): '''List = List to be plotted dim = dimension of matrix tics = x and y tics applied''' dim = len(List[0]) tics = 1 tt = 1.0 s_map = [(float(p),float(q)) for p in range(dim) for q in range(dim)] site = 0 for p in range(dim): for q in range(dim): if List[p][q] == -1 : rtgl = pylab.Rectangle(s_map[site], tt,tt, fc='white') pylab.gca().add_patch(rtgl) if List[p][q] == 1 : rtgl = pylab.Rectangle(s_map[site], tt,tt, fc='red') pylab.gca().add_patch(rtgl) site = site+1 Dx = float(dim) Dy = float(dim) pylab.axis('scaled') pylab.axis([0.0,Dx,0.0,Dy]) #pylab.xticks([(tics)*k for k in range(int(dim/tics))]) #pylab.yticks([(tics)*k for k in range(int(dim/tics))]) pylab.show() return","title":"Uplotter"},{"location":"Montecarlo/Levy/levy/","text":"Levy Quantum Path Continuous Random Walk % matplotlib inline import math , random beta = 4.0 N = 8 sigma = math . sqrt(beta / N) x = [ 0.0 ] for k in range (N - 1 ): x . append(random . gauss(x[ - 1 ], sigma)) print x [0.0, 1.01509231498381, 0.8954574749069657, 0.4475173962954569, -0.6617069586993383, -0.38473534012694194, -0.6521628289908354, -1.550921896951777] Trivial Free Path import math , random beta = 1.0 N = 8 sigma = math . sqrt(beta / N) xend = 1.0 Upsilon = [ 0.0 ] for k in range (N): Upsilon . append(random . gauss(Upsilon[ - 1 ], sigma)) x = [ 0.0 ] + [Upsilon[k] + (xend - Upsilon[ - 1 ]) * \\ k / float (N) for k in range ( 1 , N + 1 )] print x [0.0, 0.16650886545595994, 0.6100876683233167, 1.2878936165304946, 1.522730604023694, 1.8655448259378942, 1.8779816089586798, 1.4174193447820458, 1.0] Levy Free Path import math , random beta = 1.0 N = 4 dtau = beta / N nsteps = 10 # number of paths to be generated xstart, xend = 0.0 , 1.0 # initial and final points for step in range (nsteps): x = [xstart] for k in range ( 1 , N): # loop over internal slices dtau_prime = (N - k) * dtau x_mean = (dtau_prime * x[k - 1 ] + dtau * xend) / \\ (dtau + dtau_prime) sigma = math . sqrt( 1.0 / ( 1.0 / dtau + 1.0 / dtau_prime)) x . append(random . gauss(x_mean, sigma)) x . append(xend) print x [0.0, 0.5707795321525617, 0.5866019527578654, 0.8089609595648815, 1.0] [0.0, -0.3396754967087857, 0.7235057663520837, 1.1315669585984993, 1.0] [0.0, 0.018063918143963353, 0.16434572728171748, 0.592993315765318, 1.0] [0.0, 0.2246140968885552, 0.966182738296046, 0.746201579459617, 1.0] [0.0, -0.23985854999079953, -0.23870459469931876, 0.14380281472001558, 1.0] [0.0, 0.15962908547527493, 1.137840942610433, 1.3625924641454001, 1.0] [0.0, -1.1579809269318322, -1.0786715345985927, 0.4854709061903433, 1.0] [0.0, 0.1404369341832184, 0.4541880825433704, 0.8673479702904441, 1.0] [0.0, 0.7425438080805121, 0.8693731794283786, 1.3336622912118516, 1.0] [0.0, 0.12440416711297678, 0.2510353241093216, 1.1245847853705508, 1.0] Naive Harmonic Path import math , random def rho_free (x, y, beta): # free off-diagonal density matrix return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) beta = 4.0 N = 8 # number of slices dtau = beta / N delta = 1.0 # maximum displacement of one bead n_steps = 20 # number of Monte Carlo steps x = [ 0.0 ] * N # initial path for step in xrange (n_steps): k = random . randint( 0 , N - 1 ) # random slice knext, kprev = (k + 1 ) % N, (k - 1 ) % N # next/previous slices x_new = x[k] + random . uniform( - delta, delta) # new position at slice k old_weight = (rho_free(x[knext], x[k], dtau) * rho_free(x[k], x[kprev], dtau) * math . exp( - 0.5 * dtau * x[k] ** 2 )) new_weight = (rho_free(x[knext], x_new, dtau) * rho_free(x_new, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_new ** 2 )) if random . random() < new_weight / old_weight: x[k] = x_new print x [0.0, 0.28998171631723735, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] [0.0, 0.28998171631723735, -0.4471023666935825, 0.0, 0.0, 0.0, 0.0, 0.0] [0.0, 0.28998171631723735, -0.4471023666935825, 0.0, -0.6140259897130926, 0.0, 0.0, 0.0] [0.0, 0.28998171631723735, -0.4471023666935825, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, 0.0] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, 0.0] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, 0.0] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, -0.5351955742208034, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, -0.5351955742208034, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.4700080333224783, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.4700080333224783, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] Naive Path Slice import math , random def rho_free (x, y, beta): return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) dtau_prime = 0.1 dtau_dprime = 0.2 x_prime = 0.0 x_dprime = 1.0 delta = 1.0 n_steps = 10 xk = 0.0 for step in xrange (n_steps): xk_new = xk + random . uniform( - delta, delta) old_weight = (rho_free(x_dprime, xk, dtau_dprime) * rho_free(xk, x_prime, dtau_prime)) new_weight = (rho_free(x_dprime, xk_new, dtau_dprime) * rho_free(xk_new, x_prime, dtau_prime)) if random . random() < new_weight / old_weight: xk = xk_new print xk 0.095401252446 0.095401252446 0.512795106019 0.512795106019 0.512795106019 0.512795106019 0.512795106019 0.512795106019 0.901968228505 0.901968228505 Naive Path Slice Movie import math , random , pylab def rho_free (x, y, beta): return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) dtau_prime = 0.1 dtau_dprime = 0.2 x_prime = 0.0 x_dprime = 1.0 delta = 1.0 # maximum displacement of xk n_steps = 1000 # number of Monte Carlo steps data_hist = [] xk = 0.0 # initial value of xk for step in xrange (n_steps): xk_new = xk + random . uniform( - delta, delta) old_weight = (rho_free(x_dprime, xk, dtau_dprime) * rho_free(xk, x_prime, dtau_prime)) new_weight = (rho_free(x_dprime, xk_new, dtau_dprime) * rho_free(xk_new, x_prime, dtau_prime)) if random . random() < new_weight / old_weight: xk = xk_new data_hist . append(xk) def pi_analytic (xk, x_prime, x_dprime, dtau_prime, dtau_dprime): mean = (dtau_dprime * x_prime + dtau_prime * x_dprime) / (dtau_prime + dtau_dprime) sigma = 1.0 / math . sqrt( 1.0 / dtau_prime + 1.0 / dtau_dprime) return math . exp( - (xk - mean) ** 2 / ( 2.0 * sigma ** 2 )) / math . sqrt( 2.0 * math . pi) / sigma pylab . title( 'Distribution on slice k' , fontsize = 18 ) histo, bin_edges, dummy = pylab . hist(data_hist, bins = 100 , normed = True ) bin_centers = 0.5 * (bin_edges[ 1 :] + bin_edges[: - 1 ]) pylab . plot(bin_centers, [pi_analytic(x, x_prime, x_dprime, dtau_prime, dtau_dprime) for x in bin_centers], 'r-' , lw = 3 ) pylab . xlabel( '$x_k$' , fontsize = 18 ) pylab . ylabel( '$\\pi(x_k)$' , fontsize = 18 ) #pylab.savefig('plot-path_slice.png') pylab . show() Levy Harmonic Path import math , random beta = 1.0 N = 4 dtau = beta / N xstart, xend = 0.0 , 1.0 x = [xstart] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Ups1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Ups2 = x[k - 1 ] / math . sinh(dtau) + \\ xend / math . sinh(dtau_prime) x . append(random . gauss(Ups2 / Ups1, \\ 1.0 / math . sqrt(Ups1))) x . append(xend) print x [0.0, -0.3585400331470993, -0.46657041443239394, 0.01352956236855482, 1.0] Levy Harmonic Path 3D import math , random def levy_harmonic_1d (start, end, dtau): x = [start] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Ups1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Ups2 = x[k - 1 ] / math . sinh(dtau) + \\ end / math . sinh(dtau_prime) x . append(random . gauss(Ups2 / Ups1, \\ 1.0 / math . sqrt(Ups1))) x . append(end) return x beta = 1.0 N = 20 dtau = beta / float (N) [xstart, ystart, zstart] = [ 1.0 , - 2.0 , 1.5 ] [xend, yend, zend] = [ - 2.5 , 0.0 , - 0.5 ] x = levy_harmonic_1d(xstart, xend, dtau) y = levy_harmonic_1d(ystart, yend, dtau) z = levy_harmonic_1d(zstart, zend, dtau) for i in range (N + 1 ): print 'slice %2i : ' % i, x[i], y[i], z[i] slice 0: 1.0 -2.0 1.5 slice 1: 0.777748893943 -2.10539607648 1.73826482099 slice 2: 0.763931019379 -2.14387236587 1.54684977036 slice 3: 0.500747263585 -2.08049210773 1.58757506994 slice 4: 0.429361380948 -1.98193292492 1.51647256244 slice 5: 0.156144949185 -2.08472795151 1.24115678993 slice 6: -0.301482536938 -2.31425875183 1.2116215967 slice 7: -0.114110853331 -2.01170186332 1.31953455601 slice 8: -0.495169243534 -1.78954410128 1.26715746611 slice 9: -1.07124864136 -1.84323749154 1.22618560998 slice 10: -1.02146009154 -1.4469573166 1.12287349028 slice 11: -1.2202731479 -1.25130592701 1.17356480665 slice 12: -1.44734039796 -0.769759958407 0.871271945556 slice 13: -1.59945389072 -0.917060277419 0.950203408728 slice 14: -1.59348122639 -0.750802821523 0.624546501494 slice 15: -1.79081758311 -0.666414256381 0.444743391328 slice 16: -1.99247299059 -0.44958639971 0.362047069815 slice 17: -1.75822763813 -0.389265378081 0.0467617492471 slice 18: -2.35917386101 -0.396104505937 0.367460418148 slice 19: -2.39839736996 -0.0739252507074 -0.239433962495 slice 20: -2.5 0.0 -0.5 Levy Harmonic Path Movie import math , random , pylab beta = 2.0 N = 10 dtau = beta / N nsteps = 5 xstart, xend = 2.0 , 1.0 for step in range (nsteps): x = [xstart] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Ups1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Ups2 = x[k - 1 ] / math . sinh(dtau) + \\ xend / math . sinh(dtau_prime) x . append(random . gauss(Ups2 / Ups1, \\ 1.0 / math . sqrt(Ups1))) x . append(xend) # graphics pylab . plot(x, [j * dtau for j in range (N + 1 )], 'bo-' ) pylab . xlabel( '$x$' , fontsize = 18 ) pylab . ylabel( '$ \\\\ tau$' , fontsize = 18 ) pylab . title( 'Harmonic path %i ' % step) pylab . xlim( - 2.0 , 4.0 ) pylab . show() #pylab.close() TUTORIAL Naive Single Particle Emax = 5 States = [] for E_x in range (Emax): for E_y in range (Emax): for E_z in range (Emax): States . append(((E_x + E_y + E_z), (E_x, E_y, E_z))) States . sort() for k in range ( 5 ): print ' %3d ' % k, States[k][ 0 ], States[k][ 1 ] 0 0 (0, 0, 0) 1 1 (0, 0, 1) 2 1 (0, 1, 0) 3 1 (1, 0, 0) 4 2 (0, 0, 2) Naive Boson Trap import math Energy = [ 0.0 ] + [ 1.0 ] * 3 + [ 2.0 ] * 6 + [ 3.0 ] * 10 + [ 4.0 ] * 15 beta = 1.0 n_states = 0 Z = 0.0 N0_mean = 0.0 E_mean = 0.0 for s_0 in range ( 35 ): for s_1 in range (s_0, 35 ): for s_2 in range (s_1, 35 ): for s_3 in range (s_2, 35 ): for s_4 in range (s_3, 35 ): n_states += 1 state = [s_0, s_1, s_2, s_3, s_4] E = sum (Energy[s] for s in state) Z += math . exp( - beta * E) E_mean += E * math . exp( - beta * E) N0_mean += state . count( 0 ) * \\ math . exp( - beta * E) print n_states, Z, E_mean / Z / 5.0 , N0_mean / Z / 5.0 575757 17.3732972183 1.03133265311 0.446969501933","title":"Quantum Monte Carlo"},{"location":"Montecarlo/Levy/levy/#levy-quantum-path","text":"Continuous Random Walk % matplotlib inline import math , random beta = 4.0 N = 8 sigma = math . sqrt(beta / N) x = [ 0.0 ] for k in range (N - 1 ): x . append(random . gauss(x[ - 1 ], sigma)) print x [0.0, 1.01509231498381, 0.8954574749069657, 0.4475173962954569, -0.6617069586993383, -0.38473534012694194, -0.6521628289908354, -1.550921896951777] Trivial Free Path import math , random beta = 1.0 N = 8 sigma = math . sqrt(beta / N) xend = 1.0 Upsilon = [ 0.0 ] for k in range (N): Upsilon . append(random . gauss(Upsilon[ - 1 ], sigma)) x = [ 0.0 ] + [Upsilon[k] + (xend - Upsilon[ - 1 ]) * \\ k / float (N) for k in range ( 1 , N + 1 )] print x [0.0, 0.16650886545595994, 0.6100876683233167, 1.2878936165304946, 1.522730604023694, 1.8655448259378942, 1.8779816089586798, 1.4174193447820458, 1.0] Levy Free Path import math , random beta = 1.0 N = 4 dtau = beta / N nsteps = 10 # number of paths to be generated xstart, xend = 0.0 , 1.0 # initial and final points for step in range (nsteps): x = [xstart] for k in range ( 1 , N): # loop over internal slices dtau_prime = (N - k) * dtau x_mean = (dtau_prime * x[k - 1 ] + dtau * xend) / \\ (dtau + dtau_prime) sigma = math . sqrt( 1.0 / ( 1.0 / dtau + 1.0 / dtau_prime)) x . append(random . gauss(x_mean, sigma)) x . append(xend) print x [0.0, 0.5707795321525617, 0.5866019527578654, 0.8089609595648815, 1.0] [0.0, -0.3396754967087857, 0.7235057663520837, 1.1315669585984993, 1.0] [0.0, 0.018063918143963353, 0.16434572728171748, 0.592993315765318, 1.0] [0.0, 0.2246140968885552, 0.966182738296046, 0.746201579459617, 1.0] [0.0, -0.23985854999079953, -0.23870459469931876, 0.14380281472001558, 1.0] [0.0, 0.15962908547527493, 1.137840942610433, 1.3625924641454001, 1.0] [0.0, -1.1579809269318322, -1.0786715345985927, 0.4854709061903433, 1.0] [0.0, 0.1404369341832184, 0.4541880825433704, 0.8673479702904441, 1.0] [0.0, 0.7425438080805121, 0.8693731794283786, 1.3336622912118516, 1.0] [0.0, 0.12440416711297678, 0.2510353241093216, 1.1245847853705508, 1.0] Naive Harmonic Path import math , random def rho_free (x, y, beta): # free off-diagonal density matrix return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) beta = 4.0 N = 8 # number of slices dtau = beta / N delta = 1.0 # maximum displacement of one bead n_steps = 20 # number of Monte Carlo steps x = [ 0.0 ] * N # initial path for step in xrange (n_steps): k = random . randint( 0 , N - 1 ) # random slice knext, kprev = (k + 1 ) % N, (k - 1 ) % N # next/previous slices x_new = x[k] + random . uniform( - delta, delta) # new position at slice k old_weight = (rho_free(x[knext], x[k], dtau) * rho_free(x[k], x[kprev], dtau) * math . exp( - 0.5 * dtau * x[k] ** 2 )) new_weight = (rho_free(x[knext], x_new, dtau) * rho_free(x_new, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_new ** 2 )) if random . random() < new_weight / old_weight: x[k] = x_new print x [0.0, 0.28998171631723735, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] [0.0, 0.28998171631723735, -0.4471023666935825, 0.0, 0.0, 0.0, 0.0, 0.0] [0.0, 0.28998171631723735, -0.4471023666935825, 0.0, -0.6140259897130926, 0.0, 0.0, 0.0] [0.0, 0.28998171631723735, -0.4471023666935825, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, 0.0] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, 0.0] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, 0.0] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, 0.186270538173831, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, -0.5351955742208034, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6140259897130926, -0.5351955742208034, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, -0.016680482140545738] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.5748380328995746, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.6819150385978625, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7494964267635531] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.0, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.4700080333224783, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] [0.4700080333224783, 0.28998171631723735, -0.21280606021069515, 0.0, -0.6758460008351141, -0.5351955742208034, 0.0, 0.7585771385895701] Naive Path Slice import math , random def rho_free (x, y, beta): return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) dtau_prime = 0.1 dtau_dprime = 0.2 x_prime = 0.0 x_dprime = 1.0 delta = 1.0 n_steps = 10 xk = 0.0 for step in xrange (n_steps): xk_new = xk + random . uniform( - delta, delta) old_weight = (rho_free(x_dprime, xk, dtau_dprime) * rho_free(xk, x_prime, dtau_prime)) new_weight = (rho_free(x_dprime, xk_new, dtau_dprime) * rho_free(xk_new, x_prime, dtau_prime)) if random . random() < new_weight / old_weight: xk = xk_new print xk 0.095401252446 0.095401252446 0.512795106019 0.512795106019 0.512795106019 0.512795106019 0.512795106019 0.512795106019 0.901968228505 0.901968228505 Naive Path Slice Movie import math , random , pylab def rho_free (x, y, beta): return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) dtau_prime = 0.1 dtau_dprime = 0.2 x_prime = 0.0 x_dprime = 1.0 delta = 1.0 # maximum displacement of xk n_steps = 1000 # number of Monte Carlo steps data_hist = [] xk = 0.0 # initial value of xk for step in xrange (n_steps): xk_new = xk + random . uniform( - delta, delta) old_weight = (rho_free(x_dprime, xk, dtau_dprime) * rho_free(xk, x_prime, dtau_prime)) new_weight = (rho_free(x_dprime, xk_new, dtau_dprime) * rho_free(xk_new, x_prime, dtau_prime)) if random . random() < new_weight / old_weight: xk = xk_new data_hist . append(xk) def pi_analytic (xk, x_prime, x_dprime, dtau_prime, dtau_dprime): mean = (dtau_dprime * x_prime + dtau_prime * x_dprime) / (dtau_prime + dtau_dprime) sigma = 1.0 / math . sqrt( 1.0 / dtau_prime + 1.0 / dtau_dprime) return math . exp( - (xk - mean) ** 2 / ( 2.0 * sigma ** 2 )) / math . sqrt( 2.0 * math . pi) / sigma pylab . title( 'Distribution on slice k' , fontsize = 18 ) histo, bin_edges, dummy = pylab . hist(data_hist, bins = 100 , normed = True ) bin_centers = 0.5 * (bin_edges[ 1 :] + bin_edges[: - 1 ]) pylab . plot(bin_centers, [pi_analytic(x, x_prime, x_dprime, dtau_prime, dtau_dprime) for x in bin_centers], 'r-' , lw = 3 ) pylab . xlabel( '$x_k$' , fontsize = 18 ) pylab . ylabel( '$\\pi(x_k)$' , fontsize = 18 ) #pylab.savefig('plot-path_slice.png') pylab . show() Levy Harmonic Path import math , random beta = 1.0 N = 4 dtau = beta / N xstart, xend = 0.0 , 1.0 x = [xstart] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Ups1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Ups2 = x[k - 1 ] / math . sinh(dtau) + \\ xend / math . sinh(dtau_prime) x . append(random . gauss(Ups2 / Ups1, \\ 1.0 / math . sqrt(Ups1))) x . append(xend) print x [0.0, -0.3585400331470993, -0.46657041443239394, 0.01352956236855482, 1.0] Levy Harmonic Path 3D import math , random def levy_harmonic_1d (start, end, dtau): x = [start] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Ups1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Ups2 = x[k - 1 ] / math . sinh(dtau) + \\ end / math . sinh(dtau_prime) x . append(random . gauss(Ups2 / Ups1, \\ 1.0 / math . sqrt(Ups1))) x . append(end) return x beta = 1.0 N = 20 dtau = beta / float (N) [xstart, ystart, zstart] = [ 1.0 , - 2.0 , 1.5 ] [xend, yend, zend] = [ - 2.5 , 0.0 , - 0.5 ] x = levy_harmonic_1d(xstart, xend, dtau) y = levy_harmonic_1d(ystart, yend, dtau) z = levy_harmonic_1d(zstart, zend, dtau) for i in range (N + 1 ): print 'slice %2i : ' % i, x[i], y[i], z[i] slice 0: 1.0 -2.0 1.5 slice 1: 0.777748893943 -2.10539607648 1.73826482099 slice 2: 0.763931019379 -2.14387236587 1.54684977036 slice 3: 0.500747263585 -2.08049210773 1.58757506994 slice 4: 0.429361380948 -1.98193292492 1.51647256244 slice 5: 0.156144949185 -2.08472795151 1.24115678993 slice 6: -0.301482536938 -2.31425875183 1.2116215967 slice 7: -0.114110853331 -2.01170186332 1.31953455601 slice 8: -0.495169243534 -1.78954410128 1.26715746611 slice 9: -1.07124864136 -1.84323749154 1.22618560998 slice 10: -1.02146009154 -1.4469573166 1.12287349028 slice 11: -1.2202731479 -1.25130592701 1.17356480665 slice 12: -1.44734039796 -0.769759958407 0.871271945556 slice 13: -1.59945389072 -0.917060277419 0.950203408728 slice 14: -1.59348122639 -0.750802821523 0.624546501494 slice 15: -1.79081758311 -0.666414256381 0.444743391328 slice 16: -1.99247299059 -0.44958639971 0.362047069815 slice 17: -1.75822763813 -0.389265378081 0.0467617492471 slice 18: -2.35917386101 -0.396104505937 0.367460418148 slice 19: -2.39839736996 -0.0739252507074 -0.239433962495 slice 20: -2.5 0.0 -0.5 Levy Harmonic Path Movie import math , random , pylab beta = 2.0 N = 10 dtau = beta / N nsteps = 5 xstart, xend = 2.0 , 1.0 for step in range (nsteps): x = [xstart] for k in range ( 1 , N): dtau_prime = (N - k) * dtau Ups1 = 1.0 / math . tanh(dtau) + \\ 1.0 / math . tanh(dtau_prime) Ups2 = x[k - 1 ] / math . sinh(dtau) + \\ xend / math . sinh(dtau_prime) x . append(random . gauss(Ups2 / Ups1, \\ 1.0 / math . sqrt(Ups1))) x . append(xend) # graphics pylab . plot(x, [j * dtau for j in range (N + 1 )], 'bo-' ) pylab . xlabel( '$x$' , fontsize = 18 ) pylab . ylabel( '$ \\\\ tau$' , fontsize = 18 ) pylab . title( 'Harmonic path %i ' % step) pylab . xlim( - 2.0 , 4.0 ) pylab . show() #pylab.close()","title":"Levy Quantum Path"},{"location":"Montecarlo/Levy/levy/#tutorial","text":"Naive Single Particle Emax = 5 States = [] for E_x in range (Emax): for E_y in range (Emax): for E_z in range (Emax): States . append(((E_x + E_y + E_z), (E_x, E_y, E_z))) States . sort() for k in range ( 5 ): print ' %3d ' % k, States[k][ 0 ], States[k][ 1 ] 0 0 (0, 0, 0) 1 1 (0, 0, 1) 2 1 (0, 1, 0) 3 1 (1, 0, 0) 4 2 (0, 0, 2) Naive Boson Trap import math Energy = [ 0.0 ] + [ 1.0 ] * 3 + [ 2.0 ] * 6 + [ 3.0 ] * 10 + [ 4.0 ] * 15 beta = 1.0 n_states = 0 Z = 0.0 N0_mean = 0.0 E_mean = 0.0 for s_0 in range ( 35 ): for s_1 in range (s_0, 35 ): for s_2 in range (s_1, 35 ): for s_3 in range (s_2, 35 ): for s_4 in range (s_3, 35 ): n_states += 1 state = [s_0, s_1, s_2, s_3, s_4] E = sum (Energy[s] for s in state) Z += math . exp( - beta * E) E_mean += E * math . exp( - beta * E) N0_mean += state . count( 0 ) * \\ math . exp( - beta * E) print n_states, Z, E_mean / Z / 5.0 , N0_mean / Z / 5.0 575757 17.3732972183 1.03133265311 0.446969501933","title":"TUTORIAL"},{"location":"Montecarlo/Lotto/lotto/","text":"Lotto Dynamics in Integer Space We find a proper model to represent the dynamics of the system in positive integer space [1 to 69] using random number generator. With this model we run Hybrid Montecarlo(HMC) algorithm to thermalize the system to determine most probable values of quantities like: average absolute difference, root mean square absolute difference and most probable absolute difference, which are helpful to determine the most probable vectors in sample space. Import some libraries import random as random import matplotlib.pyplot as plt import numpy as np from numpy import linalg as LA import math as math import pandas % matplotlib inline Maximum no in range of lottery Max = 69 This function generates 5 random samples between 1 to 65. def sample_generator (Max): x = np . sort(random . sample( range ( 1 ,Max), 5 ) ) return x 1.1. Construction of a Toy Model For example, considering range of sample equal to 50, among millions of sample one gets: mean of first no : 5 mean of second no :15 mean of third no :25 mean of fourth no:35 mean of fifth no:45 We consider these mean values as equilibrium point of each oscillator. Oscillators oscillate in integer Space. Each sample of lottery is some state of oscillator. There will be total of (50x49x48x47x46/5!) states. We can choose best modle of oscillator by making a study of correlation cofficients among digits in each sample. Here we have proposed 3 model where model I and II are special case of Model III. 1.1.1. Model Selection with Proper Action Let us define a skewsymmetric distance matrix by taking difference between digits in sample as the matrix elements. There is one distance matrix per sample. $$D_{ij} = (x_{i}-x_{j})$$ ie. $$D = \\left( \\begin{array}{ccc} 0 & \\color{blue}{(x_{1}-x_{2})} & (x_{1}-x_{3})& (x_{1}-x_{4}) & (x_{1}-x_{5}) \\ (x_{2}-x_{1}) & 0 & \\color{blue}{(x_{2}-x_{3})}& (x_{2}-x_{4}) & (x_{2}-x_{5}) \\ (x_{3}-x_{1}) & (x_{3}-x_{2}) & 0& \\color{blue}{(x_{3}-x_{4})} & (x_{3}-x_{5}) \\ (x_{4}-x_{1}) & (x_{4}-x_{2}) & (x_{4}-x_{3})& 0 & \\color{blue}{(x_{4}-x_{5})} \\ \\color{blue}{(x_{5}-x_{1})} & (x_{5}-x_{2}) & (x_{5}-x_{3})& (x_{5}-x_{4}) & 0 \\ \\end{array} \\right)$$ Taking (N = 5) oscillators with flexibility between seperation of numbers as spring constant (K=1). Simple model of Action can be defined by taking single updiagonal terms only as: Model-I (Linear) $$ L = \\frac{1}{2}K[(x_1 -x_2)^2 +(x_2 -x_3)^2 + (x_3 -x_4)^2 + (x_4 -x_5)^2 ] $$ Model-II (Linear &Periodic) $$ L = \\frac{1}{2}K[(x_1 -x_2)^2 +(x_2 -x_3)^2 + (x_3 -x_4)^2 + (x_4 -x_5)^2 + (x_5 -x_1)^2 ] $$ Considering effect of all terms in distance matrix one can define new model of Action as: Model - III (Quadratic & Periodic) $$L = Tr(D^{\\dagger}KD)$$ $\\color{red}{Warning:}$ Since each digit are not equally correlated to eachother, this form of action should be corrected by choosing appropriate spring constant for crossed terms like $x_{3}x_{4}$. K is another matrix(or tensor) of spring constants which can be determined by finding correlation cofficients between digits within several samples. 1.1.2. Study of Distance Matrix We can make skew symmetric matrix into traceless symmetric matrix by taking absolute value of each elements. def distance_matrix (x): D = [[ 0.0 for k in range ( 5 )] for l in range ( 5 )] for k in range ( 5 ): for l in range ( 5 ): D[k][l] = abs (x[k] - x[l]) return D Lets have a look of distance matrix: distance_matrix(sample_generator(Max)) [[0, 9, 24, 39, 44], [9, 0, 15, 30, 35], [24, 15, 0, 15, 20], [39, 30, 15, 0, 5], [44, 35, 20, 5, 0]] We can generate a small bucket of 9 distance matices to visualize distribution of distances. M = [np . array([[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ]]) for k in range ( 9 )] for k in range ( 9 ): M[k] = np . array(distance_matrix(x = sample_generator(Max))) for k in range ( 9 ): plt . subplot( 3 , 3 ,k + 1 ) plt . imshow(M[ 0 ], interpolation = 'nearest' , cmap = plt . cm . ocean, extent = ( 0.5 , 10.5 , 0.5 , 10.5 )) plt . colorbar() plt . show() 1.1.2.1 Enasmble of Distance matrices wstor_III = [] for k in range ( 10000 ): x = sample_generator(Max) A = distance_matrix(x) w, v = LA . eig(A) #print max(w) #for l in range(5): #wstor.append(abs(w[l])) wstor_III . append( max (w)) plt . scatter(k, max (w)) Principle component of eigen values helps us to predict better model by dominancy of principle direction. Principle Component Analysis - Model -III num_bins = 100 plt . grid() plt . title( \"Plot of feequency of principle component in eigen values\" ) plt . hist(wstor_III,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show() Principle Component Analysis - Model - II In model - II , distance matrix becomes diagonal matrix and hence eigen values are diagonal elements themselves. We can plot distribution of largest difference. wstor_II = [] for k in range ( 10000 ): x = sample_generator(Max) A = distance_matrix(x) w = max (A[ 0 ][ 1 ],A[ 1 ][ 2 ],A[ 2 ][ 3 ],A[ 3 ][ 4 ],A[ 4 ][ 0 ]) wstor_II . append(w) plt . scatter(k,w) num_bins = 100 plt . grid() plt . title( \"Plot of feequency of principle component in eigen values\" ) plt . hist(wstor_II,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show() $\\color{blue}{Conclusion}$ : Most of the distance matrices have principle component around 100. Principle compont depends on all distances. Therefore other distances can not be ignored in action. New action should be defined in term of Distance matrix. 1.1.3. Statistical Analysis & Determination of Spring Constants 1.1.3.1. Study of Variance-Covariance Matrix of samples Study of Variance-Covariance help us to determine the spring constant(K) in our model which is ultimately related to the correlation coffecient. We construct Variance-Covariance Matirx by using 100 samples in the following steps: 1 . Lets construct a bag of Nbag = 1000 samples. Nbag = 1000 SampleBag = [sample_generator(Max) for k in range (Nbag)] 2 . Vectorization of 100 samples : where first digit from each sample goes to first column vector of Vec matrix etc. def vactorization (SampleBag): Vec = [[ 0 for k in range (Nbag)] for l in range ( 5 )] for l in range ( 5 ): for k in range (Nbag): Vec[l][k] = SampleBag[k][l] return np . array(Vec) SB = vactorization(SampleBag) p = 1 for l in range ( 5 ): for r in range ( 5 ): plt . subplot( 5 , 5 ,p) plt . scatter(SB[l],SB[r]) p = p + 1 plt . show() 3 . Normalization brings each column vector to have mean equal to zero which helps to visualize variance-covariance of samples. def normalization (Vec): mn = [ 0 for k in range ( 5 )] vr = [ 0 for k in range ( 5 )] rng = [ 0 for k in range ( 5 )] numVec = [[ 0 for k in range (Nbag)] for l in range ( 5 )] #Find mean and range (Maximum-minimum) of each vector for l in range ( 5 ): mn[l] = np . mean(Vec[l]) vr[l] = np . var(Vec[l]) for k in range (Nbag): numVec[l][k] = (SampleBag[k][l] - mn[l]) / (math . sqrt(vr[l] / float (Nbag))) numVec = np . array(numVec) return numVec 1.1.3.2.a. Variance-Covariance of Raw samples Vec = vactorization(SampleBag) VCM_raw = np . cov(Vec) plt . title( \"Variance-Covariance of raw sample\" ) plt . imshow(VCM_raw, interpolation = 'nearest' , cmap = plt . cm . hot, extent = ( 0.5 , 10.5 , 0.5 , 10.5 )) plt . colorbar() plt . show() 1.1.3.2.b. Variance-Covariance of Normalized samples : Crrelation cofficients Vec = vactorization(SampleBag) numVec = normalization(Vec) VCM_normalized = np . cov(numVec) plt . title( \"Variance-Covariance of normalized sample\" ) plt . imshow(VCM_normalized, interpolation = 'nearest' , cmap = plt . cm . hot, extent = ( 0.5 , 10.5 , 0.5 , 10.5 )) plt . colorbar() plt . show() 1.1.3.3. Spring Constants Matrix of spring constants is a symmetric tensor which can be given by square root of normalized correlation cofficients. K = np . sqrt(VCM_normalized / max (VCM_normalized[ 0 ])) K array([[ 1. , 0.79287801, 0.66542652, 0.56166262, 0.45306335], [ 0.79287801, 1. , 0.84281867, 0.69757696, 0.57453966], [ 0.66542652, 0.84281867, 1. , 0.83777405, 0.68199933], [ 0.56166262, 0.69757696, 0.83777405, 1. , 0.80502696], [ 0.45306335, 0.57453966, 0.68199933, 0.80502696, 1. ]]) $\\color{blue}{\\text{Improved Action}}: \\boxed{L = D^{\\dagger}KD}$ with K-matrix found above. 1.2 Montecarlo Simulation One can calculate the most probable difference vector using Hybrid Monrtecarlo Algorithm. Total energy of the system of (N=100) coupled oscillator in integer space can be expressed as: $$H = \\sum_{i=1}^{N} D^{\\dagger}KD $$ Define some useful function for thermalization def action (D): '''D = distance matrix''' '''K = spring constant tensor''' h = np . dot(D,np . dot(K,D)) htr = np . trace(h) return htr def hot_start (): '''N = total no of coupled oscillators in the system ''' '''U = bag of N oscillators''' U = [] for k in range (N): x = sample_generator(Max) U . append(x) return U def cold_start (): '''N = total no of coupled oscillators in the system ''' '''U = bag of N oscillators''' U = [] for k in range (N): x = [ 1 , 1 , 1 , 1 , 1 ] U . append(x) return U def hamiltonian (U): '''H = total hamiltonian''' H = 0 for k in range (N): D = distance_matrix(U[k]) h = action(D) H = H + h return H def pick_random_particle (printkey): n = random . randint( 0 , N - 1 ) if printkey == 1 : print \"oscillator picked at\" ,n return n def value_shifter (u,dx): u = u + dx for k in range ( len (u)): if u[k] < 0 : u[k] = Max + u[k] elif u[k] > 69 : u[k] = u[k] % Max u = np . sort(u) return u dv = 10 Kb = 1.0 T = 100 N = 20 1.2.1 Thermalization def thermalize (U,T,nruns,printkey): irun = 0 h_stor = [ 0.0 for k in range (nrun)] U_stor = [] count = 0 while irun < nrun: h_old = hamiltonian(U) n = pick_random_particle(printkey) ov = U[n] dx = random . sample( range ( - dv,dv), 5 ) U[n] = value_shifter(U[n],dx) h_new = hamiltonian(U) dh = h_new - h_old if printkey == 1 : print \"=================\" , irun, \"====================\" if dh < 0 : count = count + 1 if printkey == 1 : print irun, \"Energy decreased! It is accepted!\" ,dh if printkey == 3 : print \"change made at\" ,n,dx, \"Participant\" ,U[n] if printkey == 1 : print irun, \"old conf. = \" , ov, \"replaced by\" ,U[n] h_stor[irun] = h_new U_stor . append(U) else : if printkey == 1 : print irun, \"Energy increased!\" ,dh frac = math . exp( - dh / (Kb * T)) b = random . uniform( 0.0 , 1.0 ) if printkey == 1 : print \"frac =\" ,frac, \"b =\" ,b if b < frac: if printkey == 1 : print irun, \"You Lucky\" h_stor[irun] = h_new U_stor . append(U) else : if printkey == 1 : print irun, \"Loser\" if printkey == 1 : print \"config. restablished at\" , n, \":\" ,U[n], \"by\" ,U[n] - dx, \"which is old\" ,ov U[n] = U[n] - dx h_stor[irun] = h_old if U[n][ 0 ] != ov[ 0 ] : if printkey == 1 : print \"Warning! config changed at\" ,n, \":\" , ov, \" replaced by\" , U[n] if printkey == 1 : print \"---------------info-closed----------------\" if printkey == 1 : print \"\" if printkey == 2 : print irun, h_stor[irun] irun = irun + 1 success = (count / float (nrun)) * 100 if printkey == 1 : print \"=======================================================================\" print \"Success=\" ,success, \"%\" return h_stor,U_stor Test mode U = hot_start() #U = cold_start() nrun = 5 H_stor,U_stor = thermalize(U,T,nrun, 1 ) oscillator picked at 4 ================= 0 ==================== 0 Energy increased! 14490.7437085 frac = 1.16815288879e-63 b = 0.635801285104 0 Loser config. restablished at 4 : [ 4 30 51 55 57] by [ 9 25 42 48 59] which is old [ 9 25 46 50 53] ---------------info-closed---------------- oscillator picked at 4 ================= 1 ==================== 1 Energy decreased! It is accepted! -7019.6507091 1 old conf. = [ 9 25 42 48 59] replaced by [ 7 32 41 50 52] Warning! config changed at 4 : [ 9 25 42 48 59] replaced by [ 7 32 41 50 52] ---------------info-closed---------------- oscillator picked at 15 ================= 2 ==================== 2 Energy increased! 3885.6261383 frac = 1.33333750064e-17 b = 0.413681262571 2 Loser config. restablished at 15 : [30 44 56 61 62] by [38 42 52 67 65] which is old [38 42 57 62 65] ---------------info-closed---------------- oscillator picked at 12 ================= 3 ==================== 3 Energy decreased! It is accepted! -351.113417797 3 old conf. = [20 26 43 44 46] replaced by [14 19 35 35 41] Warning! config changed at 12 : [20 26 43 44 46] replaced by [14 19 35 35 41] ---------------info-closed---------------- oscillator picked at 4 ================= 4 ==================== 4 Energy decreased! It is accepted! -788.430394958 4 old conf. = [ 7 32 41 50 52] replaced by [16 27 45 50 60] Warning! config changed at 4 : [ 7 32 41 50 52] replaced by [16 27 45 50 60] ---------------info-closed---------------- ======================================================================= Success= 60.0 % Thermal mode U = hot_start() #U = cold_start() nrun = 10000 H_stor,U_stor = thermalize(U,T,nrun, 0 ) Success= 39.32 % X = np . arange( 0 , len (H_stor), 1 ) plt . figure( 1 ) plt . grid() plt . plot(X,H_stor, \"-\" ) plt . show() num_bins = 50 plt . grid() plt . hist(H_stor,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . title( \"histogram of Energy\" ) plt . show() This provides sufficient evidence for system in thermal equilibrium. Measurement of average absolute difference def abs_diff (x): diff = abs (x[ 0 ] - x[ 1 ]) + abs (x[ 1 ] - x[ 2 ]) + abs (x[ 2 ] - x[ 3 ]) + abs (x[ 3 ] - x[ 4 ]) + abs (x[ 4 ] - x[ 0 ]) return diff ln = len (U_stor) total_abs_diff = 0 Diff = [] for k in range (ln): U = U_stor[k] for l in range (N): x = U[l] diff = abs_diff(x) Diff . append(diff) total_abs_diff = total_abs_diff + diff average_abs_diff = total_abs_diff / float (ln * N) average_abs_diff 65.200000000000003 num_bins = 50 plt . grid() plt . hist(Diff,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . title( \"histogram of absolute difference\" ) plt . show() Measurement of root mean square absolute difference def rms_diff (x): diff = math . sqrt( abs (x[ 0 ] - x[ 1 ]) ** 2 + abs (x[ 1 ] - x[ 2 ]) ** 2 + abs (x[ 2 ] - x[ 3 ]) ** 2 + abs (x[ 3 ] - x[ 4 ]) ** 2 + abs (x[ 4 ] - x[ 0 ]) ** 2 ) return diff ln = len (U_stor) total_rms_diff = 0 rms_Diff = [] for k in range (ln): U = U_stor[k] for l in range (N): x = U[l] diff = rms_diff(x) rms_Diff . append(diff) total_rms_diff = total_abs_diff + diff rms_diff = total_rms_diff / float (ln * N) rms_diff 65.200247173536098 num_bins = 50 plt . grid() plt . hist(rms_Diff,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . title( \"histogram of rms difference\" ) plt . show() 1.3. Interpretation 1.3.1. Most Probable Samples using Model -III : constrained by rms absolute difference 1.3.1.2. Generation of many samples and their actions def simulation_III (N_sample,Max): Lstor = [] Xstor = [] k = 1 while k < N_sample: x = sample_generator(Max) D = distance_matrix(x) atn = action(D) Xstor . append(x) Lstor . append(atn) k = k + 1 return Xstor,Lstor 1.3.1.3. Histogram Plot of frequencies N_sample = 100000 Xstor,Lstor = simulation_III(N_sample,Max) num_bins = 50 plt . grid() plt . hist(Lstor,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show() 1.3.1.4. Generate some sample sample_required = 100 count = 1 while count < sample_required: x = sample_generator(Max) rmsdiff = math . sqrt( abs (x[ 0 ] - x[ 1 ]) ** 2 + abs (x[ 1 ] - x[ 2 ]) ** 2 + abs (x[ 2 ] - x[ 3 ]) ** 2 + abs (x[ 3 ] - x[ 4 ]) ** 2 + abs (x[ 4 ] - x[ 0 ]) ** 2 ) D = distance_matrix(x) act = action(D) if act > 20000 and act < 40000 : '''rms_diff constraint''' if rmsdiff < 70 and rmsdiff > 50 : count = count + 1 print \"rms test passed!\" ,x,act rms test passed! [22 31 34 36 63] 23213.3113095 rms test passed! [ 7 13 35 39 50] 33691.0412054 rms test passed! [18 46 51 61 62] 31851.0262931 rms test passed! [ 1 5 24 25 48] 35954.8593645 rms test passed! [17 37 47 52 68] 37716.8213328 rms test passed! [ 4 40 46 48 56] 39837.2864565 rms test passed! [17 33 45 46 68] 36706.1095915 rms test passed! [ 7 19 29 30 60] 39387.868137 rms test passed! [21 46 58 62 67] 34223.4073232 rms test passed! [14 23 27 39 60] 32757.3684971 rms test passed! [23 25 37 54 68] 38547.9912041 rms test passed! [ 9 35 36 38 64] 37754.3796817 rms test passed! [ 1 10 12 21 51] 36992.1945171 rms test passed! [ 7 12 20 40 52] 37750.4521181 rms test passed! [ 4 11 21 24 47] 27705.7997514 rms test passed! [27 35 38 66 68] 34682.9450353 rms test passed! [ 6 21 24 41 55] 37746.4051962 rms test passed! [ 8 17 19 20 57] 33609.5413481 rms test passed! [18 37 53 60 63] 35902.0551094 rms test passed! [12 25 30 53 57] 37347.9295182 rms test passed! [18 29 30 42 63] 30143.1802676 rms test passed! [ 2 3 4 36 41] 35057.1500413 rms test passed! [ 6 11 25 29 54] 36471.4485936 rms test passed! [ 8 12 17 27 55] 35542.6805521 rms test passed! [ 7 17 23 46 53] 39238.0734485 rms test passed! [12 14 32 34 55] 31131.4580129 rms test passed! [23 37 58 59 66] 32497.4099394 rms test passed! [23 29 33 61 65] 36643.4090392 rms test passed! [17 50 59 63 65] 37862.9971437 rms test passed! [ 1 13 17 25 45] 27961.5474462 rms test passed! [ 4 20 22 28 52] 31066.9002468 rms test passed! [22 29 48 62 66] 39126.0807915 rms test passed! [ 8 13 23 24 57] 36013.5811574 rms test passed! [ 6 22 35 45 53] 36964.1644758 rms test passed! [10 43 46 50 57] 32198.1633404 rms test passed! [ 7 12 17 19 55] 34427.3319364 rms test passed! [ 5 18 21 22 53] 30579.5189984 rms test passed! [12 36 40 49 57] 30092.9129731 rms test passed! [ 5 30 37 46 49] 31432.3884298 rms test passed! [10 34 43 45 53] 27702.4591541 rms test passed! [ 8 20 24 27 58] 34328.8128515 rms test passed! [ 1 10 29 36 45] 34794.6494543 rms test passed! [20 33 55 59 63] 34829.1828679 rms test passed! [ 4 15 32 46 49] 39320.7382609 rms test passed! [21 27 29 57 63] 35672.4321882 rms test passed! [ 5 14 16 36 50] 34452.9662632 rms test passed! [19 24 37 38 66] 33699.4551243 rms test passed! [ 1 29 33 38 54] 38088.0457708 rms test passed! [ 2 15 19 29 52] 36448.0413696 rms test passed! [17 41 46 50 60] 26235.6758504 rms test passed! [10 30 33 46 54] 29716.9386516 rms test passed! [21 34 36 63 65] 37014.7064226 rms test passed! [11 12 33 39 58] 39902.175383 rms test passed! [15 38 45 51 59] 29081.1981366 rms test passed! [14 17 26 31 57] 29420.6289064 rms test passed! [ 4 21 23 39 51] 34064.8058335 rms test passed! [ 2 7 14 27 51] 39604.2500949 rms test passed! [ 6 32 36 42 57] 35736.8935702 rms test passed! [16 25 52 56 57] 35834.7766351 rms test passed! [21 30 35 52 67] 35381.8603113 rms test passed! [11 34 38 39 65] 37175.3448104 rms test passed! [ 5 41 48 50 54] 37724.6053083 rms test passed! [ 8 37 41 48 54] 31733.2784115 rms test passed! [ 3 13 14 38 50] 38760.937656 rms test passed! [ 1 28 37 47 50] 39584.096506 rms test passed! [10 18 33 38 56] 33949.2512496 rms test passed! [19 32 54 58 65] 38134.1008607 rms test passed! [15 34 52 54 60] 34393.9539868 rms test passed! [ 4 14 24 28 48] 28701.0427875 rms test passed! [12 33 39 42 59] 29968.8309813 rms test passed! [ 1 20 21 26 46] 26446.7118143 rms test passed! [ 8 47 49 53 57] 36689.9561518 rms test passed! [ 2 22 36 37 46] 30190.8172601 rms test passed! [11 16 19 21 56] 30150.4726375 rms test passed! [ 1 20 26 30 48] 30248.6617372 rms test passed! [13 18 31 32 64] 39554.5612082 rms test passed! [ 7 29 37 46 52] 32098.195124 rms test passed! [18 19 23 25 58] 25625.6222709 rms test passed! [ 6 15 17 29 57] 39523.4507506 rms test passed! [ 4 7 14 18 49] 31650.8364949 rms test passed! [ 7 22 39 43 53] 34826.1117241 rms test passed! [11 29 38 50 57] 34666.9565121 rms test passed! [ 5 13 28 31 50] 31773.0990668 rms test passed! [ 3 38 42 43 47] 29862.0314873 rms test passed! [15 26 38 48 61] 34748.3933084 rms test passed! [19 38 47 61 66] 37284.0854751 rms test passed! [ 5 36 39 47 56] 37620.6268713 rms test passed! [22 41 43 55 68] 30862.471725 rms test passed! [ 7 10 41 43 49] 37659.309241 rms test passed! [ 6 18 23 32 53] 32465.9918977 rms test passed! [10 35 37 49 61] 37556.0297617 rms test passed! [17 25 46 59 60] 38948.4392844 rms test passed! [ 4 7 12 16 51] 34486.8791996 rms test passed! [16 20 22 48 59] 36282.9282905 rms test passed! [24 50 51 56 67] 25093.575942 rms test passed! [17 38 43 62 64] 38236.4049284 rms test passed! [19 47 49 50 64] 26432.4913519 rms test passed! [ 4 25 33 40 48] 29682.6587486 rms test passed! [15 32 40 49 62] 33436.5218819 Take these samples and buy lottery! Enjoy! 1.3.2. Most Probable Samples using Model -I : without any constraint from thermalization 1.3.2.1. Calculation of action in each sample def action_I (x): act = 0.5 * ((x[ 0 ] - x[ 1 ]) ** 2 + (x[ 1 ] - x[ 2 ]) ** 2 + (x[ 2 ] - x[ 3 ]) ** 2 + (x[ 3 ] - x[ 4 ]) ** 2 ) return act 1.3.2.2. Generation of many (N_samples) samples and their actions def simulation_I (N_sample,Max): Lstor = [] Xstor = [] k = 1 while k < N_sample: x = sample_generator(Max) atn = action_I(x) Xstor . append(x) Lstor . append(atn) k = k + 1 return Xstor,Lstor 1.3.2.3. Histogram Plot of frequencies N_sample = 10000 Xstor,Lstor = simulation_I(N_sample,Max) plt . grid() plt . hist(Lstor,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show() 1.3.2.4. Generate some sample sample_required = 100 k = 1 while k < sample_required: x = sample_generator(Max) act = action_I(x) if act > 250 and act < 350 : print x,act k = k + 1 [14 27 29 43 56] 269.0 [11 21 42 48 54] 306.5 [ 3 6 9 13 35] 259.0 [ 6 20 33 37 51] 288.5 [ 8 24 27 34 52] 319.0 [10 18 22 34 55] 332.5 [ 2 14 19 34 49] 309.5 [10 23 31 35 52] 269.0 [17 37 49 59 63] 330.0 [ 8 29 43 50 52] 345.0 [ 3 10 15 30 50] 349.5 [ 7 12 22 40 52] 296.5 [ 8 12 28 42 57] 346.5 [16 19 31 35 58] 349.0 [14 36 50 51 53] 342.5 [ 1 7 18 28 49] 349.0 [21 32 34 54 55] 263.0 [15 31 45 53 56] 262.5 [20 26 42 53 64] 267.0 [ 5 13 31 33 45] 268.0 [ 5 9 20 22 42] 270.5 [11 27 32 48 53] 281.0 [11 14 21 34 53] 294.0 [10 27 43 47 50] 285.0 [22 38 50 52 68] 330.0 [13 27 30 38 55] 279.0 [ 8 13 15 26 49] 339.5 [20 24 42 53 60] 255.0 [ 7 20 38 46 48] 280.5 [25 43 45 49 63] 270.0 [21 31 51 58 62] 282.5 [19 24 26 50 59] 343.0 [16 27 46 53 61] 297.5 [14 25 37 44 62] 319.0 [ 2 16 18 39 44] 333.0 [23 29 39 48 66] 270.5 [14 24 35 48 64] 323.0 [17 32 39 56 60] 289.5 [ 8 14 21 26 48] 297.0 [ 2 6 13 29 44] 273.0 [29 33 39 42 67] 343.0 [ 2 23 30 41 46] 318.0 [12 28 29 35 50] 259.0 [11 24 32 49 54] 273.5 [ 3 6 23 36 50] 331.5 [18 29 35 50 63] 275.5 [13 36 45 48 53] 322.0 [ 2 23 34 39 44] 306.0 [26 40 41 60 63] 283.5 [20 22 24 34 58] 342.0 [11 21 37 53 60] 330.5 [28 36 58 62 64] 284.0 [26 33 54 61 64] 274.0 [25 30 53 56 58] 283.5 [27 51 53 58 60] 304.5 [ 6 15 25 30 52] 345.0 [ 5 13 18 27 50] 349.5 [ 4 15 27 42 56] 343.0 [ 6 13 16 31 49] 303.5 [ 9 32 35 42 47] 306.0 [22 42 52 59 64] 287.0 [11 36 43 44 46] 339.5 [14 16 39 40 49] 307.5 [ 7 13 31 42 48] 258.5 [12 20 33 52 57] 309.5 [13 22 36 45 57] 251.0 [ 9 19 23 36 51] 255.0 [14 21 30 48 56] 259.0 [21 29 30 45 61] 273.0 [31 34 37 38 61] 274.0 [20 26 34 55 57] 272.5 [13 35 43 48 53] 299.0 [25 38 56 64 66] 280.5 [13 24 31 35 53] 255.0 [29 39 58 59 68] 271.5 [30 32 56 65 66] 331.0 [ 8 28 29 40 53] 345.5 [ 4 22 26 32 45] 272.5 [28 53 56 61 63] 331.5 [18 24 41 52 65] 307.5 [27 37 42 64 67] 309.0 [ 3 16 27 28 45] 290.0 [13 30 46 51 53] 287.0 [ 1 18 30 40 42] 268.5 [ 3 10 21 35 49] 281.0 [12 31 39 49 61] 334.5 [17 20 34 56 58] 346.5 [ 2 15 25 44 46] 317.0 [20 39 43 55 67] 332.5 [ 4 16 31 40 51] 285.5 [ 9 30 31 40 47] 286.0 [14 17 39 48 52] 295.0 [ 8 28 41 44 48] 297.0 [ 4 18 24 31 48] 285.0 [ 5 7 18 25 46] 307.5 [ 8 24 30 39 56] 331.0 [16 29 39 52 67] 331.5 [23 24 29 39 59] 263.0 [ 2 19 32 37 46] 282.0 Take these samples and buy lottery ! Enjoy !","title":"Lottary Model"},{"location":"Montecarlo/Lotto/lotto/#lotto-dynamics-in-integer-space","text":"We find a proper model to represent the dynamics of the system in positive integer space [1 to 69] using random number generator. With this model we run Hybrid Montecarlo(HMC) algorithm to thermalize the system to determine most probable values of quantities like: average absolute difference, root mean square absolute difference and most probable absolute difference, which are helpful to determine the most probable vectors in sample space. Import some libraries import random as random import matplotlib.pyplot as plt import numpy as np from numpy import linalg as LA import math as math import pandas % matplotlib inline Maximum no in range of lottery Max = 69 This function generates 5 random samples between 1 to 65. def sample_generator (Max): x = np . sort(random . sample( range ( 1 ,Max), 5 ) ) return x","title":"Lotto Dynamics in Integer Space"},{"location":"Montecarlo/Lotto/lotto/#11-construction-of-a-toy-model","text":"For example, considering range of sample equal to 50, among millions of sample one gets: mean of first no : 5 mean of second no :15 mean of third no :25 mean of fourth no:35 mean of fifth no:45 We consider these mean values as equilibrium point of each oscillator. Oscillators oscillate in integer Space. Each sample of lottery is some state of oscillator. There will be total of (50x49x48x47x46/5!) states. We can choose best modle of oscillator by making a study of correlation cofficients among digits in each sample. Here we have proposed 3 model where model I and II are special case of Model III.","title":"1.1.  Construction of a Toy Model"},{"location":"Montecarlo/Lotto/lotto/#111-model-selection-with-proper-action","text":"Let us define a skewsymmetric distance matrix by taking difference between digits in sample as the matrix elements. There is one distance matrix per sample. $$D_{ij} = (x_{i}-x_{j})$$ ie. $$D = \\left( \\begin{array}{ccc} 0 & \\color{blue}{(x_{1}-x_{2})} & (x_{1}-x_{3})& (x_{1}-x_{4}) & (x_{1}-x_{5}) \\ (x_{2}-x_{1}) & 0 & \\color{blue}{(x_{2}-x_{3})}& (x_{2}-x_{4}) & (x_{2}-x_{5}) \\ (x_{3}-x_{1}) & (x_{3}-x_{2}) & 0& \\color{blue}{(x_{3}-x_{4})} & (x_{3}-x_{5}) \\ (x_{4}-x_{1}) & (x_{4}-x_{2}) & (x_{4}-x_{3})& 0 & \\color{blue}{(x_{4}-x_{5})} \\ \\color{blue}{(x_{5}-x_{1})} & (x_{5}-x_{2}) & (x_{5}-x_{3})& (x_{5}-x_{4}) & 0 \\ \\end{array} \\right)$$ Taking (N = 5) oscillators with flexibility between seperation of numbers as spring constant (K=1). Simple model of Action can be defined by taking single updiagonal terms only as:","title":"1.1.1.   Model Selection with Proper Action"},{"location":"Montecarlo/Lotto/lotto/#model-i-linear","text":"$$ L = \\frac{1}{2}K[(x_1 -x_2)^2 +(x_2 -x_3)^2 + (x_3 -x_4)^2 + (x_4 -x_5)^2 ] $$","title":"Model-I (Linear)"},{"location":"Montecarlo/Lotto/lotto/#model-ii-linear-periodic","text":"$$ L = \\frac{1}{2}K[(x_1 -x_2)^2 +(x_2 -x_3)^2 + (x_3 -x_4)^2 + (x_4 -x_5)^2 + (x_5 -x_1)^2 ] $$ Considering effect of all terms in distance matrix one can define new model of Action as:","title":"Model-II (Linear &amp;Periodic)"},{"location":"Montecarlo/Lotto/lotto/#model-iii-quadratic-periodic","text":"$$L = Tr(D^{\\dagger}KD)$$ $\\color{red}{Warning:}$ Since each digit are not equally correlated to eachother, this form of action should be corrected by choosing appropriate spring constant for crossed terms like $x_{3}x_{4}$. K is another matrix(or tensor) of spring constants which can be determined by finding correlation cofficients between digits within several samples.","title":"Model - III (Quadratic &amp; Periodic)"},{"location":"Montecarlo/Lotto/lotto/#112-study-of-distance-matrix","text":"We can make skew symmetric matrix into traceless symmetric matrix by taking absolute value of each elements. def distance_matrix (x): D = [[ 0.0 for k in range ( 5 )] for l in range ( 5 )] for k in range ( 5 ): for l in range ( 5 ): D[k][l] = abs (x[k] - x[l]) return D Lets have a look of distance matrix: distance_matrix(sample_generator(Max)) [[0, 9, 24, 39, 44], [9, 0, 15, 30, 35], [24, 15, 0, 15, 20], [39, 30, 15, 0, 5], [44, 35, 20, 5, 0]] We can generate a small bucket of 9 distance matices to visualize distribution of distances. M = [np . array([[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 0 , 0 ]]) for k in range ( 9 )] for k in range ( 9 ): M[k] = np . array(distance_matrix(x = sample_generator(Max))) for k in range ( 9 ): plt . subplot( 3 , 3 ,k + 1 ) plt . imshow(M[ 0 ], interpolation = 'nearest' , cmap = plt . cm . ocean, extent = ( 0.5 , 10.5 , 0.5 , 10.5 )) plt . colorbar() plt . show()","title":"1.1.2. Study of Distance Matrix"},{"location":"Montecarlo/Lotto/lotto/#1121-enasmble-of-distance-matrices","text":"wstor_III = [] for k in range ( 10000 ): x = sample_generator(Max) A = distance_matrix(x) w, v = LA . eig(A) #print max(w) #for l in range(5): #wstor.append(abs(w[l])) wstor_III . append( max (w)) plt . scatter(k, max (w)) Principle component of eigen values helps us to predict better model by dominancy of principle direction.","title":"1.1.2.1 Enasmble of Distance matrices"},{"location":"Montecarlo/Lotto/lotto/#principle-component-analysis-model-iii","text":"num_bins = 100 plt . grid() plt . title( \"Plot of feequency of principle component in eigen values\" ) plt . hist(wstor_III,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show()","title":"Principle Component Analysis - Model -III"},{"location":"Montecarlo/Lotto/lotto/#principle-component-analysis-model-ii","text":"In model - II , distance matrix becomes diagonal matrix and hence eigen values are diagonal elements themselves. We can plot distribution of largest difference. wstor_II = [] for k in range ( 10000 ): x = sample_generator(Max) A = distance_matrix(x) w = max (A[ 0 ][ 1 ],A[ 1 ][ 2 ],A[ 2 ][ 3 ],A[ 3 ][ 4 ],A[ 4 ][ 0 ]) wstor_II . append(w) plt . scatter(k,w) num_bins = 100 plt . grid() plt . title( \"Plot of feequency of principle component in eigen values\" ) plt . hist(wstor_II,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show() $\\color{blue}{Conclusion}$ : Most of the distance matrices have principle component around 100. Principle compont depends on all distances. Therefore other distances can not be ignored in action. New action should be defined in term of Distance matrix.","title":"Principle Component Analysis - Model - II"},{"location":"Montecarlo/Lotto/lotto/#113-statistical-analysis-determination-of-spring-constants","text":"","title":"1.1.3. Statistical Analysis &amp; Determination of Spring Constants"},{"location":"Montecarlo/Lotto/lotto/#1131-study-of-variance-covariance-matrix-of-samples","text":"Study of Variance-Covariance help us to determine the spring constant(K) in our model which is ultimately related to the correlation coffecient. We construct Variance-Covariance Matirx by using 100 samples in the following steps: 1 . Lets construct a bag of Nbag = 1000 samples. Nbag = 1000 SampleBag = [sample_generator(Max) for k in range (Nbag)] 2 . Vectorization of 100 samples : where first digit from each sample goes to first column vector of Vec matrix etc. def vactorization (SampleBag): Vec = [[ 0 for k in range (Nbag)] for l in range ( 5 )] for l in range ( 5 ): for k in range (Nbag): Vec[l][k] = SampleBag[k][l] return np . array(Vec) SB = vactorization(SampleBag) p = 1 for l in range ( 5 ): for r in range ( 5 ): plt . subplot( 5 , 5 ,p) plt . scatter(SB[l],SB[r]) p = p + 1 plt . show() 3 . Normalization brings each column vector to have mean equal to zero which helps to visualize variance-covariance of samples. def normalization (Vec): mn = [ 0 for k in range ( 5 )] vr = [ 0 for k in range ( 5 )] rng = [ 0 for k in range ( 5 )] numVec = [[ 0 for k in range (Nbag)] for l in range ( 5 )] #Find mean and range (Maximum-minimum) of each vector for l in range ( 5 ): mn[l] = np . mean(Vec[l]) vr[l] = np . var(Vec[l]) for k in range (Nbag): numVec[l][k] = (SampleBag[k][l] - mn[l]) / (math . sqrt(vr[l] / float (Nbag))) numVec = np . array(numVec) return numVec","title":"1.1.3.1.  Study of Variance-Covariance  Matrix of samples"},{"location":"Montecarlo/Lotto/lotto/#1132a-variance-covariance-of-raw-samples","text":"Vec = vactorization(SampleBag) VCM_raw = np . cov(Vec) plt . title( \"Variance-Covariance of raw sample\" ) plt . imshow(VCM_raw, interpolation = 'nearest' , cmap = plt . cm . hot, extent = ( 0.5 , 10.5 , 0.5 , 10.5 )) plt . colorbar() plt . show()","title":"1.1.3.2.a. Variance-Covariance of Raw samples"},{"location":"Montecarlo/Lotto/lotto/#1132b-variance-covariance-of-normalized-samples-crrelation-cofficients","text":"Vec = vactorization(SampleBag) numVec = normalization(Vec) VCM_normalized = np . cov(numVec) plt . title( \"Variance-Covariance of normalized sample\" ) plt . imshow(VCM_normalized, interpolation = 'nearest' , cmap = plt . cm . hot, extent = ( 0.5 , 10.5 , 0.5 , 10.5 )) plt . colorbar() plt . show()","title":"1.1.3.2.b. Variance-Covariance of Normalized samples : Crrelation cofficients"},{"location":"Montecarlo/Lotto/lotto/#1133-spring-constants","text":"Matrix of spring constants is a symmetric tensor which can be given by square root of normalized correlation cofficients. K = np . sqrt(VCM_normalized / max (VCM_normalized[ 0 ])) K array([[ 1. , 0.79287801, 0.66542652, 0.56166262, 0.45306335], [ 0.79287801, 1. , 0.84281867, 0.69757696, 0.57453966], [ 0.66542652, 0.84281867, 1. , 0.83777405, 0.68199933], [ 0.56166262, 0.69757696, 0.83777405, 1. , 0.80502696], [ 0.45306335, 0.57453966, 0.68199933, 0.80502696, 1. ]]) $\\color{blue}{\\text{Improved Action}}: \\boxed{L = D^{\\dagger}KD}$ with K-matrix found above.","title":"1.1.3.3. Spring Constants"},{"location":"Montecarlo/Lotto/lotto/#12-montecarlo-simulation","text":"One can calculate the most probable difference vector using Hybrid Monrtecarlo Algorithm. Total energy of the system of (N=100) coupled oscillator in integer space can be expressed as: $$H = \\sum_{i=1}^{N} D^{\\dagger}KD $$ Define some useful function for thermalization def action (D): '''D = distance matrix''' '''K = spring constant tensor''' h = np . dot(D,np . dot(K,D)) htr = np . trace(h) return htr def hot_start (): '''N = total no of coupled oscillators in the system ''' '''U = bag of N oscillators''' U = [] for k in range (N): x = sample_generator(Max) U . append(x) return U def cold_start (): '''N = total no of coupled oscillators in the system ''' '''U = bag of N oscillators''' U = [] for k in range (N): x = [ 1 , 1 , 1 , 1 , 1 ] U . append(x) return U def hamiltonian (U): '''H = total hamiltonian''' H = 0 for k in range (N): D = distance_matrix(U[k]) h = action(D) H = H + h return H def pick_random_particle (printkey): n = random . randint( 0 , N - 1 ) if printkey == 1 : print \"oscillator picked at\" ,n return n def value_shifter (u,dx): u = u + dx for k in range ( len (u)): if u[k] < 0 : u[k] = Max + u[k] elif u[k] > 69 : u[k] = u[k] % Max u = np . sort(u) return u dv = 10 Kb = 1.0 T = 100 N = 20","title":"1.2 Montecarlo Simulation"},{"location":"Montecarlo/Lotto/lotto/#121-thermalization","text":"def thermalize (U,T,nruns,printkey): irun = 0 h_stor = [ 0.0 for k in range (nrun)] U_stor = [] count = 0 while irun < nrun: h_old = hamiltonian(U) n = pick_random_particle(printkey) ov = U[n] dx = random . sample( range ( - dv,dv), 5 ) U[n] = value_shifter(U[n],dx) h_new = hamiltonian(U) dh = h_new - h_old if printkey == 1 : print \"=================\" , irun, \"====================\" if dh < 0 : count = count + 1 if printkey == 1 : print irun, \"Energy decreased! It is accepted!\" ,dh if printkey == 3 : print \"change made at\" ,n,dx, \"Participant\" ,U[n] if printkey == 1 : print irun, \"old conf. = \" , ov, \"replaced by\" ,U[n] h_stor[irun] = h_new U_stor . append(U) else : if printkey == 1 : print irun, \"Energy increased!\" ,dh frac = math . exp( - dh / (Kb * T)) b = random . uniform( 0.0 , 1.0 ) if printkey == 1 : print \"frac =\" ,frac, \"b =\" ,b if b < frac: if printkey == 1 : print irun, \"You Lucky\" h_stor[irun] = h_new U_stor . append(U) else : if printkey == 1 : print irun, \"Loser\" if printkey == 1 : print \"config. restablished at\" , n, \":\" ,U[n], \"by\" ,U[n] - dx, \"which is old\" ,ov U[n] = U[n] - dx h_stor[irun] = h_old if U[n][ 0 ] != ov[ 0 ] : if printkey == 1 : print \"Warning! config changed at\" ,n, \":\" , ov, \" replaced by\" , U[n] if printkey == 1 : print \"---------------info-closed----------------\" if printkey == 1 : print \"\" if printkey == 2 : print irun, h_stor[irun] irun = irun + 1 success = (count / float (nrun)) * 100 if printkey == 1 : print \"=======================================================================\" print \"Success=\" ,success, \"%\" return h_stor,U_stor","title":"1.2.1 Thermalization"},{"location":"Montecarlo/Lotto/lotto/#test-mode","text":"U = hot_start() #U = cold_start() nrun = 5 H_stor,U_stor = thermalize(U,T,nrun, 1 ) oscillator picked at 4 ================= 0 ==================== 0 Energy increased! 14490.7437085 frac = 1.16815288879e-63 b = 0.635801285104 0 Loser config. restablished at 4 : [ 4 30 51 55 57] by [ 9 25 42 48 59] which is old [ 9 25 46 50 53] ---------------info-closed---------------- oscillator picked at 4 ================= 1 ==================== 1 Energy decreased! It is accepted! -7019.6507091 1 old conf. = [ 9 25 42 48 59] replaced by [ 7 32 41 50 52] Warning! config changed at 4 : [ 9 25 42 48 59] replaced by [ 7 32 41 50 52] ---------------info-closed---------------- oscillator picked at 15 ================= 2 ==================== 2 Energy increased! 3885.6261383 frac = 1.33333750064e-17 b = 0.413681262571 2 Loser config. restablished at 15 : [30 44 56 61 62] by [38 42 52 67 65] which is old [38 42 57 62 65] ---------------info-closed---------------- oscillator picked at 12 ================= 3 ==================== 3 Energy decreased! It is accepted! -351.113417797 3 old conf. = [20 26 43 44 46] replaced by [14 19 35 35 41] Warning! config changed at 12 : [20 26 43 44 46] replaced by [14 19 35 35 41] ---------------info-closed---------------- oscillator picked at 4 ================= 4 ==================== 4 Energy decreased! It is accepted! -788.430394958 4 old conf. = [ 7 32 41 50 52] replaced by [16 27 45 50 60] Warning! config changed at 4 : [ 7 32 41 50 52] replaced by [16 27 45 50 60] ---------------info-closed---------------- ======================================================================= Success= 60.0 %","title":"Test mode"},{"location":"Montecarlo/Lotto/lotto/#thermal-mode","text":"U = hot_start() #U = cold_start() nrun = 10000 H_stor,U_stor = thermalize(U,T,nrun, 0 ) Success= 39.32 % X = np . arange( 0 , len (H_stor), 1 ) plt . figure( 1 ) plt . grid() plt . plot(X,H_stor, \"-\" ) plt . show() num_bins = 50 plt . grid() plt . hist(H_stor,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . title( \"histogram of Energy\" ) plt . show() This provides sufficient evidence for system in thermal equilibrium.","title":"Thermal mode"},{"location":"Montecarlo/Lotto/lotto/#measurement-of-average-absolute-difference","text":"def abs_diff (x): diff = abs (x[ 0 ] - x[ 1 ]) + abs (x[ 1 ] - x[ 2 ]) + abs (x[ 2 ] - x[ 3 ]) + abs (x[ 3 ] - x[ 4 ]) + abs (x[ 4 ] - x[ 0 ]) return diff ln = len (U_stor) total_abs_diff = 0 Diff = [] for k in range (ln): U = U_stor[k] for l in range (N): x = U[l] diff = abs_diff(x) Diff . append(diff) total_abs_diff = total_abs_diff + diff average_abs_diff = total_abs_diff / float (ln * N) average_abs_diff 65.200000000000003 num_bins = 50 plt . grid() plt . hist(Diff,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . title( \"histogram of absolute difference\" ) plt . show()","title":"Measurement of average  absolute difference"},{"location":"Montecarlo/Lotto/lotto/#measurement-of-root-mean-square-absolute-difference","text":"def rms_diff (x): diff = math . sqrt( abs (x[ 0 ] - x[ 1 ]) ** 2 + abs (x[ 1 ] - x[ 2 ]) ** 2 + abs (x[ 2 ] - x[ 3 ]) ** 2 + abs (x[ 3 ] - x[ 4 ]) ** 2 + abs (x[ 4 ] - x[ 0 ]) ** 2 ) return diff ln = len (U_stor) total_rms_diff = 0 rms_Diff = [] for k in range (ln): U = U_stor[k] for l in range (N): x = U[l] diff = rms_diff(x) rms_Diff . append(diff) total_rms_diff = total_abs_diff + diff rms_diff = total_rms_diff / float (ln * N) rms_diff 65.200247173536098 num_bins = 50 plt . grid() plt . hist(rms_Diff,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . title( \"histogram of rms difference\" ) plt . show()","title":"Measurement of root mean square absolute difference"},{"location":"Montecarlo/Lotto/lotto/#13-interpretation","text":"","title":"1.3. Interpretation"},{"location":"Montecarlo/Lotto/lotto/#131-most-probable-samples-using-model-iii-constrained-by-rms-absolute-difference","text":"","title":"1.3.1. Most Probable Samples using Model -III : constrained by rms absolute difference"},{"location":"Montecarlo/Lotto/lotto/#1312-generation-of-many-samples-and-their-actions","text":"def simulation_III (N_sample,Max): Lstor = [] Xstor = [] k = 1 while k < N_sample: x = sample_generator(Max) D = distance_matrix(x) atn = action(D) Xstor . append(x) Lstor . append(atn) k = k + 1 return Xstor,Lstor","title":"1.3.1.2. Generation of many  samples and their actions"},{"location":"Montecarlo/Lotto/lotto/#1313-histogram-plot-of-frequencies","text":"N_sample = 100000 Xstor,Lstor = simulation_III(N_sample,Max) num_bins = 50 plt . grid() plt . hist(Lstor,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show()","title":"1.3.1.3. Histogram Plot of frequencies"},{"location":"Montecarlo/Lotto/lotto/#1314-generate-some-sample","text":"sample_required = 100 count = 1 while count < sample_required: x = sample_generator(Max) rmsdiff = math . sqrt( abs (x[ 0 ] - x[ 1 ]) ** 2 + abs (x[ 1 ] - x[ 2 ]) ** 2 + abs (x[ 2 ] - x[ 3 ]) ** 2 + abs (x[ 3 ] - x[ 4 ]) ** 2 + abs (x[ 4 ] - x[ 0 ]) ** 2 ) D = distance_matrix(x) act = action(D) if act > 20000 and act < 40000 : '''rms_diff constraint''' if rmsdiff < 70 and rmsdiff > 50 : count = count + 1 print \"rms test passed!\" ,x,act rms test passed! [22 31 34 36 63] 23213.3113095 rms test passed! [ 7 13 35 39 50] 33691.0412054 rms test passed! [18 46 51 61 62] 31851.0262931 rms test passed! [ 1 5 24 25 48] 35954.8593645 rms test passed! [17 37 47 52 68] 37716.8213328 rms test passed! [ 4 40 46 48 56] 39837.2864565 rms test passed! [17 33 45 46 68] 36706.1095915 rms test passed! [ 7 19 29 30 60] 39387.868137 rms test passed! [21 46 58 62 67] 34223.4073232 rms test passed! [14 23 27 39 60] 32757.3684971 rms test passed! [23 25 37 54 68] 38547.9912041 rms test passed! [ 9 35 36 38 64] 37754.3796817 rms test passed! [ 1 10 12 21 51] 36992.1945171 rms test passed! [ 7 12 20 40 52] 37750.4521181 rms test passed! [ 4 11 21 24 47] 27705.7997514 rms test passed! [27 35 38 66 68] 34682.9450353 rms test passed! [ 6 21 24 41 55] 37746.4051962 rms test passed! [ 8 17 19 20 57] 33609.5413481 rms test passed! [18 37 53 60 63] 35902.0551094 rms test passed! [12 25 30 53 57] 37347.9295182 rms test passed! [18 29 30 42 63] 30143.1802676 rms test passed! [ 2 3 4 36 41] 35057.1500413 rms test passed! [ 6 11 25 29 54] 36471.4485936 rms test passed! [ 8 12 17 27 55] 35542.6805521 rms test passed! [ 7 17 23 46 53] 39238.0734485 rms test passed! [12 14 32 34 55] 31131.4580129 rms test passed! [23 37 58 59 66] 32497.4099394 rms test passed! [23 29 33 61 65] 36643.4090392 rms test passed! [17 50 59 63 65] 37862.9971437 rms test passed! [ 1 13 17 25 45] 27961.5474462 rms test passed! [ 4 20 22 28 52] 31066.9002468 rms test passed! [22 29 48 62 66] 39126.0807915 rms test passed! [ 8 13 23 24 57] 36013.5811574 rms test passed! [ 6 22 35 45 53] 36964.1644758 rms test passed! [10 43 46 50 57] 32198.1633404 rms test passed! [ 7 12 17 19 55] 34427.3319364 rms test passed! [ 5 18 21 22 53] 30579.5189984 rms test passed! [12 36 40 49 57] 30092.9129731 rms test passed! [ 5 30 37 46 49] 31432.3884298 rms test passed! [10 34 43 45 53] 27702.4591541 rms test passed! [ 8 20 24 27 58] 34328.8128515 rms test passed! [ 1 10 29 36 45] 34794.6494543 rms test passed! [20 33 55 59 63] 34829.1828679 rms test passed! [ 4 15 32 46 49] 39320.7382609 rms test passed! [21 27 29 57 63] 35672.4321882 rms test passed! [ 5 14 16 36 50] 34452.9662632 rms test passed! [19 24 37 38 66] 33699.4551243 rms test passed! [ 1 29 33 38 54] 38088.0457708 rms test passed! [ 2 15 19 29 52] 36448.0413696 rms test passed! [17 41 46 50 60] 26235.6758504 rms test passed! [10 30 33 46 54] 29716.9386516 rms test passed! [21 34 36 63 65] 37014.7064226 rms test passed! [11 12 33 39 58] 39902.175383 rms test passed! [15 38 45 51 59] 29081.1981366 rms test passed! [14 17 26 31 57] 29420.6289064 rms test passed! [ 4 21 23 39 51] 34064.8058335 rms test passed! [ 2 7 14 27 51] 39604.2500949 rms test passed! [ 6 32 36 42 57] 35736.8935702 rms test passed! [16 25 52 56 57] 35834.7766351 rms test passed! [21 30 35 52 67] 35381.8603113 rms test passed! [11 34 38 39 65] 37175.3448104 rms test passed! [ 5 41 48 50 54] 37724.6053083 rms test passed! [ 8 37 41 48 54] 31733.2784115 rms test passed! [ 3 13 14 38 50] 38760.937656 rms test passed! [ 1 28 37 47 50] 39584.096506 rms test passed! [10 18 33 38 56] 33949.2512496 rms test passed! [19 32 54 58 65] 38134.1008607 rms test passed! [15 34 52 54 60] 34393.9539868 rms test passed! [ 4 14 24 28 48] 28701.0427875 rms test passed! [12 33 39 42 59] 29968.8309813 rms test passed! [ 1 20 21 26 46] 26446.7118143 rms test passed! [ 8 47 49 53 57] 36689.9561518 rms test passed! [ 2 22 36 37 46] 30190.8172601 rms test passed! [11 16 19 21 56] 30150.4726375 rms test passed! [ 1 20 26 30 48] 30248.6617372 rms test passed! [13 18 31 32 64] 39554.5612082 rms test passed! [ 7 29 37 46 52] 32098.195124 rms test passed! [18 19 23 25 58] 25625.6222709 rms test passed! [ 6 15 17 29 57] 39523.4507506 rms test passed! [ 4 7 14 18 49] 31650.8364949 rms test passed! [ 7 22 39 43 53] 34826.1117241 rms test passed! [11 29 38 50 57] 34666.9565121 rms test passed! [ 5 13 28 31 50] 31773.0990668 rms test passed! [ 3 38 42 43 47] 29862.0314873 rms test passed! [15 26 38 48 61] 34748.3933084 rms test passed! [19 38 47 61 66] 37284.0854751 rms test passed! [ 5 36 39 47 56] 37620.6268713 rms test passed! [22 41 43 55 68] 30862.471725 rms test passed! [ 7 10 41 43 49] 37659.309241 rms test passed! [ 6 18 23 32 53] 32465.9918977 rms test passed! [10 35 37 49 61] 37556.0297617 rms test passed! [17 25 46 59 60] 38948.4392844 rms test passed! [ 4 7 12 16 51] 34486.8791996 rms test passed! [16 20 22 48 59] 36282.9282905 rms test passed! [24 50 51 56 67] 25093.575942 rms test passed! [17 38 43 62 64] 38236.4049284 rms test passed! [19 47 49 50 64] 26432.4913519 rms test passed! [ 4 25 33 40 48] 29682.6587486 rms test passed! [15 32 40 49 62] 33436.5218819 Take these samples and buy lottery! Enjoy!","title":"1.3.1.4.  Generate some sample"},{"location":"Montecarlo/Lotto/lotto/#132-most-probable-samples-using-model-i-without-any-constraint-from-thermalization","text":"","title":"1.3.2. Most Probable Samples using Model -I : without any constraint from thermalization"},{"location":"Montecarlo/Lotto/lotto/#1321-calculation-of-action-in-each-sample","text":"def action_I (x): act = 0.5 * ((x[ 0 ] - x[ 1 ]) ** 2 + (x[ 1 ] - x[ 2 ]) ** 2 + (x[ 2 ] - x[ 3 ]) ** 2 + (x[ 3 ] - x[ 4 ]) ** 2 ) return act","title":"1.3.2.1. Calculation of action in each sample"},{"location":"Montecarlo/Lotto/lotto/#1322-generation-of-many-n_samples-samples-and-their-actions","text":"def simulation_I (N_sample,Max): Lstor = [] Xstor = [] k = 1 while k < N_sample: x = sample_generator(Max) atn = action_I(x) Xstor . append(x) Lstor . append(atn) k = k + 1 return Xstor,Lstor","title":"1.3.2.2. Generation of many (N_samples) samples and their actions"},{"location":"Montecarlo/Lotto/lotto/#1323-histogram-plot-of-frequencies","text":"N_sample = 10000 Xstor,Lstor = simulation_I(N_sample,Max) plt . grid() plt . hist(Lstor,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show()","title":"1.3.2.3. Histogram Plot of frequencies"},{"location":"Montecarlo/Lotto/lotto/#1324-generate-some-sample","text":"sample_required = 100 k = 1 while k < sample_required: x = sample_generator(Max) act = action_I(x) if act > 250 and act < 350 : print x,act k = k + 1 [14 27 29 43 56] 269.0 [11 21 42 48 54] 306.5 [ 3 6 9 13 35] 259.0 [ 6 20 33 37 51] 288.5 [ 8 24 27 34 52] 319.0 [10 18 22 34 55] 332.5 [ 2 14 19 34 49] 309.5 [10 23 31 35 52] 269.0 [17 37 49 59 63] 330.0 [ 8 29 43 50 52] 345.0 [ 3 10 15 30 50] 349.5 [ 7 12 22 40 52] 296.5 [ 8 12 28 42 57] 346.5 [16 19 31 35 58] 349.0 [14 36 50 51 53] 342.5 [ 1 7 18 28 49] 349.0 [21 32 34 54 55] 263.0 [15 31 45 53 56] 262.5 [20 26 42 53 64] 267.0 [ 5 13 31 33 45] 268.0 [ 5 9 20 22 42] 270.5 [11 27 32 48 53] 281.0 [11 14 21 34 53] 294.0 [10 27 43 47 50] 285.0 [22 38 50 52 68] 330.0 [13 27 30 38 55] 279.0 [ 8 13 15 26 49] 339.5 [20 24 42 53 60] 255.0 [ 7 20 38 46 48] 280.5 [25 43 45 49 63] 270.0 [21 31 51 58 62] 282.5 [19 24 26 50 59] 343.0 [16 27 46 53 61] 297.5 [14 25 37 44 62] 319.0 [ 2 16 18 39 44] 333.0 [23 29 39 48 66] 270.5 [14 24 35 48 64] 323.0 [17 32 39 56 60] 289.5 [ 8 14 21 26 48] 297.0 [ 2 6 13 29 44] 273.0 [29 33 39 42 67] 343.0 [ 2 23 30 41 46] 318.0 [12 28 29 35 50] 259.0 [11 24 32 49 54] 273.5 [ 3 6 23 36 50] 331.5 [18 29 35 50 63] 275.5 [13 36 45 48 53] 322.0 [ 2 23 34 39 44] 306.0 [26 40 41 60 63] 283.5 [20 22 24 34 58] 342.0 [11 21 37 53 60] 330.5 [28 36 58 62 64] 284.0 [26 33 54 61 64] 274.0 [25 30 53 56 58] 283.5 [27 51 53 58 60] 304.5 [ 6 15 25 30 52] 345.0 [ 5 13 18 27 50] 349.5 [ 4 15 27 42 56] 343.0 [ 6 13 16 31 49] 303.5 [ 9 32 35 42 47] 306.0 [22 42 52 59 64] 287.0 [11 36 43 44 46] 339.5 [14 16 39 40 49] 307.5 [ 7 13 31 42 48] 258.5 [12 20 33 52 57] 309.5 [13 22 36 45 57] 251.0 [ 9 19 23 36 51] 255.0 [14 21 30 48 56] 259.0 [21 29 30 45 61] 273.0 [31 34 37 38 61] 274.0 [20 26 34 55 57] 272.5 [13 35 43 48 53] 299.0 [25 38 56 64 66] 280.5 [13 24 31 35 53] 255.0 [29 39 58 59 68] 271.5 [30 32 56 65 66] 331.0 [ 8 28 29 40 53] 345.5 [ 4 22 26 32 45] 272.5 [28 53 56 61 63] 331.5 [18 24 41 52 65] 307.5 [27 37 42 64 67] 309.0 [ 3 16 27 28 45] 290.0 [13 30 46 51 53] 287.0 [ 1 18 30 40 42] 268.5 [ 3 10 21 35 49] 281.0 [12 31 39 49 61] 334.5 [17 20 34 56 58] 346.5 [ 2 15 25 44 46] 317.0 [20 39 43 55 67] 332.5 [ 4 16 31 40 51] 285.5 [ 9 30 31 40 47] 286.0 [14 17 39 48 52] 295.0 [ 8 28 41 44 48] 297.0 [ 4 18 24 31 48] 285.0 [ 5 7 18 25 46] 307.5 [ 8 24 30 39 56] 331.0 [16 29 39 52 67] 331.5 [23 24 29 39 59] 263.0 [ 2 19 32 37 46] 282.0 Take these samples and buy lottery ! Enjoy !","title":"1.3.2.4.  Generate some sample"},{"location":"Montecarlo/Oscillator/Oscillator/","text":"Harmonic Oscillator using HMC Import the Library '''import section''' import numpy as np import matplotlib.pyplot as plt import math as math import random as random We want to apply HMC to collection of 100 independent Harmonic Oscillator to get equilibrium configuration. Hamiltonian Hamiltonian of Harmonic Oscillator in 1D is: $$ H = \\frac{1}{2} p^{2} + \\frac{1}{2}q^{2}$$ with $$ m = 1,k = 1 $$ This function calculates the total Hamiltonian of the configuration def hamiltonian (x,p,np): '''x,p: x and p are list of position and momentum''' '''np : number of particles in the system ''' H = 0.0 for k in range (np): H = H + ((x[k] * x[k]) / 2.0 + (p[k] * p[k]) / 2.0 ) return H Generating Random Momentum In order to generate random momentum we use \"random.gauss\" def drawp (np): '''this function returns a list of random numbers''' t = [ 0.0 for k in range (np)] for k in range (np): r = random . gauss( 0.0 , 1.0 ) t[k] = r return (t) One can check whether the generated numbers are normally distributed or not by doing: N = 100000 p = [ 0.0 for k in range (N)] p = drawp(N) num_bins = 20 plt . figure( 1 ) plt . hist(p,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show() Leap Frog We will use leap frog approximation to evolve the system according to time. def leap_frog (N,dt,ix,ip,np): ''' N : number of steps to evolve dt: fraction of time ie T = dt*N ix,ip : initial position and momentum np : number of the particles in the system ''' ''' Returns x,p : final position and momentum''' x = ix p = ip k = 0 while k < N: if k == 0 : for i in range (np): p[i] = p[i] - ((dt / 2.0 ) * x[i]) elif k > 0 : if k < N - 1 : for i in range (np): x[i] = x[i] + (dt * p[i]) p[i] = p[i] - (dt * x[i]) #S1 = hamiltonian(x,p,np) #print \"k =\",k,\"S1=\",S1 elif k == N - 1 : for i in range (np): p[i] = (p[i] - (dt / 2.0 ) * x[i]) k = k + 1 return x,p HMC Here we run the HMC - simulation def HMC (np,N,dt,steps,x0): ''' np : number of particles in the system N = number of steps in Leap - Frog dt = fraction of time in Leap - Frog steps: total steps in HMC ''' xt = [ 0.0 for k in range (np)] pt = [ 0.0 for k in range (np)] p0 = drawp(np) H = [ 0.0 for k in range (steps)] S0 = hamiltonian(x0,p0,np) print \"=======>\" , 0 , \"S0=\" , S0 chain = 1 total_frac = 0.0 while chain < steps: s_stor = [ 0.0 ] xt,pt = leap_frog(N,dt,x0,p0,np) S1 = hamiltonian(xt,pt,np) frac = math . exp( - (S1 - S0)) #print frac a = min ( 1 ,frac) b = random . uniform( 0.0 , 1.0 ) if b < a: print \"=======>\" , chain, \"S1=\" ,S1,frac,a,b H[chain] = S1 x0 = xt p0 = drawp(np) S0 = hamiltonian(x0,p0,np) else : H[chain] = S0 p0 = drawp(np) chain = chain + 1 return H Run HMC Steps to run Seting Constants np = 1000 N = 1000 dt = 0.001 steps = 100 Call HMC x0 = [ 1.0 for k in range (np)] x0 = [random . uniform( 0.0 , 1.0 ) for k in range (np)] H = HMC(np,N,dt,steps,x0) =======&gt; 0 S0= 634.329642425 =======&gt; 1 S1= 634.176644431 1.1653226407 1 0.733718825241 =======&gt; 2 S1= 860.433247645 1.04820040462 1 0.118879577619 =======&gt; 3 S1= 959.0880056 1.02823941879 1 0.494715009236 =======&gt; 4 S1= 995.098781516 1.00201905305 1 0.26041376277 =======&gt; 5 S1= 1014.46067223 0.996173462387 0.996173462387 0.973534507459 =======&gt; 6 S1= 1060.1975905 1.00650260273 1 0.0433863045125 =======&gt; 7 S1= 1056.67125783 1.0046068542 1 0.318541041274 =======&gt; 8 S1= 1007.92542371 0.972470680716 0.972470680716 0.641673826227 =======&gt; 9 S1= 1019.45210409 0.999868096288 0.999868096288 0.673753652179 =======&gt; 10 S1= 1033.75761347 1.01455345167 1 0.904224474449 =======&gt; 11 S1= 1039.33277255 1.00067885822 1 0.922841618884 =======&gt; 12 S1= 977.786623826 0.969824483296 0.969824483296 0.0534599327409 =======&gt; 13 S1= 982.135607524 0.981771694716 0.981771694716 0.0888855631239 =======&gt; 14 S1= 984.434076216 1.00314168125 1 0.900050557869 =======&gt; 15 S1= 979.489618274 1.00009113341 1 0.65844667362 =======&gt; 16 S1= 971.111139684 0.999416129807 0.999416129807 0.655811347266 =======&gt; 17 S1= 968.559937229 0.988931685077 0.988931685077 0.423820846374 =======&gt; 18 S1= 1015.44100508 1.01079386585 1 0.286496247338 =======&gt; 19 S1= 1001.41694142 1.00450602184 1 0.083130176045 =======&gt; 20 S1= 960.860002507 0.990150380448 0.990150380448 0.0519649287677 =======&gt; 21 S1= 933.474638737 1.00388363176 1 0.46189851642 =======&gt; 22 S1= 934.623173003 1.00369016883 1 0.495986113076 =======&gt; 23 S1= 989.4356649 0.996338227827 0.996338227827 0.531254896848 =======&gt; 24 S1= 1025.92286005 1.00861885908 1 0.313190008068 =======&gt; 25 S1= 1013.92821481 0.99071689113 0.99071689113 0.758255203087 =======&gt; 26 S1= 984.231043708 1.00076682019 1 0.843966385214 =======&gt; 27 S1= 947.27251361 1.01126395915 1 0.583020435715 =======&gt; 28 S1= 940.456922734 1.02975887887 1 0.595715587061 =======&gt; 29 S1= 1021.02868528 1.0253436546 1 0.00374011822671 =======&gt; 30 S1= 1044.50742208 1.01629498318 1 0.879696971454 =======&gt; 31 S1= 1004.58078536 0.991459152846 0.991459152846 0.707240349329 =======&gt; 32 S1= 974.925563796 0.998420468809 0.998420468809 0.929684182116 =======&gt; 33 S1= 990.203727805 1.00391617234 1 0.698723615461 =======&gt; 34 S1= 970.184852439 0.972615104041 0.972615104041 0.568697026237 =======&gt; 35 S1= 1006.22736678 1.02654444157 1 0.852950015052 =======&gt; 36 S1= 998.92636329 0.988291037764 0.988291037764 0.379738519717 =======&gt; 37 S1= 1030.24158673 0.983339277845 0.983339277845 0.757129957835 =======&gt; 39 S1= 1025.25902821 2.57411624753e+11 1 0.0463867804879 =======&gt; 40 S1= 1014.17028424 1.00196224 1 0.43927515854 =======&gt; 41 S1= 969.658672095 0.99242843551 0.99242843551 0.607817867387 =======&gt; 42 S1= 965.791453024 0.997937568522 0.997937568522 0.208140784376 =======&gt; 43 S1= 915.270272438 0.984914926098 0.984914926098 0.0439698970697 =======&gt; 44 S1= 961.813210918 1.04321328147 1 0.219150007161 =======&gt; 45 S1= 950.972655041 0.999032011959 0.999032011959 0.469070790857 =======&gt; 46 S1= 979.203355916 1.00739610649 1 0.987271370304 =======&gt; 47 S1= 963.762907782 1.0269051626 1 0.228776920354 =======&gt; 48 S1= 949.920749247 1.00736064522 1 0.443149065727 =======&gt; 49 S1= 1021.89675351 1.02219667178 1 0.562416696674 =======&gt; 50 S1= 1045.94052152 1.01372753928 1 0.449516449873 =======&gt; 51 S1= 1022.03904161 1.00609459087 1 0.216552050456 =======&gt; 52 S1= 1008.12344917 0.986500719573 0.986500719573 0.484734159393 =======&gt; 53 S1= 983.162882167 1.00790784095 1 0.636702880429 =======&gt; 54 S1= 1013.81551942 1.01409814001 1 4.81073520403e-05 =======&gt; 55 S1= 1010.85292888 1.01025417351 1 0.149774761606 =======&gt; 56 S1= 999.558517909 1.00130374632 1 0.964433917429 =======&gt; 57 S1= 1007.70305301 0.991591621018 0.991591621018 0.441621732618 =======&gt; 58 S1= 1035.64389008 0.99519261928 0.99519261928 0.0886792040929 =======&gt; 59 S1= 1010.89736177 0.992819333052 0.992819333052 0.919392595293 =======&gt; 60 S1= 1018.43419346 1.03093518871 1 0.490427219365 =======&gt; 61 S1= 1029.3748498 1.02052172977 1 0.775699542826 =======&gt; 62 S1= 1008.38007901 0.981519448603 0.981519448603 0.103399004587 =======&gt; 63 S1= 1013.60095323 0.995815163828 0.995815163828 0.510309286351 =======&gt; 64 S1= 994.410649009 0.991837188211 0.991837188211 0.310897384492 =======&gt; 65 S1= 994.116396391 0.993409094913 0.993409094913 0.768301617641 =======&gt; 66 S1= 1006.13575458 0.989289998424 0.989289998424 0.0895708870016 =======&gt; 67 S1= 1050.91856039 0.99704078393 0.99704078393 0.121374733941 =======&gt; 68 S1= 1017.75278059 0.973890480407 0.973890480407 0.686366119542 =======&gt; 69 S1= 995.879923494 1.00767777078 1 0.735823324802 =======&gt; 70 S1= 943.442902305 0.99834110281 0.99834110281 0.55392468377 =======&gt; 71 S1= 1000.71447811 1.03263450015 1 0.251331122407 =======&gt; 72 S1= 1004.9542924 0.986986118235 0.986986118235 0.878474840287 =======&gt; 73 S1= 1006.77014848 1.00896660084 1 0.522078869728 =======&gt; 74 S1= 994.563680798 1.00299539687 1 0.484478355029 =======&gt; 75 S1= 992.464156392 1.01160947857 1 0.0726515554188 =======&gt; 76 S1= 1032.73546321 1.00979569001 1 0.135635688016 =======&gt; 82 S1= 972.617554632 516459.37774 1 0.218468658673 =======&gt; 83 S1= 954.034538674 0.988720489167 0.988720489167 0.787692132405 =======&gt; 84 S1= 987.112031092 1.00765876819 1 0.633473950464 =======&gt; 85 S1= 1017.30900049 0.987977157391 0.987977157391 0.845728433192 =======&gt; 86 S1= 1077.42941197 1.0187661378 1 0.220075666386 =======&gt; 87 S1= 1052.6648128 1.00363767186 1 0.486906416463 =======&gt; 88 S1= 1021.30595102 1.01204872528 1 0.925931423529 =======&gt; 89 S1= 997.770911129 1.0139249168 1 0.880471281482 =======&gt; 90 S1= 977.391794605 1.01080296415 1 0.00720408839598 =======&gt; 91 S1= 971.101936763 0.994794720856 0.994794720856 0.653042189832 =======&gt; 92 S1= 984.018511787 0.996881531283 0.996881531283 0.763730120442 =======&gt; 93 S1= 996.771079992 1.02931942658 1 0.982855323235 =======&gt; 94 S1= 986.597018438 0.994872537714 0.994872537714 0.81748404728 =======&gt; 95 S1= 957.950186927 0.99876353159 0.99876353159 0.19244008715 =======&gt; 96 S1= 986.873852747 1.00908608477 1 0.306752182025 =======&gt; 97 S1= 979.964652828 0.99670144889 0.99670144889 0.926651912953 =======&gt; 98 S1= 946.617639244 0.992433587915 0.992433587915 0.124414236105 =======&gt; 99 S1= 977.089862612 1.00594584499 1 0.32264646888 Plot t = [ 1.0 * k for k in range (steps)] plt . figure( 12 ) plt . scatter(t,H) plt . show()","title":"Harmonic Oscillator"},{"location":"Montecarlo/Oscillator/Oscillator/#harmonic-oscillator-using-hmc","text":"","title":"Harmonic Oscillator using HMC"},{"location":"Montecarlo/Oscillator/Oscillator/#import-the-library","text":"'''import section''' import numpy as np import matplotlib.pyplot as plt import math as math import random as random We want to apply HMC to collection of 100 independent Harmonic Oscillator to get equilibrium configuration.","title":"Import the Library"},{"location":"Montecarlo/Oscillator/Oscillator/#hamiltonian","text":"Hamiltonian of Harmonic Oscillator in 1D is: $$ H = \\frac{1}{2} p^{2} + \\frac{1}{2}q^{2}$$ with $$ m = 1,k = 1 $$ This function calculates the total Hamiltonian of the configuration def hamiltonian (x,p,np): '''x,p: x and p are list of position and momentum''' '''np : number of particles in the system ''' H = 0.0 for k in range (np): H = H + ((x[k] * x[k]) / 2.0 + (p[k] * p[k]) / 2.0 ) return H","title":"Hamiltonian"},{"location":"Montecarlo/Oscillator/Oscillator/#generating-random-momentum","text":"In order to generate random momentum we use \"random.gauss\" def drawp (np): '''this function returns a list of random numbers''' t = [ 0.0 for k in range (np)] for k in range (np): r = random . gauss( 0.0 , 1.0 ) t[k] = r return (t) One can check whether the generated numbers are normally distributed or not by doing: N = 100000 p = [ 0.0 for k in range (N)] p = drawp(N) num_bins = 20 plt . figure( 1 ) plt . hist(p,num_bins, normed = 1.0 , facecolor = 'green' , alpha = 0.5 ) plt . show()","title":"Generating Random Momentum"},{"location":"Montecarlo/Oscillator/Oscillator/#leap-frog","text":"We will use leap frog approximation to evolve the system according to time. def leap_frog (N,dt,ix,ip,np): ''' N : number of steps to evolve dt: fraction of time ie T = dt*N ix,ip : initial position and momentum np : number of the particles in the system ''' ''' Returns x,p : final position and momentum''' x = ix p = ip k = 0 while k < N: if k == 0 : for i in range (np): p[i] = p[i] - ((dt / 2.0 ) * x[i]) elif k > 0 : if k < N - 1 : for i in range (np): x[i] = x[i] + (dt * p[i]) p[i] = p[i] - (dt * x[i]) #S1 = hamiltonian(x,p,np) #print \"k =\",k,\"S1=\",S1 elif k == N - 1 : for i in range (np): p[i] = (p[i] - (dt / 2.0 ) * x[i]) k = k + 1 return x,p","title":"Leap Frog"},{"location":"Montecarlo/Oscillator/Oscillator/#hmc","text":"Here we run the HMC - simulation def HMC (np,N,dt,steps,x0): ''' np : number of particles in the system N = number of steps in Leap - Frog dt = fraction of time in Leap - Frog steps: total steps in HMC ''' xt = [ 0.0 for k in range (np)] pt = [ 0.0 for k in range (np)] p0 = drawp(np) H = [ 0.0 for k in range (steps)] S0 = hamiltonian(x0,p0,np) print \"=======>\" , 0 , \"S0=\" , S0 chain = 1 total_frac = 0.0 while chain < steps: s_stor = [ 0.0 ] xt,pt = leap_frog(N,dt,x0,p0,np) S1 = hamiltonian(xt,pt,np) frac = math . exp( - (S1 - S0)) #print frac a = min ( 1 ,frac) b = random . uniform( 0.0 , 1.0 ) if b < a: print \"=======>\" , chain, \"S1=\" ,S1,frac,a,b H[chain] = S1 x0 = xt p0 = drawp(np) S0 = hamiltonian(x0,p0,np) else : H[chain] = S0 p0 = drawp(np) chain = chain + 1 return H","title":"HMC"},{"location":"Montecarlo/Oscillator/Oscillator/#run-hmc","text":"Steps to run","title":"Run HMC"},{"location":"Montecarlo/Oscillator/Oscillator/#seting-constants","text":"np = 1000 N = 1000 dt = 0.001 steps = 100 Call HMC x0 = [ 1.0 for k in range (np)] x0 = [random . uniform( 0.0 , 1.0 ) for k in range (np)] H = HMC(np,N,dt,steps,x0) =======&gt; 0 S0= 634.329642425 =======&gt; 1 S1= 634.176644431 1.1653226407 1 0.733718825241 =======&gt; 2 S1= 860.433247645 1.04820040462 1 0.118879577619 =======&gt; 3 S1= 959.0880056 1.02823941879 1 0.494715009236 =======&gt; 4 S1= 995.098781516 1.00201905305 1 0.26041376277 =======&gt; 5 S1= 1014.46067223 0.996173462387 0.996173462387 0.973534507459 =======&gt; 6 S1= 1060.1975905 1.00650260273 1 0.0433863045125 =======&gt; 7 S1= 1056.67125783 1.0046068542 1 0.318541041274 =======&gt; 8 S1= 1007.92542371 0.972470680716 0.972470680716 0.641673826227 =======&gt; 9 S1= 1019.45210409 0.999868096288 0.999868096288 0.673753652179 =======&gt; 10 S1= 1033.75761347 1.01455345167 1 0.904224474449 =======&gt; 11 S1= 1039.33277255 1.00067885822 1 0.922841618884 =======&gt; 12 S1= 977.786623826 0.969824483296 0.969824483296 0.0534599327409 =======&gt; 13 S1= 982.135607524 0.981771694716 0.981771694716 0.0888855631239 =======&gt; 14 S1= 984.434076216 1.00314168125 1 0.900050557869 =======&gt; 15 S1= 979.489618274 1.00009113341 1 0.65844667362 =======&gt; 16 S1= 971.111139684 0.999416129807 0.999416129807 0.655811347266 =======&gt; 17 S1= 968.559937229 0.988931685077 0.988931685077 0.423820846374 =======&gt; 18 S1= 1015.44100508 1.01079386585 1 0.286496247338 =======&gt; 19 S1= 1001.41694142 1.00450602184 1 0.083130176045 =======&gt; 20 S1= 960.860002507 0.990150380448 0.990150380448 0.0519649287677 =======&gt; 21 S1= 933.474638737 1.00388363176 1 0.46189851642 =======&gt; 22 S1= 934.623173003 1.00369016883 1 0.495986113076 =======&gt; 23 S1= 989.4356649 0.996338227827 0.996338227827 0.531254896848 =======&gt; 24 S1= 1025.92286005 1.00861885908 1 0.313190008068 =======&gt; 25 S1= 1013.92821481 0.99071689113 0.99071689113 0.758255203087 =======&gt; 26 S1= 984.231043708 1.00076682019 1 0.843966385214 =======&gt; 27 S1= 947.27251361 1.01126395915 1 0.583020435715 =======&gt; 28 S1= 940.456922734 1.02975887887 1 0.595715587061 =======&gt; 29 S1= 1021.02868528 1.0253436546 1 0.00374011822671 =======&gt; 30 S1= 1044.50742208 1.01629498318 1 0.879696971454 =======&gt; 31 S1= 1004.58078536 0.991459152846 0.991459152846 0.707240349329 =======&gt; 32 S1= 974.925563796 0.998420468809 0.998420468809 0.929684182116 =======&gt; 33 S1= 990.203727805 1.00391617234 1 0.698723615461 =======&gt; 34 S1= 970.184852439 0.972615104041 0.972615104041 0.568697026237 =======&gt; 35 S1= 1006.22736678 1.02654444157 1 0.852950015052 =======&gt; 36 S1= 998.92636329 0.988291037764 0.988291037764 0.379738519717 =======&gt; 37 S1= 1030.24158673 0.983339277845 0.983339277845 0.757129957835 =======&gt; 39 S1= 1025.25902821 2.57411624753e+11 1 0.0463867804879 =======&gt; 40 S1= 1014.17028424 1.00196224 1 0.43927515854 =======&gt; 41 S1= 969.658672095 0.99242843551 0.99242843551 0.607817867387 =======&gt; 42 S1= 965.791453024 0.997937568522 0.997937568522 0.208140784376 =======&gt; 43 S1= 915.270272438 0.984914926098 0.984914926098 0.0439698970697 =======&gt; 44 S1= 961.813210918 1.04321328147 1 0.219150007161 =======&gt; 45 S1= 950.972655041 0.999032011959 0.999032011959 0.469070790857 =======&gt; 46 S1= 979.203355916 1.00739610649 1 0.987271370304 =======&gt; 47 S1= 963.762907782 1.0269051626 1 0.228776920354 =======&gt; 48 S1= 949.920749247 1.00736064522 1 0.443149065727 =======&gt; 49 S1= 1021.89675351 1.02219667178 1 0.562416696674 =======&gt; 50 S1= 1045.94052152 1.01372753928 1 0.449516449873 =======&gt; 51 S1= 1022.03904161 1.00609459087 1 0.216552050456 =======&gt; 52 S1= 1008.12344917 0.986500719573 0.986500719573 0.484734159393 =======&gt; 53 S1= 983.162882167 1.00790784095 1 0.636702880429 =======&gt; 54 S1= 1013.81551942 1.01409814001 1 4.81073520403e-05 =======&gt; 55 S1= 1010.85292888 1.01025417351 1 0.149774761606 =======&gt; 56 S1= 999.558517909 1.00130374632 1 0.964433917429 =======&gt; 57 S1= 1007.70305301 0.991591621018 0.991591621018 0.441621732618 =======&gt; 58 S1= 1035.64389008 0.99519261928 0.99519261928 0.0886792040929 =======&gt; 59 S1= 1010.89736177 0.992819333052 0.992819333052 0.919392595293 =======&gt; 60 S1= 1018.43419346 1.03093518871 1 0.490427219365 =======&gt; 61 S1= 1029.3748498 1.02052172977 1 0.775699542826 =======&gt; 62 S1= 1008.38007901 0.981519448603 0.981519448603 0.103399004587 =======&gt; 63 S1= 1013.60095323 0.995815163828 0.995815163828 0.510309286351 =======&gt; 64 S1= 994.410649009 0.991837188211 0.991837188211 0.310897384492 =======&gt; 65 S1= 994.116396391 0.993409094913 0.993409094913 0.768301617641 =======&gt; 66 S1= 1006.13575458 0.989289998424 0.989289998424 0.0895708870016 =======&gt; 67 S1= 1050.91856039 0.99704078393 0.99704078393 0.121374733941 =======&gt; 68 S1= 1017.75278059 0.973890480407 0.973890480407 0.686366119542 =======&gt; 69 S1= 995.879923494 1.00767777078 1 0.735823324802 =======&gt; 70 S1= 943.442902305 0.99834110281 0.99834110281 0.55392468377 =======&gt; 71 S1= 1000.71447811 1.03263450015 1 0.251331122407 =======&gt; 72 S1= 1004.9542924 0.986986118235 0.986986118235 0.878474840287 =======&gt; 73 S1= 1006.77014848 1.00896660084 1 0.522078869728 =======&gt; 74 S1= 994.563680798 1.00299539687 1 0.484478355029 =======&gt; 75 S1= 992.464156392 1.01160947857 1 0.0726515554188 =======&gt; 76 S1= 1032.73546321 1.00979569001 1 0.135635688016 =======&gt; 82 S1= 972.617554632 516459.37774 1 0.218468658673 =======&gt; 83 S1= 954.034538674 0.988720489167 0.988720489167 0.787692132405 =======&gt; 84 S1= 987.112031092 1.00765876819 1 0.633473950464 =======&gt; 85 S1= 1017.30900049 0.987977157391 0.987977157391 0.845728433192 =======&gt; 86 S1= 1077.42941197 1.0187661378 1 0.220075666386 =======&gt; 87 S1= 1052.6648128 1.00363767186 1 0.486906416463 =======&gt; 88 S1= 1021.30595102 1.01204872528 1 0.925931423529 =======&gt; 89 S1= 997.770911129 1.0139249168 1 0.880471281482 =======&gt; 90 S1= 977.391794605 1.01080296415 1 0.00720408839598 =======&gt; 91 S1= 971.101936763 0.994794720856 0.994794720856 0.653042189832 =======&gt; 92 S1= 984.018511787 0.996881531283 0.996881531283 0.763730120442 =======&gt; 93 S1= 996.771079992 1.02931942658 1 0.982855323235 =======&gt; 94 S1= 986.597018438 0.994872537714 0.994872537714 0.81748404728 =======&gt; 95 S1= 957.950186927 0.99876353159 0.99876353159 0.19244008715 =======&gt; 96 S1= 986.873852747 1.00908608477 1 0.306752182025 =======&gt; 97 S1= 979.964652828 0.99670144889 0.99670144889 0.926651912953 =======&gt; 98 S1= 946.617639244 0.992433587915 0.992433587915 0.124414236105 =======&gt; 99 S1= 977.089862612 1.00594584499 1 0.32264646888","title":"Seting Constants"},{"location":"Montecarlo/Oscillator/Oscillator/#plot","text":"t = [ 1.0 * k for k in range (steps)] plt . figure( 12 ) plt . scatter(t,H) plt . show()","title":"Plot"},{"location":"Montecarlo/Percolation/percol/","text":"Percolation Percolation from pylab import * from scipy.ndimage import measurements L = 100 r = rand(L,L) p = 0.4 z = r < p imshow(z, origin='lower', interpolation='nearest') colorbar() title(\"Matrix\") show() lw, num = measurements.label(z) imshow(lw, origin='lower', interpolation='nearest') colorbar() title(\"Labeled clusters\") show() b = arange(lw.max() + 1) shuffle(b) shuffledLw = b[lw] imshow(shuffledLw, origin='lower', interpolation='nearest') colorbar() title(\"Labeled clusters\") show() area = measurements.sum(z, lw, index=arange(lw.max() + 1)) areaImg = area[lw] im3 = imshow(areaImg, origin='lower', interpolation='nearest') colorbar() title(\"Clusters by area\") show() sliced = measurements.find_objects(areaImg == areaImg.max()) if(len(sliced) > 0): sliceX = sliced[0][1] sliceY = sliced[0][0] plotxlim=im3.axes.get_xlim() plotylim=im3.axes.get_ylim() plot([sliceX.start, sliceX.start, sliceX.stop, sliceX.stop, sliceX.start], \\ [sliceY.start, sliceY.stop, sliceY.stop, sliceY.start, sliceY.start], \\ color=\"red\") xlim(plotxlim) ylim(plotylim) show() Final from pylab import * from scipy.ndimage import measurements L = 100 r = rand(L,L) p = 0.4 z = r<p figure(figsize=(16,5)) subplot(1,3,1) imshow(z, origin='lower', interpolation='nearest') colorbar() title(\"Matrix\") # Show image of labeled clusters (shuffled) lw, num = measurements.label(z) subplot(1,3,2) b = arange(lw.max() + 1) # create an array of values from 0 to lw.max() + 1 shuffle(b) # shuffle this array shuffledLw = b[lw] # replace all values with values from b imshow(shuffledLw, origin='lower', interpolation='nearest') # show image clusters as labeled by a shuffled lw colorbar() title(\"Labeled clusters\") # Calculate areas subplot(1,3,3) area = measurements.sum(z, lw, index=arange(lw.max() + 1)) areaImg = area[lw] im3 = imshow(areaImg, origin='lower', interpolation='nearest') colorbar() title(\"Clusters by area\") # Bounding box sliced = measurements.find_objects(areaImg == areaImg.max()) if(len(sliced) > 0): sliceX = sliced[0][1] sliceY = sliced[0][0] plotxlim=im3.axes.get_xlim() plotylim=im3.axes.get_ylim() plot([sliceX.start, sliceX.start, sliceX.stop, sliceX.stop, sliceX.start], \\ [sliceY.start, sliceY.stop, sliceY.stop, sliceY.start, sliceY.start], \\ color=\"red\") xlim(plotxlim) ylim(plotylim) show()","title":"Percolation"},{"location":"Montecarlo/Percolation/percol/#percolation","text":"","title":"Percolation"},{"location":"Montecarlo/Percolation/percol/#percolation_1","text":"from pylab import * from scipy.ndimage import measurements L = 100 r = rand(L,L) p = 0.4 z = r < p imshow(z, origin='lower', interpolation='nearest') colorbar() title(\"Matrix\") show() lw, num = measurements.label(z) imshow(lw, origin='lower', interpolation='nearest') colorbar() title(\"Labeled clusters\") show() b = arange(lw.max() + 1) shuffle(b) shuffledLw = b[lw] imshow(shuffledLw, origin='lower', interpolation='nearest') colorbar() title(\"Labeled clusters\") show() area = measurements.sum(z, lw, index=arange(lw.max() + 1)) areaImg = area[lw] im3 = imshow(areaImg, origin='lower', interpolation='nearest') colorbar() title(\"Clusters by area\") show() sliced = measurements.find_objects(areaImg == areaImg.max()) if(len(sliced) > 0): sliceX = sliced[0][1] sliceY = sliced[0][0] plotxlim=im3.axes.get_xlim() plotylim=im3.axes.get_ylim() plot([sliceX.start, sliceX.start, sliceX.stop, sliceX.stop, sliceX.start], \\ [sliceY.start, sliceY.stop, sliceY.stop, sliceY.start, sliceY.start], \\ color=\"red\") xlim(plotxlim) ylim(plotylim) show()","title":"Percolation"},{"location":"Montecarlo/Percolation/percol/#final","text":"from pylab import * from scipy.ndimage import measurements L = 100 r = rand(L,L) p = 0.4 z = r<p figure(figsize=(16,5)) subplot(1,3,1) imshow(z, origin='lower', interpolation='nearest') colorbar() title(\"Matrix\") # Show image of labeled clusters (shuffled) lw, num = measurements.label(z) subplot(1,3,2) b = arange(lw.max() + 1) # create an array of values from 0 to lw.max() + 1 shuffle(b) # shuffle this array shuffledLw = b[lw] # replace all values with values from b imshow(shuffledLw, origin='lower', interpolation='nearest') # show image clusters as labeled by a shuffled lw colorbar() title(\"Labeled clusters\") # Calculate areas subplot(1,3,3) area = measurements.sum(z, lw, index=arange(lw.max() + 1)) areaImg = area[lw] im3 = imshow(areaImg, origin='lower', interpolation='nearest') colorbar() title(\"Clusters by area\") # Bounding box sliced = measurements.find_objects(areaImg == areaImg.max()) if(len(sliced) > 0): sliceX = sliced[0][1] sliceY = sliced[0][0] plotxlim=im3.axes.get_xlim() plotylim=im3.axes.get_ylim() plot([sliceX.start, sliceX.start, sliceX.stop, sliceX.stop, sliceX.start], \\ [sliceY.start, sliceY.stop, sliceY.stop, sliceY.start, sliceY.start], \\ color=\"red\") xlim(plotxlim) ylim(plotylim) show()","title":"Final"},{"location":"Montecarlo/RandomWalk/Rwalk/","text":"Random Walk import numpy as np import random as random import matplotlib.pyplot as plt import seaborn as sns sns . set() Random walk in one dimension Direct Implementation '''X stores 1-D coordinate''' X = [] '''T stores time coordinate''' T = [] '''starting point''' x = 0 '''length of each step''' d = 1 '''iteratefor N steps''' for t in range ( 100 ): '''Walk one step ahead''' x = x + d * random . choice([ - 1 , 1 ]) '''collect time''' T . append(t) '''collect position''' X . append(x) '''Make a plot''' plt . figure(figsize = [ 12 , 6 ]) plt . scatter(T,X,marker = '.' ) plt . plot(T,X) plt . xlabel( \"Time\" ) plt . ylabel( 'Displacement' ) plt . grid( True ) plt . show() Implement with function def walk1D (x,N,d): '''This function returns the space 'X' and time 'T' for random walk in 1D x: initial position N: total number of steps d: step length''' '''X stores 1-D coordinate''' X = [] '''T stores time coordinate''' T = [] '''iteratefor N steps''' for t in range (N): '''Walk one step ahead''' x = x + d * random . choice([ - 1 , 1 ]) '''collect time''' T . append(t) '''collect position''' X . append(x) return X,T '''Implement function to get data''' X,T = walk1D(x = 0 ,N = 100 ,d = 1 ) '''Make a plot''' plt . figure(figsize = [ 12 , 6 ]) plt . scatter(T,X,marker = '.' ) plt . plot(T,X) plt . xlabel( \"Time\" ) plt . ylabel( 'Displacement' ) plt . grid( True ) plt . show() Object Oriented Programming class Walker1D ( object ): ''' This is a class to create on dimentional walk: x0 : initial position d : step size N : number of steps in random walk ''' def __init__ ( self ,N,d,x0): self . N = N self . X = [] self . d = d self . x0 = x0 def walk1D ( self ): '''note initial position''' x = self . x0 k = 0 while k < self . N: '''Walk one step ahead''' x = x + self . d * random . choice([ - 1 , 1 ]) '''collect position''' self . X . append(x) k = k + 1 return self . X Let's generate 4 different random walks of step 1000 each X1 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() X2 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() X3 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() X4 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() T = [i for i in range ( len (X1))] import json with open ( 'data/rwalk4.json' , 'w' ) as f4: json . dump([X1,X2,X3,X4,T],f4) Let's visualize them plt . figure(figsize = [ 20 , 12 ]) plt . plot(T,X1) plt . plot(T,X2) plt . plot(T,X3) plt . plot(T,X4) plt . xlabel( \"Time\" ) plt . ylabel( 'Displacement' ) plt . grid( True ) plt . savefig( 'plot/rwalk4.pdf' ) plt . show() Random Walk in 2D Create a function to walk a single step def move2D (xi,yi): ''' This function choose a direction and walk one step in 2D ''' direction = random . choice([ 'x' , 'y' ]) if direction == 'x' : r = random . choice([ - 1 , 1 ]) if r == 1 :xf = xi + 1 else : xf = xi - 1 yf = yi if direction == 'y' : r = random . choice([ - 1 , 1 ]) if r == 1 :yf = yi + 1 else : yf = yi - 1 xf = xi return xf,yf Lets walk in 2D using above function def walk2D (N,pos): ''' This function walks N step in 2d implementing move2D ''' '''coordinate collectors''' X = [] ; Y = [] '''from where to start''' x0 = pos[ 0 ] ; y0 = pos[ 0 ] k = 0 while k < N: '''move a step''' x,y = move2D(x0,y0) '''collect X coordinate''' X . append(x) '''collect Y coordinate''' Y . append(y) '''set previous position for next step''' x0 = x y0 = y k = k + 1 return X,Y Lets create a 3 different Random walk in 2D N = 10000 U = walk2D(N,[ 0 , 0 ]) V = walk2D(N,[ 0 , 0 ]) W = walk2D(N,[ 0 , 0 ]) with open ( 'data/rwalk4.json' , 'w' ) as f: json . dump([U,V,W],f) plt . figure(figsize = [ 15 , 12 ]) plt . plot(U[ 0 ],U[ 1 ], \"-\" ) plt . plot(V[ 0 ],V[ 1 ], \"-\" ) plt . plot(W[ 0 ],W[ 1 ], \"-\" ) plt . axis([ - 100 , 100 , - 100 , 100 ]) plt . xlabel( \"x-axis\" ) plt . ylabel( \"y-axis\" ) plt . grid( True ) plt . title( \"Brownian motion in 2D\" ) plt . savefig( 'plot/rwalk2D.pdf' ) plt . show()","title":"Random Walk"},{"location":"Montecarlo/RandomWalk/Rwalk/#random-walk","text":"import numpy as np import random as random import matplotlib.pyplot as plt import seaborn as sns sns . set()","title":"Random Walk"},{"location":"Montecarlo/RandomWalk/Rwalk/#random-walk-in-one-dimension","text":"","title":"Random walk in one dimension"},{"location":"Montecarlo/RandomWalk/Rwalk/#direct-implementation","text":"'''X stores 1-D coordinate''' X = [] '''T stores time coordinate''' T = [] '''starting point''' x = 0 '''length of each step''' d = 1 '''iteratefor N steps''' for t in range ( 100 ): '''Walk one step ahead''' x = x + d * random . choice([ - 1 , 1 ]) '''collect time''' T . append(t) '''collect position''' X . append(x) '''Make a plot''' plt . figure(figsize = [ 12 , 6 ]) plt . scatter(T,X,marker = '.' ) plt . plot(T,X) plt . xlabel( \"Time\" ) plt . ylabel( 'Displacement' ) plt . grid( True ) plt . show()","title":"Direct Implementation"},{"location":"Montecarlo/RandomWalk/Rwalk/#implement-with-function","text":"def walk1D (x,N,d): '''This function returns the space 'X' and time 'T' for random walk in 1D x: initial position N: total number of steps d: step length''' '''X stores 1-D coordinate''' X = [] '''T stores time coordinate''' T = [] '''iteratefor N steps''' for t in range (N): '''Walk one step ahead''' x = x + d * random . choice([ - 1 , 1 ]) '''collect time''' T . append(t) '''collect position''' X . append(x) return X,T '''Implement function to get data''' X,T = walk1D(x = 0 ,N = 100 ,d = 1 ) '''Make a plot''' plt . figure(figsize = [ 12 , 6 ]) plt . scatter(T,X,marker = '.' ) plt . plot(T,X) plt . xlabel( \"Time\" ) plt . ylabel( 'Displacement' ) plt . grid( True ) plt . show()","title":"Implement with function"},{"location":"Montecarlo/RandomWalk/Rwalk/#object-oriented-programming","text":"class Walker1D ( object ): ''' This is a class to create on dimentional walk: x0 : initial position d : step size N : number of steps in random walk ''' def __init__ ( self ,N,d,x0): self . N = N self . X = [] self . d = d self . x0 = x0 def walk1D ( self ): '''note initial position''' x = self . x0 k = 0 while k < self . N: '''Walk one step ahead''' x = x + self . d * random . choice([ - 1 , 1 ]) '''collect position''' self . X . append(x) k = k + 1 return self . X","title":"Object Oriented Programming"},{"location":"Montecarlo/RandomWalk/Rwalk/#lets-generate-4-different-random-walks-of-step-1000-each","text":"X1 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() X2 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() X3 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() X4 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() T = [i for i in range ( len (X1))] import json with open ( 'data/rwalk4.json' , 'w' ) as f4: json . dump([X1,X2,X3,X4,T],f4)","title":"Let's generate 4 different random walks of step 1000 each"},{"location":"Montecarlo/RandomWalk/Rwalk/#lets-visualize-them","text":"plt . figure(figsize = [ 20 , 12 ]) plt . plot(T,X1) plt . plot(T,X2) plt . plot(T,X3) plt . plot(T,X4) plt . xlabel( \"Time\" ) plt . ylabel( 'Displacement' ) plt . grid( True ) plt . savefig( 'plot/rwalk4.pdf' ) plt . show()","title":"Let's visualize them"},{"location":"Montecarlo/RandomWalk/Rwalk/#random-walk-in-2d","text":"","title":"Random Walk in 2D"},{"location":"Montecarlo/RandomWalk/Rwalk/#create-a-function-to-walk-a-single-step","text":"def move2D (xi,yi): ''' This function choose a direction and walk one step in 2D ''' direction = random . choice([ 'x' , 'y' ]) if direction == 'x' : r = random . choice([ - 1 , 1 ]) if r == 1 :xf = xi + 1 else : xf = xi - 1 yf = yi if direction == 'y' : r = random . choice([ - 1 , 1 ]) if r == 1 :yf = yi + 1 else : yf = yi - 1 xf = xi return xf,yf","title":"Create a function to walk a single step"},{"location":"Montecarlo/RandomWalk/Rwalk/#lets-walk-in-2d-using-above-function","text":"def walk2D (N,pos): ''' This function walks N step in 2d implementing move2D ''' '''coordinate collectors''' X = [] ; Y = [] '''from where to start''' x0 = pos[ 0 ] ; y0 = pos[ 0 ] k = 0 while k < N: '''move a step''' x,y = move2D(x0,y0) '''collect X coordinate''' X . append(x) '''collect Y coordinate''' Y . append(y) '''set previous position for next step''' x0 = x y0 = y k = k + 1 return X,Y","title":"Lets walk in 2D using above function"},{"location":"Montecarlo/RandomWalk/Rwalk/#lets-create-a-3-different-random-walk-in-2d","text":"N = 10000 U = walk2D(N,[ 0 , 0 ]) V = walk2D(N,[ 0 , 0 ]) W = walk2D(N,[ 0 , 0 ]) with open ( 'data/rwalk4.json' , 'w' ) as f: json . dump([U,V,W],f) plt . figure(figsize = [ 15 , 12 ]) plt . plot(U[ 0 ],U[ 1 ], \"-\" ) plt . plot(V[ 0 ],V[ 1 ], \"-\" ) plt . plot(W[ 0 ],W[ 1 ], \"-\" ) plt . axis([ - 100 , 100 , - 100 , 100 ]) plt . xlabel( \"x-axis\" ) plt . ylabel( \"y-axis\" ) plt . grid( True ) plt . title( \"Brownian motion in 2D\" ) plt . savefig( 'plot/rwalk2D.pdf' ) plt . show()","title":"Lets create a 3 different Random walk in 2D"},{"location":"NatureInspired/10. CellularAutomaton/","text":"10. Cellular Automaton For full documentation visit mkdocs.org . Representation mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Operators mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Index Introduction Fundamental of Quantum States Linear Algebra Fundamental Quantum Gates -Fundamental of Quantum Circuits","title":"10. Cellular Automaton"},{"location":"NatureInspired/10. CellularAutomaton/#10-cellular-automaton","text":"For full documentation visit mkdocs.org .","title":"10. Cellular Automaton"},{"location":"NatureInspired/10. CellularAutomaton/#representation","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Representation"},{"location":"NatureInspired/10. CellularAutomaton/#operators","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Operators"},{"location":"NatureInspired/10. CellularAutomaton/#index","text":"Introduction Fundamental of Quantum States Linear Algebra Fundamental Quantum Gates -Fundamental of Quantum Circuits","title":"Index"},{"location":"NumericalMethods/Laplace/laplace/","text":"Laplace Equation Some Keybord Shortcut: Example markdown file are found at: https://wakari.io/notebook/Lecture_3_Scipy.ipynb We want to solve Laplace equation both analytically and Computationally. Laplace equation in 2D is : $$\\frac{d^2U}{dx^2} + \\frac{d^2U}{dy^2} = 0$$ Analytic Solution By considering $$U(x,y) = X(x)Y(y)$$ one can solve the equation to get analytic solution using periodic boundary conditions $$U(x,y) = \\sum_{n=1}^{\\infty}E_{n} \\sin \\frac{n\\pi x}{L}\\sinh\\frac{n\\pi y}{L}$$ Where $E_n$ is a constant to be set by further boundary condition. Computational Method There are two methods Method of finite Difference We divide the entire square in to the lattice with equal spacing $\\triangle$ in both in the x and y directions. The x and y variables are now discrete: $$x = x_o + i\\triangle$$; $$y = y_o + i\\triangle$$; Where, $i,j = 0,N_{max} = L/D$ We represent the potential by the arrey $U(N_{Max},N_{Max})$. Finite Difference Algorithm $$U(i,j) = \\frac{1}{4}[U(i+1,j)+ U(i-1,j) + U(i,j+1) + U(i,j-1)]$$ Boundary Conditions $$U(i,N_{max}) = 100,$$ (top) $$U(1,j) = 0,$$ (left) $$U(N_{max},j) = 0,$$ (right) $$U(i,1) = 0,$$ (bottom) We define a function to control boundary conditions. Coding import numpy as np from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt import random '''constants''' N = 100 # Number of lattice points Nitr = 1000 # Number of iterations def fun (k): if k == 0 : return 1 else : return 0 Initiate list to hold 2D array of U U = [[ 0.0 for x in range (N)] for y in range (N)] Now we want to impose boundary conditions def boundary_conditions (U): for i in range (N): U[i][N - 1 ] = 100.0 for j in range (N): U[ 0 ][j] = 0.0 for j in range (N): U[N - 1 ][j] = 0.0 for i in range (N): U[i][ 0 ] = 0.0 return U Now we iterate with this begining configurations: itr = 0 boundary_conditions(U) while itr < Nitr: for i in range (N): for j in range (N): U[i][j] = ( 0.25 ) * (U[(i + 1 ) % N][j] + U[(i - 1 ) + (fun(i) * N)][j] + U[i][(j + 1 ) % N] + U[i][(j - 1 ) + (fun(j) * N)]) boundary_conditions(U) itr = itr + 1 #print U def val (i,j): return U[i][j] fig = plt . figure() ax = fig . add_subplot( 111 , projection = '3d' ) x = y = np . arange( 0 , N, 1 ) X, Y = np . meshgrid(x, y) ax . set_xlabel( 'X Label' ) ax . set_ylabel( 'Y Label' ) ax . set_zlabel( 'Z Label' ) zs = np . array([val(x,y) for x,y in zip (np . ravel(X), np . ravel(Y))]) Z = zs . reshape(X . shape) ax . plot_surface(X, Y, Z) plt . show()","title":"Laplace"},{"location":"NumericalMethods/Laplace/laplace/#laplace-equation","text":"","title":"Laplace Equation"},{"location":"NumericalMethods/Laplace/laplace/#some-keybord-shortcut","text":"Example markdown file are found at: https://wakari.io/notebook/Lecture_3_Scipy.ipynb We want to solve Laplace equation both analytically and Computationally. Laplace equation in 2D is : $$\\frac{d^2U}{dx^2} + \\frac{d^2U}{dy^2} = 0$$","title":"Some Keybord Shortcut:"},{"location":"NumericalMethods/Laplace/laplace/#analytic-solution","text":"By considering $$U(x,y) = X(x)Y(y)$$ one can solve the equation to get analytic solution using periodic boundary conditions $$U(x,y) = \\sum_{n=1}^{\\infty}E_{n} \\sin \\frac{n\\pi x}{L}\\sinh\\frac{n\\pi y}{L}$$ Where $E_n$ is a constant to be set by further boundary condition.","title":"Analytic Solution"},{"location":"NumericalMethods/Laplace/laplace/#computational-method","text":"There are two methods","title":"Computational Method"},{"location":"NumericalMethods/Laplace/laplace/#method-of-finite-difference","text":"We divide the entire square in to the lattice with equal spacing $\\triangle$ in both in the x and y directions. The x and y variables are now discrete: $$x = x_o + i\\triangle$$; $$y = y_o + i\\triangle$$; Where, $i,j = 0,N_{max} = L/D$ We represent the potential by the arrey $U(N_{Max},N_{Max})$.","title":"Method of finite Difference"},{"location":"NumericalMethods/Laplace/laplace/#finite-difference-algorithm","text":"$$U(i,j) = \\frac{1}{4}[U(i+1,j)+ U(i-1,j) + U(i,j+1) + U(i,j-1)]$$","title":"Finite Difference Algorithm"},{"location":"NumericalMethods/Laplace/laplace/#boundary-conditions","text":"$$U(i,N_{max}) = 100,$$ (top) $$U(1,j) = 0,$$ (left) $$U(N_{max},j) = 0,$$ (right) $$U(i,1) = 0,$$ (bottom) We define a function to control boundary conditions.","title":"Boundary Conditions"},{"location":"NumericalMethods/Laplace/laplace/#coding","text":"import numpy as np from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt import random '''constants''' N = 100 # Number of lattice points Nitr = 1000 # Number of iterations def fun (k): if k == 0 : return 1 else : return 0 Initiate list to hold 2D array of U U = [[ 0.0 for x in range (N)] for y in range (N)] Now we want to impose boundary conditions def boundary_conditions (U): for i in range (N): U[i][N - 1 ] = 100.0 for j in range (N): U[ 0 ][j] = 0.0 for j in range (N): U[N - 1 ][j] = 0.0 for i in range (N): U[i][ 0 ] = 0.0 return U Now we iterate with this begining configurations: itr = 0 boundary_conditions(U) while itr < Nitr: for i in range (N): for j in range (N): U[i][j] = ( 0.25 ) * (U[(i + 1 ) % N][j] + U[(i - 1 ) + (fun(i) * N)][j] + U[i][(j + 1 ) % N] + U[i][(j - 1 ) + (fun(j) * N)]) boundary_conditions(U) itr = itr + 1 #print U def val (i,j): return U[i][j] fig = plt . figure() ax = fig . add_subplot( 111 , projection = '3d' ) x = y = np . arange( 0 , N, 1 ) X, Y = np . meshgrid(x, y) ax . set_xlabel( 'X Label' ) ax . set_ylabel( 'Y Label' ) ax . set_zlabel( 'Z Label' ) zs = np . array([val(x,y) for x,y in zip (np . ravel(X), np . ravel(Y))]) Z = zs . reshape(X . shape) ax . plot_surface(X, Y, Z) plt . show()","title":"Coding"},{"location":"NumericalMethods/intro/Numerical-Methods/","text":"Numerical Methods: Integration Differential Equations Integration source import numpy as np from scipy.integrate import quad, dblquad, tplquad $$ y = mx +c$$ def f (x): return 5 * x + 4 x_lower = 0 # the lower limit of x x_upper = 1 # the upper limit of x val, abserr = quad(f, x_lower, x_upper) print ( \"integral value =\" , val, \", absolute error =\" , abserr) integral value = 6.499999999999999 , absolute error = 7.216449660063516e-14 Bessel function from scipy.special import jn, yn, jn_zeros, yn_zeros def integrand (x, n): \"\"\" Bessel function of first kind and order n. \"\"\" return jn(n, x) x_lower = 0 # the lower limit of x x_upper = 10 # the upper limit of x val, abserr = quad(integrand, x_lower, x_upper, args = ( 3 ,)) print (val, abserr) 0.7366751370811073 9.389126882496403e-13 Gaussian function val, abserr = quad( lambda x: np . exp( - x ** 2 ), - 5.0 , 5.0 ) print ( \"numerical =\" , val, abserr) analytical = np . sqrt(np . pi) print ( \"analytical =\" , analytical) numerical = 1.7724538509027912 4.6261378229003154e-14 analytical = 1.7724538509055159 def integrand (x, y): return np . exp( - x ** 2 - y ** 2 ) x_lower = 0 x_upper = 10 y_lower = 0 y_upper = 10 val, abserr = dblquad(integrand, x_lower, x_upper,\\ lambda x : y_lower, lambda x: y_upper) print (val, abserr) 0.7853981633974476 1.3753098510218528e-08 Ordinary Differential Equations Source Odent Source from scipy.integrate import odeint, ode def dy (y, t, zeta, w0): \"\"\" The right-hand side of the damped oscillator ODE \"\"\" x, p = y[ 0 ], y[ 1 ] dx = p dp = - 2 * zeta * w0 * p - w0 ** 2 * x return [dx, dp] # initial state: y0 = [ 1.0 , 0.0 ] # time coodinate to solve the ODE for t = np . linspace( 0 , 10 , 1000 ) w0 = 2 * np . pi * 1.0 # solve the ODE problem for three different values of the damping ratio y1 = odeint(dy, y0, t, args = ( 0.0 , w0)) # undamped y2 = odeint(dy, y0, t, args = ( 0.2 , w0)) # under damped y3 = odeint(dy, y0, t, args = ( 1.0 , w0)) # critial damping y4 = odeint(dy, y0, t, args = ( 5.0 , w0)) # over damped plt . figure(figsize = [ 10 , 8 ]) plt . plot(t, y1[:, 0 ], 'k' , label = \"undamped\" , linewidth = 0.25 ) plt . plot(t, y2[:, 0 ], 'r' , label = \"under damped\" ) plt . plot(t, y3[:, 0 ], 'b' , label = r\"critical damping\" ) plt . plot(t, y4[:, 0 ], 'g' , label = \"over damped\" ) plt . legend(); Partial Differential Equations PDE : Eliptic Equation (Laplace Euation) $$ \\nabla^{2} u + c f(u) = 0 $$ $$\\frac{\\partial^{2}u}{\\partial^{2}x} + \\frac{\\partial^{2}u}{\\partial^{2}x} + cf(u) = 0$$ for $c=1, f(u)=0$ it becomes Laplace Equation Using Above lattice of finite difference: $$\\large{u_{i\u22121,j}+u_{i+1,j} + u_{i,j\u22121} + u{i,j+1} \u2212 4u_{i,j}+cf(u_{i,j})=0}$$ $$u_{i,j}=0; \\forall u \\in \u2202\u03a9$$ for 4 by 4 lattice view matrices here: source Problem Type : Solve $$\\large{Ax = b}$$ Implementation of Least square methods to solve a $Ax = b$ problem as a optimization problem % matplotlib inline import matplotlib.pyplot as plt import numpy as np from scipy.optimize import least_squares from scipy.sparse import coo_matrix import seaborn as sns sns . set() n = 100 c = 1 def f (u): return u ** 3 def f_prime (u): return 3 * u ** 2 Prepare the lattice def fun (u, n,f, f_prime,c, ** kwargs): v = np . zeros((n + 2 , n + 2 )) #buttom value = 1 v[n + 1 ,:] = 1 # top value = 1 #v[0,:] = 1 # center value = 1 #v[int(n/2),int(n/2)] = 1 u = u . reshape((n, n)) v[ 1 : - 1 , 1 : - 1 ] = u y = v[: - 2 , 1 : - 1 ] + v[ 2 :, 1 : - 1 ] + \\ v[ 1 : - 1 , : - 2 ] + v[ 1 : - 1 , 2 :] - \\ 4 * u + c * f(u) return y . ravel() Prepare Jacobians def compute_jac_indices (n): i = np . arange(n) jj, ii = np . meshgrid(i, i) ii = ii . ravel() jj = jj . ravel() ij = np . arange(n ** 2 ) jac_rows = [ij] jac_cols = [ij] mask = ii > 0 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask - n) mask = ii < n - 1 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask + n) mask = jj > 0 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask - 1 ) mask = jj < n - 1 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask + 1 ) return np . hstack(jac_rows), np . hstack(jac_cols) jac_rows, jac_cols = compute_jac_indices(n) jac_rows, jac_cols (array([ 0, 1, 2, ..., 9996, 9997, 9998]), array([ 0, 1, 2, ..., 9997, 9998, 9999])) def jac (u, n,f, f_prime,c, jac_rows = None , jac_cols = None ): jac_values = np . ones_like(jac_cols, dtype = float ) jac_values[:n ** 2 ] = - 4 + c * f_prime(u) return coo_matrix((jac_values, (jac_rows, jac_cols)), shape = (n ** 2 , n ** 2 )) u0 = np . ones(n ** 2 ) * 0.5 Optimization: Least Square res_1 = least_squares(fun, u0, jac = jac, gtol = 1e-3 , args = (n,f, f_prime,c),\\ kwargs = { 'jac_rows' : jac_rows, 'jac_cols' : jac_cols}, verbose = 1 ) `gtol` termination condition is satisfied. Function evaluations 738, initial cost 1.1562e+02, final cost 6.4462e-01, first-order optimality 9.38e-04. Returned quantities after solution res_1 . x . shape (10000,) res_1 . x array([0.00622038, 0.01236634, 0.01833963, ..., 0.01834064, 0.01236645, 0.00622026]) res_1 . fun array([-0.00014825, -0.00029118, -0.00041394, ..., -0.000414 , -0.00029121, -0.00014826]) res_1 . fun . shape (10000,) res_1 . jac &lt;10000x10000 sparse matrix of type '&lt;class 'numpy.float64'&gt;' with 49600 stored elements in Compressed Sparse Row format&gt; Plot the solutions plt . figure(figsize = ( 16 , 5 )) plt . subplot( 131 ) plt . plot(res_1 . x) plt . subplot( 132 ) plt . imshow(res_1 . x . reshape((n, n)),\\ cmap = 'coolwarm' ,\\ vmin =- max ( abs (res_1 . x)),\\ vmax = max ( abs (res_1 . x))) plt . colorbar(use_gridspec = True ,\\ fraction = 0.046 ,\\ pad = 0.04 ) plt . subplot( 133 ) plt . plot(res_1 . fun) plt . tight_layout() References: http://folk.ntnu.no/leifh/teaching/tkt4140/._main000.html http://folk.ntnu.no/leifh/teaching/tkt4140/._main055.html https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares","title":"Introduction"},{"location":"NumericalMethods/intro/Numerical-Methods/#numerical-methods","text":"Integration Differential Equations","title":"Numerical Methods:"},{"location":"NumericalMethods/intro/Numerical-Methods/#integration-source","text":"import numpy as np from scipy.integrate import quad, dblquad, tplquad $$ y = mx +c$$ def f (x): return 5 * x + 4 x_lower = 0 # the lower limit of x x_upper = 1 # the upper limit of x val, abserr = quad(f, x_lower, x_upper) print ( \"integral value =\" , val, \", absolute error =\" , abserr) integral value = 6.499999999999999 , absolute error = 7.216449660063516e-14","title":"Integration source"},{"location":"NumericalMethods/intro/Numerical-Methods/#bessel-function","text":"from scipy.special import jn, yn, jn_zeros, yn_zeros def integrand (x, n): \"\"\" Bessel function of first kind and order n. \"\"\" return jn(n, x) x_lower = 0 # the lower limit of x x_upper = 10 # the upper limit of x val, abserr = quad(integrand, x_lower, x_upper, args = ( 3 ,)) print (val, abserr) 0.7366751370811073 9.389126882496403e-13","title":"Bessel function"},{"location":"NumericalMethods/intro/Numerical-Methods/#gaussian-function","text":"val, abserr = quad( lambda x: np . exp( - x ** 2 ), - 5.0 , 5.0 ) print ( \"numerical =\" , val, abserr) analytical = np . sqrt(np . pi) print ( \"analytical =\" , analytical) numerical = 1.7724538509027912 4.6261378229003154e-14 analytical = 1.7724538509055159 def integrand (x, y): return np . exp( - x ** 2 - y ** 2 ) x_lower = 0 x_upper = 10 y_lower = 0 y_upper = 10 val, abserr = dblquad(integrand, x_lower, x_upper,\\ lambda x : y_lower, lambda x: y_upper) print (val, abserr) 0.7853981633974476 1.3753098510218528e-08","title":"Gaussian function"},{"location":"NumericalMethods/intro/Numerical-Methods/#ordinary-differential-equations-source","text":"Odent Source from scipy.integrate import odeint, ode def dy (y, t, zeta, w0): \"\"\" The right-hand side of the damped oscillator ODE \"\"\" x, p = y[ 0 ], y[ 1 ] dx = p dp = - 2 * zeta * w0 * p - w0 ** 2 * x return [dx, dp] # initial state: y0 = [ 1.0 , 0.0 ] # time coodinate to solve the ODE for t = np . linspace( 0 , 10 , 1000 ) w0 = 2 * np . pi * 1.0 # solve the ODE problem for three different values of the damping ratio y1 = odeint(dy, y0, t, args = ( 0.0 , w0)) # undamped y2 = odeint(dy, y0, t, args = ( 0.2 , w0)) # under damped y3 = odeint(dy, y0, t, args = ( 1.0 , w0)) # critial damping y4 = odeint(dy, y0, t, args = ( 5.0 , w0)) # over damped plt . figure(figsize = [ 10 , 8 ]) plt . plot(t, y1[:, 0 ], 'k' , label = \"undamped\" , linewidth = 0.25 ) plt . plot(t, y2[:, 0 ], 'r' , label = \"under damped\" ) plt . plot(t, y3[:, 0 ], 'b' , label = r\"critical damping\" ) plt . plot(t, y4[:, 0 ], 'g' , label = \"over damped\" ) plt . legend();","title":"Ordinary Differential Equations Source"},{"location":"NumericalMethods/intro/Numerical-Methods/#partial-differential-equations","text":"","title":"Partial Differential Equations"},{"location":"NumericalMethods/intro/Numerical-Methods/#pde-eliptic-equation-laplace-euation","text":"$$ \\nabla^{2} u + c f(u) = 0 $$ $$\\frac{\\partial^{2}u}{\\partial^{2}x} + \\frac{\\partial^{2}u}{\\partial^{2}x} + cf(u) = 0$$ for $c=1, f(u)=0$ it becomes Laplace Equation Using Above lattice of finite difference: $$\\large{u_{i\u22121,j}+u_{i+1,j} + u_{i,j\u22121} + u{i,j+1} \u2212 4u_{i,j}+cf(u_{i,j})=0}$$ $$u_{i,j}=0; \\forall u \\in \u2202\u03a9$$ for 4 by 4 lattice view matrices here: source Problem Type : Solve $$\\large{Ax = b}$$","title":"PDE : Eliptic Equation (Laplace Euation)"},{"location":"NumericalMethods/intro/Numerical-Methods/#implementation-of-least-square-methods-to-solve-a-ax-b-problem-as-a-optimization-problem","text":"% matplotlib inline import matplotlib.pyplot as plt import numpy as np from scipy.optimize import least_squares from scipy.sparse import coo_matrix import seaborn as sns sns . set() n = 100 c = 1 def f (u): return u ** 3 def f_prime (u): return 3 * u ** 2","title":"Implementation of Least square methods to solve a $Ax = b$ problem as a optimization problem"},{"location":"NumericalMethods/intro/Numerical-Methods/#prepare-the-lattice","text":"def fun (u, n,f, f_prime,c, ** kwargs): v = np . zeros((n + 2 , n + 2 )) #buttom value = 1 v[n + 1 ,:] = 1 # top value = 1 #v[0,:] = 1 # center value = 1 #v[int(n/2),int(n/2)] = 1 u = u . reshape((n, n)) v[ 1 : - 1 , 1 : - 1 ] = u y = v[: - 2 , 1 : - 1 ] + v[ 2 :, 1 : - 1 ] + \\ v[ 1 : - 1 , : - 2 ] + v[ 1 : - 1 , 2 :] - \\ 4 * u + c * f(u) return y . ravel()","title":"Prepare the lattice"},{"location":"NumericalMethods/intro/Numerical-Methods/#prepare-jacobians","text":"def compute_jac_indices (n): i = np . arange(n) jj, ii = np . meshgrid(i, i) ii = ii . ravel() jj = jj . ravel() ij = np . arange(n ** 2 ) jac_rows = [ij] jac_cols = [ij] mask = ii > 0 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask - n) mask = ii < n - 1 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask + n) mask = jj > 0 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask - 1 ) mask = jj < n - 1 ij_mask = ij[mask] jac_rows . append(ij_mask) jac_cols . append(ij_mask + 1 ) return np . hstack(jac_rows), np . hstack(jac_cols) jac_rows, jac_cols = compute_jac_indices(n) jac_rows, jac_cols (array([ 0, 1, 2, ..., 9996, 9997, 9998]), array([ 0, 1, 2, ..., 9997, 9998, 9999])) def jac (u, n,f, f_prime,c, jac_rows = None , jac_cols = None ): jac_values = np . ones_like(jac_cols, dtype = float ) jac_values[:n ** 2 ] = - 4 + c * f_prime(u) return coo_matrix((jac_values, (jac_rows, jac_cols)), shape = (n ** 2 , n ** 2 )) u0 = np . ones(n ** 2 ) * 0.5","title":"Prepare Jacobians"},{"location":"NumericalMethods/intro/Numerical-Methods/#optimization-least-square","text":"res_1 = least_squares(fun, u0, jac = jac, gtol = 1e-3 , args = (n,f, f_prime,c),\\ kwargs = { 'jac_rows' : jac_rows, 'jac_cols' : jac_cols}, verbose = 1 ) `gtol` termination condition is satisfied. Function evaluations 738, initial cost 1.1562e+02, final cost 6.4462e-01, first-order optimality 9.38e-04.","title":"Optimization: Least Square"},{"location":"NumericalMethods/intro/Numerical-Methods/#returned-quantities-after-solution","text":"res_1 . x . shape (10000,) res_1 . x array([0.00622038, 0.01236634, 0.01833963, ..., 0.01834064, 0.01236645, 0.00622026]) res_1 . fun array([-0.00014825, -0.00029118, -0.00041394, ..., -0.000414 , -0.00029121, -0.00014826]) res_1 . fun . shape (10000,) res_1 . jac &lt;10000x10000 sparse matrix of type '&lt;class 'numpy.float64'&gt;' with 49600 stored elements in Compressed Sparse Row format&gt;","title":"Returned quantities after solution"},{"location":"NumericalMethods/intro/Numerical-Methods/#plot-the-solutions","text":"plt . figure(figsize = ( 16 , 5 )) plt . subplot( 131 ) plt . plot(res_1 . x) plt . subplot( 132 ) plt . imshow(res_1 . x . reshape((n, n)),\\ cmap = 'coolwarm' ,\\ vmin =- max ( abs (res_1 . x)),\\ vmax = max ( abs (res_1 . x))) plt . colorbar(use_gridspec = True ,\\ fraction = 0.046 ,\\ pad = 0.04 ) plt . subplot( 133 ) plt . plot(res_1 . fun) plt . tight_layout()","title":"Plot the solutions"},{"location":"NumericalMethods/intro/Numerical-Methods/#references","text":"http://folk.ntnu.no/leifh/teaching/tkt4140/._main000.html http://folk.ntnu.no/leifh/teaching/tkt4140/._main055.html https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares","title":"References:"},{"location":"NumericalMethods/special-function/Special-Functions/","text":"Scipy: Special Functions Source from scipy.special import jn, yn, jn_zeros, yn_zeros import numpy as np import matplotlib.pyplot as plt % matplotlib inline from __future__ import division import scipy as sci import scipy.special as sp import numpy as np import matplotlib import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm, colors import seaborn as sns sns . set() Bessel Functions n = 0 # order x = 0.0 # Bessel function of first kind print ( \"J_ %d ( %f ) = %f \" % (n, x, jn(n, x))) x = 1.0 # Bessel function of second kind print ( \"Y_ %d ( %f ) = %f \" % (n, x, yn(n, x))) J_0(0.000000) = 1.000000 Y_0(1.000000) = 0.088257 x = np . linspace( 0 , 20 , 100 ) plt . figure(figsize = ( 12 , 10 )) for n in range ( 10 ): plt . plot(x, jn(n, x), label = r\"$J_ %d (x)$\" % n) plt . legend(); Spherical Harmonics $Y^m_n(\\theta,\\phi) = \\sqrt{\\frac{2n+1}{4\\pi} \\frac{(n-m)!}{(n+m)!}} e^{i m \\theta} P^m_n(\\cos(\\phi))$ Some Examples \\begin{split}Y_0^0(\\theta, \\phi) &= \\frac{1}{2} \\sqrt{\\frac{1}{\\pi}} \\ Y_1^{-1}(\\theta, \\phi) &= \\frac{1}{2} \\sqrt{\\frac{3}{2\\pi}} e^{-i\\theta} \\sin(\\phi) \\ Y_1^0(\\theta, \\phi) &= \\frac{1}{2} \\sqrt{\\frac{3}{\\pi}} \\cos(\\phi) \\ Y_1^1(\\theta, \\phi) &= -\\frac{1}{2} \\sqrt{\\frac{3}{2\\pi}} e^{i\\theta} \\sin(\\phi).\\end{split} PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200j , 0 :np . pi: 100j ] #arrays of angular variables Y(1,0) l = 1 #degree m = 0 #order R = np . abs(sp . sph_harm(m, l, PHI, THETA)) #Array with the absolute values of Ylm #Now we convert to cartesian coordinates # for the 3D representation X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) N = R / R . max() # Normalize R for the plot colors to cover the entire range of colormap. fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 10 , 8 )) im = ax . plot_surface(X, Y, Z, rstride = 1 , cstride = 1 , facecolors = cm . jet(N)) ax . set_title( r'$|Y^1_ 0|$' , fontsize = 20 ) m = cm . ScalarMappable(cmap = cm . jet) m . set_array(R) # Assign the unnormalized data array to the mappable #so that the scale corresponds to the values of R fig . colorbar(m, shrink = 0.8 ); Y(2,1) l = 2 #degree m = 1 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200j , 0 :np . pi: 100j ] #arrays of angular variables R = np . abs(sp . sph_harm(m, l, PHI, THETA)) #Array with the absolute values of Ylm #Now we convert to cartesian coordinates # for the 3D representation X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) N = R / R . max() # Normalize R for the plot colors to cover the entire range of colormap. fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 10 , 8 )) im = ax . plot_surface(X, Y, Z, rstride = 1 , cstride = 1 , facecolors = cm . jet(N)) ax . set_title( r'$|Y^2_ 0|$' , fontsize = 20 ) m = cm . ScalarMappable(cmap = cm . jet) m . set_array(R) # Assign the unnormalized data array to the mappable #so that the scale corresponds to the values of R fig . colorbar(m, shrink = 0.8 ); l = 2 # degree m = 1 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200j , 0 :np . pi: 100j ] R = sp . sph_harm(m, l, PHI, THETA) . real X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) #As R has negative values, we'll use an instance of Normalize #see http://stackoverflow.com/questions/25023075/normalizing-colormap-used-by-facecolors-in-matplotlib norm = colors . Normalize() fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 10 , 8 )) m = cm . ScalarMappable(cmap = cm . jet) ax . plot_surface(X, Y, Z, rstride = 1 , cstride = 1 , facecolors = cm . jet(norm(R))) ax . set_title( 'real$(Y^2_ 1)$' , fontsize = 20 ) m . set_array(R) fig . colorbar(m, shrink = 0.8 ); Y(4,2) l = 4 #degree m = 2 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200j , 0 :np . pi: 100j ] #arrays of angular variables R = np . abs(sp . sph_harm(m, l, PHI, THETA)) #Array with the absolute values of Ylm #Now we convert to cartesian coordinates # for the 3D representation X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) N = R / R . max() # Normalize R for the plot colors to cover the entire range of colormap. fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 10 , 8 )) im = ax . plot_surface(X, Y, Z, rstride = 1 , cstride = 1 , facecolors = cm . jet(N)) ax . set_title( r'$|Y^0_ 0|$' , fontsize = 20 ) m = cm . ScalarMappable(cmap = cm . jet) m . set_array(R) # Assign the unnormalized data array to the mappable #so that the scale corresponds to the values of R fig . colorbar(m, shrink = 0.8 ); l = 4 # degree m = 2 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200j , 0 :np . pi: 100j ] R = sp . sph_harm(m, l, PHI, THETA) . real X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) #As R has negative values, we'll use an instance of Normalize #see http://stackoverflow.com/questions/25023075/normalizing-colormap-used-by-facecolors-in-matplotlib norm = colors . Normalize() fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 10 , 8 )) m = cm . ScalarMappable(cmap = cm . jet) ax . plot_surface(X, Y, Z, rstride = 1 , cstride = 1 , facecolors = cm . jet(norm(R))) ax . set_title( 'real$(Y^4_ 2)$' , fontsize = 20 ) m . set_array(R) fig . colorbar(m, shrink = 0.8 ); Vibrating Circular Membrane The vibrations of a thin circular membrane stretched across a rigid circular frame (such as a drum head) can be described as normal modes written in terms of Bessel functions: $\\large{z(r,\u03b8;t)=AJ_n(kr)\\sin(n\u03b8)\\cos(k\u03bdt)}$ where $(r,\u03b8)$ describes a position in polar co-ordinates with the origin at the centre of the membrane, t is time and v is a constant depending on the tension and surface density of the drum. The modes are labelled by integers $n=0,1,\u22ef $ and $m=1,2,3,\u22ef$ where k is the mth zero of $J_n$. The following program produces a plot of the displacement of the membrane in the n=3,m=2 normal mode at time t=0. Table p q --- --- --- --- --- --- import numpy as np from scipy.special import jn, jn_zeros import pylab import seaborn as sns sns . set() def displacement (n, m, r, theta): \"\"\" Calculate the displacement of the drum membrane at (r, theta; t=0) in the normal mode described by integers n >= 0, 0 < m <= mmax. \"\"\" # Pick off the mth zero of Bessel function Jn k = jn_zeros(n, mmax + 1 )[m] return np . sin(n * theta) * jn(n, r * k) SIngle Plot # Allow calculations up to m = mmax mmax = 10 # Positions on the drum surface are specified in polar co-ordinates r = np . linspace( 0 , 1 , 100 ) theta = np . linspace( 0 , 2 * np . pi, 100 ) # Create arrays of cartesian co-ordinates (x, y) ... x = np . array([rr * np . cos(theta) for rr in r]) y = np . array([rr * np . sin(theta) for rr in r]) # ... and vertical displacement (z) for the required normal mode at # time, t = 0 n0, m0 = 2 , 0 z = np . array([displacement(n0, m0, rr, theta) for rr in r]) plt . figure(figsize = [ 5 , 5 ]) pylab . contour(x, y, z) pylab . show() 3D plot r, theta = np . mgrid[ 0 : 1 : 100j , 0 : 2 * np . pi: 100j ] x = r * np . cos(theta) y = r * np . sin(theta) z = displacement(n0, m0, r, theta) N = z / (z . max() - z . min()) fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 18 , 6 )) im = ax . plot_surface(x, y, z, rstride = 1 , cstride = 1 , facecolors = cm . jet(N)) mm = cm . ScalarMappable(cmap = cm . jet) mm . set_array(R) fig . colorbar(mm, shrink = 0.8 ); Multiplot plt . figure(figsize = [ 15 , 25 ]) k = 0 for n in range ( 6 ): for m in range (n - 1 ): k = k + 1 z = np . array([displacement(n, m, rr, theta) for rr in r]) plt . subplot( 5 , 3 ,k) plt . title( str (n) + str (m)) pylab . contour(x, y, z) pylab . show() m,n = 2,2 n0,m0 = 2 , 2 r, theta = np . mgrid[ 0 : 1 : 100j , 0 : 2 * np . pi: 100j ] x = r * np . cos(theta) y = r * np . sin(theta) z = displacement(n0, m0, r, theta) N = z / (z . max() - z . min()) fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 18 , 6 )) im = ax . plot_surface(x, y, z, rstride = 1 , cstride = 1 , facecolors = cm . jet(N)) mm = cm . ScalarMappable(cmap = cm . jet) mm . set_array(R) fig . colorbar(mm, shrink = 0.8 ); References https://en.wikipedia.org/wiki/Vibrations_of_a_circular_membrane https://www.exoruskoh.me/single-post/2017/05/24/Vibrating-Membranes-and-Fancy-Animations https://www.acs.psu.edu/drussell/Demos/MembraneCircle/Circle.html http://balbuceosastropy.blogspot.com/2015/06/spherical-harmonics-in-python.html","title":"Special Functions"},{"location":"NumericalMethods/special-function/Special-Functions/#scipy-special-functions-source","text":"from scipy.special import jn, yn, jn_zeros, yn_zeros import numpy as np import matplotlib.pyplot as plt % matplotlib inline from __future__ import division import scipy as sci import scipy.special as sp import numpy as np import matplotlib import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm, colors import seaborn as sns sns . set()","title":"Scipy: Special Functions Source"},{"location":"NumericalMethods/special-function/Special-Functions/#bessel-functions","text":"n = 0 # order x = 0.0 # Bessel function of first kind print ( \"J_ %d ( %f ) = %f \" % (n, x, jn(n, x))) x = 1.0 # Bessel function of second kind print ( \"Y_ %d ( %f ) = %f \" % (n, x, yn(n, x))) J_0(0.000000) = 1.000000 Y_0(1.000000) = 0.088257 x = np . linspace( 0 , 20 , 100 ) plt . figure(figsize = ( 12 , 10 )) for n in range ( 10 ): plt . plot(x, jn(n, x), label = r\"$J_ %d (x)$\" % n) plt . legend();","title":"Bessel Functions"},{"location":"NumericalMethods/special-function/Special-Functions/#spherical-harmonics","text":"$Y^m_n(\\theta,\\phi) = \\sqrt{\\frac{2n+1}{4\\pi} \\frac{(n-m)!}{(n+m)!}} e^{i m \\theta} P^m_n(\\cos(\\phi))$ Some Examples \\begin{split}Y_0^0(\\theta, \\phi) &= \\frac{1}{2} \\sqrt{\\frac{1}{\\pi}} \\ Y_1^{-1}(\\theta, \\phi) &= \\frac{1}{2} \\sqrt{\\frac{3}{2\\pi}} e^{-i\\theta} \\sin(\\phi) \\ Y_1^0(\\theta, \\phi) &= \\frac{1}{2} \\sqrt{\\frac{3}{\\pi}} \\cos(\\phi) \\ Y_1^1(\\theta, \\phi) &= -\\frac{1}{2} \\sqrt{\\frac{3}{2\\pi}} e^{i\\theta} \\sin(\\phi).\\end{split} PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200j , 0 :np . pi: 100j ] #arrays of angular variables","title":"Spherical Harmonics"},{"location":"NumericalMethods/special-function/Special-Functions/#y10","text":"l = 1 #degree m = 0 #order R = np . abs(sp . sph_harm(m, l, PHI, THETA)) #Array with the absolute values of Ylm #Now we convert to cartesian coordinates # for the 3D representation X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) N = R / R . max() # Normalize R for the plot colors to cover the entire range of colormap. fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 10 , 8 )) im = ax . plot_surface(X, Y, Z, rstride = 1 , cstride = 1 , facecolors = cm . jet(N)) ax . set_title( r'$|Y^1_ 0|$' , fontsize = 20 ) m = cm . ScalarMappable(cmap = cm . jet) m . set_array(R) # Assign the unnormalized data array to the mappable #so that the scale corresponds to the values of R fig . colorbar(m, shrink = 0.8 );","title":"Y(1,0)"},{"location":"NumericalMethods/special-function/Special-Functions/#y21","text":"l = 2 #degree m = 1 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200j , 0 :np . pi: 100j ] #arrays of angular variables R = np . abs(sp . sph_harm(m, l, PHI, THETA)) #Array with the absolute values of Ylm #Now we convert to cartesian coordinates # for the 3D representation X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) N = R / R . max() # Normalize R for the plot colors to cover the entire range of colormap. fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 10 , 8 )) im = ax . plot_surface(X, Y, Z, rstride = 1 , cstride = 1 , facecolors = cm . jet(N)) ax . set_title( r'$|Y^2_ 0|$' , fontsize = 20 ) m = cm . ScalarMappable(cmap = cm . jet) m . set_array(R) # Assign the unnormalized data array to the mappable #so that the scale corresponds to the values of R fig . colorbar(m, shrink = 0.8 ); l = 2 # degree m = 1 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200j , 0 :np . pi: 100j ] R = sp . sph_harm(m, l, PHI, THETA) . real X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) #As R has negative values, we'll use an instance of Normalize #see http://stackoverflow.com/questions/25023075/normalizing-colormap-used-by-facecolors-in-matplotlib norm = colors . Normalize() fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 10 , 8 )) m = cm . ScalarMappable(cmap = cm . jet) ax . plot_surface(X, Y, Z, rstride = 1 , cstride = 1 , facecolors = cm . jet(norm(R))) ax . set_title( 'real$(Y^2_ 1)$' , fontsize = 20 ) m . set_array(R) fig . colorbar(m, shrink = 0.8 );","title":"Y(2,1)"},{"location":"NumericalMethods/special-function/Special-Functions/#y42","text":"l = 4 #degree m = 2 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200j , 0 :np . pi: 100j ] #arrays of angular variables R = np . abs(sp . sph_harm(m, l, PHI, THETA)) #Array with the absolute values of Ylm #Now we convert to cartesian coordinates # for the 3D representation X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) N = R / R . max() # Normalize R for the plot colors to cover the entire range of colormap. fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 10 , 8 )) im = ax . plot_surface(X, Y, Z, rstride = 1 , cstride = 1 , facecolors = cm . jet(N)) ax . set_title( r'$|Y^0_ 0|$' , fontsize = 20 ) m = cm . ScalarMappable(cmap = cm . jet) m . set_array(R) # Assign the unnormalized data array to the mappable #so that the scale corresponds to the values of R fig . colorbar(m, shrink = 0.8 ); l = 4 # degree m = 2 # order PHI, THETA = np . mgrid[ 0 : 2 * np . pi: 200j , 0 :np . pi: 100j ] R = sp . sph_harm(m, l, PHI, THETA) . real X = R * np . sin(THETA) * np . cos(PHI) Y = R * np . sin(THETA) * np . sin(PHI) Z = R * np . cos(THETA) #As R has negative values, we'll use an instance of Normalize #see http://stackoverflow.com/questions/25023075/normalizing-colormap-used-by-facecolors-in-matplotlib norm = colors . Normalize() fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 10 , 8 )) m = cm . ScalarMappable(cmap = cm . jet) ax . plot_surface(X, Y, Z, rstride = 1 , cstride = 1 , facecolors = cm . jet(norm(R))) ax . set_title( 'real$(Y^4_ 2)$' , fontsize = 20 ) m . set_array(R) fig . colorbar(m, shrink = 0.8 );","title":"Y(4,2)"},{"location":"NumericalMethods/special-function/Special-Functions/#vibrating-circular-membrane","text":"The vibrations of a thin circular membrane stretched across a rigid circular frame (such as a drum head) can be described as normal modes written in terms of Bessel functions: $\\large{z(r,\u03b8;t)=AJ_n(kr)\\sin(n\u03b8)\\cos(k\u03bdt)}$ where $(r,\u03b8)$ describes a position in polar co-ordinates with the origin at the centre of the membrane, t is time and v is a constant depending on the tension and surface density of the drum. The modes are labelled by integers $n=0,1,\u22ef $ and $m=1,2,3,\u22ef$ where k is the mth zero of $J_n$. The following program produces a plot of the displacement of the membrane in the n=3,m=2 normal mode at time t=0. Table p q --- --- --- --- --- --- import numpy as np from scipy.special import jn, jn_zeros import pylab import seaborn as sns sns . set() def displacement (n, m, r, theta): \"\"\" Calculate the displacement of the drum membrane at (r, theta; t=0) in the normal mode described by integers n >= 0, 0 < m <= mmax. \"\"\" # Pick off the mth zero of Bessel function Jn k = jn_zeros(n, mmax + 1 )[m] return np . sin(n * theta) * jn(n, r * k)","title":"Vibrating Circular Membrane"},{"location":"NumericalMethods/special-function/Special-Functions/#single-plot","text":"# Allow calculations up to m = mmax mmax = 10 # Positions on the drum surface are specified in polar co-ordinates r = np . linspace( 0 , 1 , 100 ) theta = np . linspace( 0 , 2 * np . pi, 100 ) # Create arrays of cartesian co-ordinates (x, y) ... x = np . array([rr * np . cos(theta) for rr in r]) y = np . array([rr * np . sin(theta) for rr in r]) # ... and vertical displacement (z) for the required normal mode at # time, t = 0 n0, m0 = 2 , 0 z = np . array([displacement(n0, m0, rr, theta) for rr in r]) plt . figure(figsize = [ 5 , 5 ]) pylab . contour(x, y, z) pylab . show()","title":"SIngle Plot"},{"location":"NumericalMethods/special-function/Special-Functions/#3d-plot","text":"r, theta = np . mgrid[ 0 : 1 : 100j , 0 : 2 * np . pi: 100j ] x = r * np . cos(theta) y = r * np . sin(theta) z = displacement(n0, m0, r, theta) N = z / (z . max() - z . min()) fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 18 , 6 )) im = ax . plot_surface(x, y, z, rstride = 1 , cstride = 1 , facecolors = cm . jet(N)) mm = cm . ScalarMappable(cmap = cm . jet) mm . set_array(R) fig . colorbar(mm, shrink = 0.8 );","title":"3D plot"},{"location":"NumericalMethods/special-function/Special-Functions/#multiplot","text":"plt . figure(figsize = [ 15 , 25 ]) k = 0 for n in range ( 6 ): for m in range (n - 1 ): k = k + 1 z = np . array([displacement(n, m, rr, theta) for rr in r]) plt . subplot( 5 , 3 ,k) plt . title( str (n) + str (m)) pylab . contour(x, y, z) pylab . show()","title":"Multiplot"},{"location":"NumericalMethods/special-function/Special-Functions/#mn-22","text":"n0,m0 = 2 , 2 r, theta = np . mgrid[ 0 : 1 : 100j , 0 : 2 * np . pi: 100j ] x = r * np . cos(theta) y = r * np . sin(theta) z = displacement(n0, m0, r, theta) N = z / (z . max() - z . min()) fig, ax = plt . subplots(subplot_kw = dict (projection = '3d' ), figsize = ( 18 , 6 )) im = ax . plot_surface(x, y, z, rstride = 1 , cstride = 1 , facecolors = cm . jet(N)) mm = cm . ScalarMappable(cmap = cm . jet) mm . set_array(R) fig . colorbar(mm, shrink = 0.8 );","title":"m,n = 2,2"},{"location":"NumericalMethods/special-function/Special-Functions/#references","text":"https://en.wikipedia.org/wiki/Vibrations_of_a_circular_membrane https://www.exoruskoh.me/single-post/2017/05/24/Vibrating-Membranes-and-Fancy-Animations https://www.acs.psu.edu/drussell/Demos/MembraneCircle/Circle.html http://balbuceosastropy.blogspot.com/2015/06/spherical-harmonics-in-python.html","title":"References"},{"location":"PathIntegral/Intro/Intro/","text":"Density Matrix and Path Integral Naive Harmonic Path import math , random def rho_free (x, y, beta): # free off-diagonal density matrix return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) beta = 4.0 N = 8 # number of slices dtau = beta / N delta = 1.0 # maximum displacement on one slice n_steps = 10 # number of Monte Carlo steps x = [ 0.0 ] * N # initial path for step in range (n_steps): k = random . randint( 0 , N - 1 ) # random slice knext, kprev = (k + 1 ) % N, (k - 1 ) % N # next/previous slices x_new = x[k] + random . uniform( - delta, delta) # new position at slice k old_weight = (rho_free(x[knext], x[k], dtau) * rho_free(x[k], x[kprev], dtau) * math . exp( - 0.5 * dtau * x[k] ** 2 )) new_weight = (rho_free(x[knext], x_new, dtau) * rho_free(x_new, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_new ** 2 )) if random . uniform( 0.0 , 1.0 ) < new_weight / old_weight: x[k] = x_new print x [0.0, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.0, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [-0.1902541007130032, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, -0.2691021744359521, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, -0.2691021744359521, -0.05409984381515698, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, -0.2691021744359521, -0.05409984381515698, 0.0] Naive Harmonic Path Movie % matplotlib inline import math , random , pylab , os def rho_free (x, y, beta): # free off-diagonal density matrix return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) output_dir = 'snapshots_naive_harmonic_path' if not os . path . exists(output_dir): os . makedirs(output_dir) def show_path (x, k, x_old, Accepted, step): path = x + [x[ 0 ]] y_axis = range ( len (x) + 1 ) if Accepted: old_path = x[:] old_path[k] = x_old old_path = old_path + [old_path[ 0 ]] pylab . plot(old_path, y_axis, 'ro--' , label = 'old path' ) pylab . plot(path, y_axis, 'bo-' , label = 'new path' ) pylab . legend() pylab . xlim( - 5.0 , 5.0 ) pylab . xlabel( '$x$' , fontsize = 14 ) pylab . ylabel( '$ \\\\ tau$' , fontsize = 14 ) pylab . title( 'Naive path integral Monte Carlo, step %i ' % step) #pylab.savefig(output_dir + '/snapshot_%05i.png' % step) #pylab.clf() pylab . show() beta = 4.0 N = 8 # number of slices dtau = beta / N delta = 1.0 # maximum displacement on one slice n_steps = 4 # number of Monte Carlo steps x = [random . uniform( - 1.0 , 1.0 ) for k in range (N)] # initial path show_path(x, 0 , 0.0 , False , 0 ) for step in range (n_steps): print 'step' ,step k = random . randint( 0 , N - 1 ) # randomly choose slice knext, kprev = (k + 1 ) % N, (k - 1 ) % N # next/previous slices x_old = x[k] x_new = x[k] + random . uniform( - delta, delta) # new position at slice k old_weight = (rho_free(x[knext], x_old, dtau) * rho_free(x_old, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_old ** 2 )) new_weight = (rho_free(x[knext], x_new, dtau) * rho_free(x_new, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_new ** 2 )) if random . uniform( 0.0 , 1.0 ) < new_weight / old_weight: x[k] = x_new Accepted = True else : Accepted = False show_path(x, k, x_old, Accepted, step + 1 ) step 0 step 1 step 2 step 3 Matrix Square Harmonic import math , numpy # Free off-diagonal density matrix def rho_free (x, xp, beta): return (math . exp( - (x - xp) ** 2 / ( 2.0 * beta)) / math . sqrt( 2.0 * math . pi * beta)) # Harmonic density matrix in the Trotter approximation (returns the full matrix) def rho_harmonic_trotter (grid, beta): return numpy . array([[rho_free(x, xp, beta) * \\ numpy . exp( - 0.5 * beta * 0.5 * (x ** 2 + xp ** 2 )) \\ for x in grid] for xp in grid]) x_max = 5.0 # the x range is [-x_max,+x_max] nx = 100 dx = 2.0 * x_max / (nx - 1 ) x = [i * dx for i in range ( - (nx - 1 ) / 2 , nx / 2 + 1 )] beta_tmp = 2.0 ** ( - 5 ) # initial value of beta (power of 2) beta = 2.0 ** 4 # actual value of beta (power of 2) rho = rho_harmonic_trotter(x, beta_tmp) # density matrix at initial beta while beta_tmp < beta: rho = numpy . dot(rho, rho) rho *= dx beta_tmp *= 2.0 print 'beta: %s -> %s ' % (beta_tmp / 2.0 , beta_tmp) beta: 0.03125 -&gt; 0.0625 beta: 0.0625 -&gt; 0.125 beta: 0.125 -&gt; 0.25 beta: 0.25 -&gt; 0.5 beta: 0.5 -&gt; 1.0 beta: 1.0 -&gt; 2.0 beta: 2.0 -&gt; 4.0 beta: 4.0 -&gt; 8.0 beta: 8.0 -&gt; 16.0 Matrix Square Harmonic Movie import math , numpy , pylab # Free off-diagonal density matrix def rho_free (x, xp, beta): return (math . exp( - (x - xp) ** 2 / ( 2.0 * beta)) / math . sqrt( 2.0 * math . pi * beta)) # Harmonic density matrix in the Trotter approximation (returns the full matrix) def rho_harmonic_trotter (grid, beta): return numpy . array([[rho_free(x, xp, beta) * \\ numpy . exp( - 0.5 * beta * 0.5 * (x ** 2 + xp ** 2 )) \\ for x in grid] for xp in grid]) x_max = 5.0 # the x range is [-x_max,+x_max] nx = 100 dx = 2.0 * x_max / (nx - 1 ) x = [i * dx for i in range ( - (nx - 1 ) / 2 , nx / 2 + 1 )] beta_tmp = 2.0 ** ( - 8 ) # initial value of beta (power of 2) beta = 2.0 ** 2 # actual value of beta (power of 2) rho = rho_harmonic_trotter(x, beta_tmp) # density matrix at initial beta while beta_tmp < beta: rho = numpy . dot(rho, rho) rho *= dx beta_tmp *= 2.0 # graphics output pylab . imshow(rho, extent = [ - x_max, x_max, - x_max, x_max], origin = 'lower' ) pylab . colorbar() pylab . title( '$ \\\\ beta = 2^{ %i }$' % math . log(beta, 2 )) pylab . xlabel( '$x$' , fontsize = 18 ) pylab . ylabel( '$x \\' $' , fontsize = 18 ) #pylab.savefig('plot-harmonic-rho.png') pylab . show() Harmonic Wave Function import math n_states = 4 grid_x = [i * 0.2 for i in range ( - 25 , 26 )] psi = {} for x in grid_x: psi[x] = [math . exp( - x ** 2 / 2.0 ) / math . pi ** 0.25 ] # ground state psi[x] . append(math . sqrt( 2.0 ) * x * psi[x][ 0 ]) # first excited state # other excited states (through recursion): for n in range ( 2 , n_states): psi[x] . append(math . sqrt( 2.0 / n) * x * psi[x][n - 1 ] - math . sqrt((n - 1.0 ) / n) * psi[x][n - 2 ]) for n in range (n_states): print 'level %i :' % n, [psi[x][n] for x in grid_x] level 0: [2.7991843929095964e-06, 7.458304327999357e-06, 1.9093120491923166e-05, 4.696149856362874e-05, 0.00011097756752308872, 0.0002519745490309146, 0.0005496754903223565, 0.0011520843816137305, 0.002320013042709098, 0.004488743450746296, 0.008344251073246413, 0.014903153092645628, 0.025573912975171406, 0.042164254297199076, 0.06679129832888486, 0.10165378830641791, 0.14864676809808386, 0.2088409186844682, 0.2819057534684933, 0.3656120532774727, 0.4555806720113325, 0.5454290908346697, 0.6273927923216392, 0.6933762682841502, 0.7362522621713508, 0.7511255444649425, 0.7362522621713508, 0.6933762682841502, 0.6273927923216392, 0.5454290908346697, 0.4555806720113325, 0.3656120532774727, 0.2819057534684933, 0.2088409186844682, 0.14864676809808386, 0.10165378830641791, 0.06679129832888486, 0.042164254297199076, 0.025573912975171406, 0.014903153092645628, 0.008344251073246413, 0.004488743450746296, 0.002320013042709098, 0.0011520843816137305, 0.0005496754903223565, 0.0002519745490309146, 0.00011097756752308872, 4.696149856362874e-05, 1.9093120491923166e-05, 7.458304327999357e-06, 2.7991843929095964e-06] level 1: [-1.979322266017925e-05, -5.06286486382207e-05, -0.00012420804975942648, -0.000292219787983413, -0.0006591731206633777, -0.0014253832984494556, -0.0029539624266082393, -0.00586545608691489, -0.011155379293597705, -0.020313733971388224, -0.035401659106893996, -0.05901347543207756, -0.09403413388833536, -0.1431102246586728, -0.20780575187947614, -0.2875203321790795, -0.3783928958050294, -0.4725530553312507, -0.5581449158126092, -0.620464229174492, -0.6442883651134752, -0.6170825740569735, -0.5323604375018335, -0.3922328489740365, -0.20824358689811923, 0.0, 0.20824358689811923, 0.3922328489740365, 0.5323604375018335, 0.6170825740569735, 0.6442883651134752, 0.620464229174492, 0.5581449158126092, 0.4725530553312507, 0.3783928958050294, 0.2875203321790795, 0.20780575187947614, 0.1431102246586728, 0.09403413388833536, 0.05901347543207756, 0.035401659106893996, 0.020313733971388224, 0.011155379293597705, 0.00586545608691489, 0.0029539624266082393, 0.0014253832984494556, 0.0006591731206633777, 0.000292219787983413, 0.00012420804975942648, 5.06286486382207e-05, 1.979322266017925e-05] level 2: [9.698679103487833e-05, 0.0002377436958969781, 0.0005578561539195112, 0.001252560273037993, 0.0026900541162310225, 0.0055233602814916405, 0.010836377954452331, 0.020300995234155426, 0.036287792643291364, 0.061829927775412914, 0.10030470080286633, 0.15469961059694617, 0.2264052608234536, 0.31364990904359125, 0.4099440741622393, 0.5031605813133891, 0.5759980747254336, 0.6084120587389853, 0.5820654122045782, 0.48603031285335224, 0.3221441825567376, 0.10798945045997044, -0.12421743541709435, -0.3333979216279309, -0.4789602498656741, -0.5311259660135985, -0.4789602498656741, -0.3333979216279309, -0.12421743541709435, 0.10798945045997044, 0.3221441825567376, 0.48603031285335224, 0.5820654122045782, 0.6084120587389853, 0.5759980747254336, 0.5031605813133891, 0.4099440741622393, 0.31364990904359125, 0.2264052608234536, 0.15469961059694617, 0.10030470080286633, 0.061829927775412914, 0.036287792643291364, 0.020300995234155426, 0.010836377954452331, 0.0055233602814916405, 0.0026900541162310225, 0.001252560273037993, 0.0005578561539195112, 0.0002377436958969781, 9.698679103487833e-05] level 3: [-0.0003797858177480724, -0.0008904230727075194, -0.0019938277067416796, -0.004261332735734368, -0.008686751352074272, -0.01687539855058424, -0.031209988866398874, -0.05488337067267696, -0.09162979026487528, -0.14496246447491137, -0.2167900021496088, -0.3054884678261664, -0.4038551667423139, -0.4977767788921179, -0.5667067709284037, -0.5868984204285561, -0.5375843198695371, -0.40898823122401184, -0.209632771094667, 0.030396415302535507, 0.26302962362333343, 0.4333073982061352, 0.4955243438272363, 0.42914408535388815, 0.24824405798556262, -0.0, -0.24824405798556262, -0.42914408535388815, -0.4955243438272363, -0.4333073982061352, -0.26302962362333343, -0.030396415302535507, 0.209632771094667, 0.40898823122401184, 0.5375843198695371, 0.5868984204285561, 0.5667067709284037, 0.4977767788921179, 0.4038551667423139, 0.3054884678261664, 0.2167900021496088, 0.14496246447491137, 0.09162979026487528, 0.05488337067267696, 0.031209988866398874, 0.01687539855058424, 0.008686751352074272, 0.004261332735734368, 0.0019938277067416796, 0.0008904230727075194, 0.0003797858177480724] Harmonic Wave Function Movie import math , pylab n_states = 50 grid_x = [i * 0.1 for i in range ( - 50 , 51 )] psi = {} for x in grid_x: psi[x] = [math . exp( - x ** 2 / 2.0 ) / math . pi ** 0.25 ] # ground state psi[x] . append(math . sqrt( 2.0 ) * x * psi[x][ 0 ]) # first excited state # other excited states (through recursion): for n in range ( 2 , n_states): psi[x] . append(math . sqrt( 2.0 / n) * x * psi[x][n - 1 ] - math . sqrt((n - 1.0 ) / n) * psi[x][n - 2 ]) # graphics output for n in range (n_states): shifted_psi = [psi[x][n] + n for x in grid_x] # vertical shift pylab . plot(grid_x, shifted_psi) pylab . title( 'Harmonic oscillator wavefunctions' ) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$\\psi_n(x)$ (shifted)' , fontsize = 16 ) pylab . xlim( - 5.0 , 5.0 ) #pylab.savefig('plot-harmonic_wavefunction.png') pylab . show() Harmonic Wave Function Check import math def orthonormality_check (n, m): integral_n_m = sum (psi[n][i] * psi[m][i] for i in range (nx)) * dx return integral_n_m nx = 10 L = 10.0 dx = L / (nx - 1 ) x = [ - L / 2.0 + i * dx for i in range (nx)] n_states = 4 psi = [[math . exp( - x[i] ** 2 / 2.0 ) / math . pi ** 0.25 for i in range (nx)]] psi . append([math . sqrt( 2.0 ) * x[i] * psi[ 0 ][i] for i in range (nx)]) for n in range ( 2 , n_states): psi . append([math . sqrt( 2.0 / n) * x[i] * psi[n - 1 ][i] - \\ math . sqrt((n - 1.0 ) / n) * psi[n - 2 ][i] for i in range (nx)]) n = n_states - 1 print 'checking energy level' , n H_psi = [ 0.0 ] + [( - 0.5 * (psi[n][i + 1 ] - 2.0 * psi[n][i] + psi[n][i - 1 ]) / dx ** 2 + 0.5 * x[i] ** 2 * psi[n][i]) for i in range ( 1 , nx - 1 )] for i in range ( 1 , nx - 1 ): print n, x[i], H_psi[i] / psi[n][i] checking energy level 3 3 -3.88888888889 3.00668022555 3 -2.77777777778 4.04737813751 3 -1.66666666667 2.35349806276 3 -0.555555555556 1.7484816623 3 0.555555555556 1.7484816623 3 1.66666666667 2.35349806276 3 2.77777777778 4.04737813751 3 3.88888888889 3.00668022555 Harmonic Wave Function Check Movie import math , pylab nx = 300 # nx is even, to avoid division by zero L = 10.0 dx = L / (nx - 1 ) x = [ - L / 2.0 + i * dx for i in range (nx)] # construct wavefunctions: n_states = 4 psi = [[math . exp( - x[i] ** 2 / 2.0 ) / math . pi ** 0.25 for i in range (nx)]] # ground state psi . append([math . sqrt( 2.0 ) * x[i] * psi[ 0 ][i] for i in range (nx)]) # first excited state for n in range ( 2 , n_states): psi . append([math . sqrt( 2.0 / n) * x[i] * psi[n - 1 ][i] - \\ math . sqrt((n - 1.0 ) / n) * psi[n - 2 ][i] for i in range (nx)]) # local energy check: H_psi_over_psi = [] for n in range (n_states): H_psi = [( - 0.5 * (psi[n][i + 1 ] - 2.0 * psi[n][i] + psi[n][i - 1 ]) / dx ** 2 + 0.5 * x[i] ** 2 * psi[n][i]) for i in range ( 1 , nx - 1 )] H_psi_over_psi . append([H_psi[i] / psi[n][i + 1 ] for i in range (nx - 2 )]) # graphics output: for n in range (n_states): pylab . plot(x[ 1 : - 1 ], [n + 0.5 for i in x[ 1 : - 1 ]], 'k--' , lw = 1.5 ) pylab . plot(x[ 1 : - 1 ], H_psi_over_psi[n], '-' , lw = 1.5 ) pylab . xlabel( '$x$' , fontsize = 18 ) pylab . ylabel( '$H \\psi_ %i (x)/\\psi_ %i (x)$' % (n, n), fontsize = 18 ) pylab . xlim(x[ 0 ], x[ - 1 ]) pylab . ylim(n, n + 1 ) pylab . title( 'Schroedinger equation check (local energy)' ) #pylab.savefig('plot-check_schroedinger_energy-%i.png' % n) pylab . show() TUTORIAL Free Periodic Complex Exp import math , cmath ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho_complex = [] for i in range (nx): rho_complex . append([ sum ( math . exp( - 2.0 * beta * (math . pi * n / L) ** 2 ) * cmath . exp( 1j * 2.0 * n * math . pi * (x[i] - x[j]) / L) / L for n in range ( - (ntot - 1 ) / 2 , (ntot + 1 ) / 2 )) for j in range (nx)]) rho_real = [[rho_complex[i][j] . real for i in range (nx)] for j in range (nx)] Free Periodic Complex Movie import math , cmath , pylab ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho_complex = [] for i in range (nx): rho_complex . append([ sum ( math . exp( - 2.0 * beta * (math . pi * n / L) ** 2 ) * cmath . exp( 1j * 2.0 * n * math . pi * (x[i] - x[j]) / L) / L for n in range ( - (ntot - 1 ) / 2 , (ntot + 1 ) / 2 )) for j in range (nx)]) rho_real = [[rho_complex[i][j] . real for i in range (nx)] for j in range (nx)] # graphics output pylab . imshow(rho_real, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (complex exp)' % beta) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) #pylab.savefig('plot-periodic-complex.png') pylab . show() Periodic Sine Cosine import math # simmetric wavefunctions def psi_s (x, L, n): return math . sqrt( 2.0 / L) * math . cos( 2.0 * n * math . pi * x / L) # antysimmetric wavefunctions def psi_a (x, L, n): return math . sqrt( 2.0 / L) * math . sin( 2.0 * n * math . pi * x / L) ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho = [] for i in range (nx): rho . append([ 1.0 / L + sum ( math . exp( - beta * 2.0 * (math . pi * n / L) ** 2 ) * (psi_s(x[i], L, n) * psi_s(x[j], L, n) + psi_a(x[i], L, n) * psi_a(x[j], L, n) ) for n in range ( 1 , (ntot + 1 ) / 2 )) for j in range (nx)]) Periodic Sine Cosine Movie import math , pylab # simmetric wavefunctions def psi_s (x, L, n): return math . sqrt( 2.0 / L) * math . cos( 2.0 * n * math . pi * x / L) # antysimmetric wavefunctions def psi_a (x, L, n): return math . sqrt( 2.0 / L) * math . sin( 2.0 * n * math . pi * x / L) ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho = [] for i in range (nx): rho . append([ 1.0 / L + sum ( math . exp( - beta * 2.0 * (math . pi * n / L) ** 2 ) * (psi_s(x[i], L, n) * psi_s(x[j], L, n) + psi_a(x[i], L, n) * psi_a(x[j], L, n) ) for n in range ( 1 , (ntot + 1 ) / 2 )) for j in range (nx)]) # graphics output pylab . imshow(rho, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (sine/cosine)' % beta) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) #pylab.savefig('plot-periodic-sine_cosine.png') pylab . show() Quantum Time Evolution import numpy , pylab , os def fourier_x_to_p (phi_x, dx): phi_p = [(phi_x * numpy . exp( - 1j * p * grid_x)) . sum() * dx for p in grid_p] return numpy . array(phi_p) def fourier_p_to_x (phi_p, dp): phi_x = [(phi_p * numpy . exp( 1j * x * grid_p)) . sum() for x in grid_x] return numpy . array(phi_x) / ( 2.0 * numpy . pi) def time_step_evolution (psi0, potential, grid_x, grid_p, dx, dp, delta_t): psi0 = numpy . exp( - 1j * potential * delta_t / 2.0 ) * psi0 psi0 = fourier_x_to_p(psi0, dx) psi0 = numpy . exp( - 1j * grid_p ** 2 * delta_t / 2.0 ) * psi0 psi0 = fourier_p_to_x(psi0, dp) psi0 = numpy . exp( - 1j * potential * delta_t / 2.0 ) * psi0 psi0 /= (numpy . absolute(psi0 ** 2 ) . sum() * dx) return psi0 def funct_potential (x): if x < - 8.0 : return (x + 8.0 ) ** 2 elif x <= - 1.0 : return 0.0 elif x < 1.0 : return numpy . exp( - 1.0 / ( 1.0 - x ** 2 )) / numpy . exp( - 1.0 ) else : return 0.0 output_dir = 'snapshots_time_evolution' if not os . path . exists(output_dir): os . makedirs(output_dir) def show (x, psi, pot, time, timestep): pylab . plot(x, psi, 'g' , linewidth = 2.0 , label = '$|\\psi(x)|^2$' ) pylab . xlim( - 10 , 15 ) pylab . ylim( - 0.1 , 1.15 ) pylab . plot(x, pot, 'k' , linewidth = 2.0 , label = '$V(x)$' ) pylab . xlabel( '$x$' , fontsize = 20 ) pylab . title( 'time = %s ' % time) pylab . legend(loc = 1 ) #pylab.savefig(output_dir + '/snapshot_%05i.png' % timestep) timestep += 1 #pylab.clf() pylab . show() steps = 800 x_min = - 12.0 x_max = 40.0 grid_x = numpy . linspace(x_min, x_max, steps) grid_p = numpy . linspace(x_min, x_max, steps) dx = grid_x[ 1 ] - grid_x[ 0 ] dp = grid_p[ 1 ] - grid_p[ 0 ] delta_t = 0.1 t_max = 1.0 potential = [funct_potential(x) for x in grid_x] potential = numpy . array(potential) # initial state: x0 = - 8.0 sigma = . 5 psi = numpy . exp( - (grid_x - x0) ** 2 / ( 2.0 * sigma ** 2 ) ) psi /= numpy . sqrt( sigma * numpy . sqrt( numpy . pi ) ) # time evolution time = 0.0 timestep = 0 while time < t_max: if timestep % 4 == 0 : show(grid_x, numpy . absolute(psi) ** 2.0 , potential, time, timestep) print time time += delta_t timestep += 1 psi = time_step_evolution(psi, potential, grid_x, grid_p, dx, dp, delta_t) 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 Harmonic Totter import math , pylab # density matrix for a free particle (exact) def funct_rho_free (x, xp, beta): return (math . exp( - (x - xp) ** 2 / ( 2.0 * beta)) / math . sqrt( 2.0 * math . pi * beta)) beta = 0.1 nx = 300 L = 10.0 x = [ - L / 2.0 + i * L / float (nx - 1 ) for i in range (nx)] rho_free, rho_harm = [], [] for i in range (nx): rho_free . append([funct_rho_free(x[i], x[j], beta) for j in range (nx)]) rho_harm . append([rho_free[i][j] * math . exp( - beta * x[i] ** 2 / 4.0 - beta * x[j] ** 2 / 4.0 ) for j in range (nx)]) # graphics output (free particle) pylab . imshow(rho_free, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (free)' % beta) #pylab.savefig('plot-trotter-free.png') #pylab.clf() pylab . show() # graphics output (harmonic potential) pylab . imshow(rho_harm, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (harmonic)' % beta) #pylab.savefig('plot-trotter-harmonic.png') pylab . show()","title":"Getting Started with Path Integral"},{"location":"PathIntegral/Intro/Intro/#density-matrix-and-path-integral","text":"Naive Harmonic Path import math , random def rho_free (x, y, beta): # free off-diagonal density matrix return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) beta = 4.0 N = 8 # number of slices dtau = beta / N delta = 1.0 # maximum displacement on one slice n_steps = 10 # number of Monte Carlo steps x = [ 0.0 ] * N # initial path for step in range (n_steps): k = random . randint( 0 , N - 1 ) # random slice knext, kprev = (k + 1 ) % N, (k - 1 ) % N # next/previous slices x_new = x[k] + random . uniform( - delta, delta) # new position at slice k old_weight = (rho_free(x[knext], x[k], dtau) * rho_free(x[k], x[kprev], dtau) * math . exp( - 0.5 * dtau * x[k] ** 2 )) new_weight = (rho_free(x[knext], x_new, dtau) * rho_free(x_new, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_new ** 2 )) if random . uniform( 0.0 , 1.0 ) < new_weight / old_weight: x[k] = x_new print x [0.0, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.0, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [-0.1902541007130032, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, 0.0, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, -0.2691021744359521, 0.0, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, -0.2691021744359521, -0.05409984381515698, 0.0] [0.3502387271176708, 0.0, 0.0, -0.9503347336313315, 0.0, -0.2691021744359521, -0.05409984381515698, 0.0] Naive Harmonic Path Movie % matplotlib inline import math , random , pylab , os def rho_free (x, y, beta): # free off-diagonal density matrix return math . exp( - (x - y) ** 2 / ( 2.0 * beta)) output_dir = 'snapshots_naive_harmonic_path' if not os . path . exists(output_dir): os . makedirs(output_dir) def show_path (x, k, x_old, Accepted, step): path = x + [x[ 0 ]] y_axis = range ( len (x) + 1 ) if Accepted: old_path = x[:] old_path[k] = x_old old_path = old_path + [old_path[ 0 ]] pylab . plot(old_path, y_axis, 'ro--' , label = 'old path' ) pylab . plot(path, y_axis, 'bo-' , label = 'new path' ) pylab . legend() pylab . xlim( - 5.0 , 5.0 ) pylab . xlabel( '$x$' , fontsize = 14 ) pylab . ylabel( '$ \\\\ tau$' , fontsize = 14 ) pylab . title( 'Naive path integral Monte Carlo, step %i ' % step) #pylab.savefig(output_dir + '/snapshot_%05i.png' % step) #pylab.clf() pylab . show() beta = 4.0 N = 8 # number of slices dtau = beta / N delta = 1.0 # maximum displacement on one slice n_steps = 4 # number of Monte Carlo steps x = [random . uniform( - 1.0 , 1.0 ) for k in range (N)] # initial path show_path(x, 0 , 0.0 , False , 0 ) for step in range (n_steps): print 'step' ,step k = random . randint( 0 , N - 1 ) # randomly choose slice knext, kprev = (k + 1 ) % N, (k - 1 ) % N # next/previous slices x_old = x[k] x_new = x[k] + random . uniform( - delta, delta) # new position at slice k old_weight = (rho_free(x[knext], x_old, dtau) * rho_free(x_old, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_old ** 2 )) new_weight = (rho_free(x[knext], x_new, dtau) * rho_free(x_new, x[kprev], dtau) * math . exp( - 0.5 * dtau * x_new ** 2 )) if random . uniform( 0.0 , 1.0 ) < new_weight / old_weight: x[k] = x_new Accepted = True else : Accepted = False show_path(x, k, x_old, Accepted, step + 1 ) step 0 step 1 step 2 step 3 Matrix Square Harmonic import math , numpy # Free off-diagonal density matrix def rho_free (x, xp, beta): return (math . exp( - (x - xp) ** 2 / ( 2.0 * beta)) / math . sqrt( 2.0 * math . pi * beta)) # Harmonic density matrix in the Trotter approximation (returns the full matrix) def rho_harmonic_trotter (grid, beta): return numpy . array([[rho_free(x, xp, beta) * \\ numpy . exp( - 0.5 * beta * 0.5 * (x ** 2 + xp ** 2 )) \\ for x in grid] for xp in grid]) x_max = 5.0 # the x range is [-x_max,+x_max] nx = 100 dx = 2.0 * x_max / (nx - 1 ) x = [i * dx for i in range ( - (nx - 1 ) / 2 , nx / 2 + 1 )] beta_tmp = 2.0 ** ( - 5 ) # initial value of beta (power of 2) beta = 2.0 ** 4 # actual value of beta (power of 2) rho = rho_harmonic_trotter(x, beta_tmp) # density matrix at initial beta while beta_tmp < beta: rho = numpy . dot(rho, rho) rho *= dx beta_tmp *= 2.0 print 'beta: %s -> %s ' % (beta_tmp / 2.0 , beta_tmp) beta: 0.03125 -&gt; 0.0625 beta: 0.0625 -&gt; 0.125 beta: 0.125 -&gt; 0.25 beta: 0.25 -&gt; 0.5 beta: 0.5 -&gt; 1.0 beta: 1.0 -&gt; 2.0 beta: 2.0 -&gt; 4.0 beta: 4.0 -&gt; 8.0 beta: 8.0 -&gt; 16.0 Matrix Square Harmonic Movie import math , numpy , pylab # Free off-diagonal density matrix def rho_free (x, xp, beta): return (math . exp( - (x - xp) ** 2 / ( 2.0 * beta)) / math . sqrt( 2.0 * math . pi * beta)) # Harmonic density matrix in the Trotter approximation (returns the full matrix) def rho_harmonic_trotter (grid, beta): return numpy . array([[rho_free(x, xp, beta) * \\ numpy . exp( - 0.5 * beta * 0.5 * (x ** 2 + xp ** 2 )) \\ for x in grid] for xp in grid]) x_max = 5.0 # the x range is [-x_max,+x_max] nx = 100 dx = 2.0 * x_max / (nx - 1 ) x = [i * dx for i in range ( - (nx - 1 ) / 2 , nx / 2 + 1 )] beta_tmp = 2.0 ** ( - 8 ) # initial value of beta (power of 2) beta = 2.0 ** 2 # actual value of beta (power of 2) rho = rho_harmonic_trotter(x, beta_tmp) # density matrix at initial beta while beta_tmp < beta: rho = numpy . dot(rho, rho) rho *= dx beta_tmp *= 2.0 # graphics output pylab . imshow(rho, extent = [ - x_max, x_max, - x_max, x_max], origin = 'lower' ) pylab . colorbar() pylab . title( '$ \\\\ beta = 2^{ %i }$' % math . log(beta, 2 )) pylab . xlabel( '$x$' , fontsize = 18 ) pylab . ylabel( '$x \\' $' , fontsize = 18 ) #pylab.savefig('plot-harmonic-rho.png') pylab . show() Harmonic Wave Function import math n_states = 4 grid_x = [i * 0.2 for i in range ( - 25 , 26 )] psi = {} for x in grid_x: psi[x] = [math . exp( - x ** 2 / 2.0 ) / math . pi ** 0.25 ] # ground state psi[x] . append(math . sqrt( 2.0 ) * x * psi[x][ 0 ]) # first excited state # other excited states (through recursion): for n in range ( 2 , n_states): psi[x] . append(math . sqrt( 2.0 / n) * x * psi[x][n - 1 ] - math . sqrt((n - 1.0 ) / n) * psi[x][n - 2 ]) for n in range (n_states): print 'level %i :' % n, [psi[x][n] for x in grid_x] level 0: [2.7991843929095964e-06, 7.458304327999357e-06, 1.9093120491923166e-05, 4.696149856362874e-05, 0.00011097756752308872, 0.0002519745490309146, 0.0005496754903223565, 0.0011520843816137305, 0.002320013042709098, 0.004488743450746296, 0.008344251073246413, 0.014903153092645628, 0.025573912975171406, 0.042164254297199076, 0.06679129832888486, 0.10165378830641791, 0.14864676809808386, 0.2088409186844682, 0.2819057534684933, 0.3656120532774727, 0.4555806720113325, 0.5454290908346697, 0.6273927923216392, 0.6933762682841502, 0.7362522621713508, 0.7511255444649425, 0.7362522621713508, 0.6933762682841502, 0.6273927923216392, 0.5454290908346697, 0.4555806720113325, 0.3656120532774727, 0.2819057534684933, 0.2088409186844682, 0.14864676809808386, 0.10165378830641791, 0.06679129832888486, 0.042164254297199076, 0.025573912975171406, 0.014903153092645628, 0.008344251073246413, 0.004488743450746296, 0.002320013042709098, 0.0011520843816137305, 0.0005496754903223565, 0.0002519745490309146, 0.00011097756752308872, 4.696149856362874e-05, 1.9093120491923166e-05, 7.458304327999357e-06, 2.7991843929095964e-06] level 1: [-1.979322266017925e-05, -5.06286486382207e-05, -0.00012420804975942648, -0.000292219787983413, -0.0006591731206633777, -0.0014253832984494556, -0.0029539624266082393, -0.00586545608691489, -0.011155379293597705, -0.020313733971388224, -0.035401659106893996, -0.05901347543207756, -0.09403413388833536, -0.1431102246586728, -0.20780575187947614, -0.2875203321790795, -0.3783928958050294, -0.4725530553312507, -0.5581449158126092, -0.620464229174492, -0.6442883651134752, -0.6170825740569735, -0.5323604375018335, -0.3922328489740365, -0.20824358689811923, 0.0, 0.20824358689811923, 0.3922328489740365, 0.5323604375018335, 0.6170825740569735, 0.6442883651134752, 0.620464229174492, 0.5581449158126092, 0.4725530553312507, 0.3783928958050294, 0.2875203321790795, 0.20780575187947614, 0.1431102246586728, 0.09403413388833536, 0.05901347543207756, 0.035401659106893996, 0.020313733971388224, 0.011155379293597705, 0.00586545608691489, 0.0029539624266082393, 0.0014253832984494556, 0.0006591731206633777, 0.000292219787983413, 0.00012420804975942648, 5.06286486382207e-05, 1.979322266017925e-05] level 2: [9.698679103487833e-05, 0.0002377436958969781, 0.0005578561539195112, 0.001252560273037993, 0.0026900541162310225, 0.0055233602814916405, 0.010836377954452331, 0.020300995234155426, 0.036287792643291364, 0.061829927775412914, 0.10030470080286633, 0.15469961059694617, 0.2264052608234536, 0.31364990904359125, 0.4099440741622393, 0.5031605813133891, 0.5759980747254336, 0.6084120587389853, 0.5820654122045782, 0.48603031285335224, 0.3221441825567376, 0.10798945045997044, -0.12421743541709435, -0.3333979216279309, -0.4789602498656741, -0.5311259660135985, -0.4789602498656741, -0.3333979216279309, -0.12421743541709435, 0.10798945045997044, 0.3221441825567376, 0.48603031285335224, 0.5820654122045782, 0.6084120587389853, 0.5759980747254336, 0.5031605813133891, 0.4099440741622393, 0.31364990904359125, 0.2264052608234536, 0.15469961059694617, 0.10030470080286633, 0.061829927775412914, 0.036287792643291364, 0.020300995234155426, 0.010836377954452331, 0.0055233602814916405, 0.0026900541162310225, 0.001252560273037993, 0.0005578561539195112, 0.0002377436958969781, 9.698679103487833e-05] level 3: [-0.0003797858177480724, -0.0008904230727075194, -0.0019938277067416796, -0.004261332735734368, -0.008686751352074272, -0.01687539855058424, -0.031209988866398874, -0.05488337067267696, -0.09162979026487528, -0.14496246447491137, -0.2167900021496088, -0.3054884678261664, -0.4038551667423139, -0.4977767788921179, -0.5667067709284037, -0.5868984204285561, -0.5375843198695371, -0.40898823122401184, -0.209632771094667, 0.030396415302535507, 0.26302962362333343, 0.4333073982061352, 0.4955243438272363, 0.42914408535388815, 0.24824405798556262, -0.0, -0.24824405798556262, -0.42914408535388815, -0.4955243438272363, -0.4333073982061352, -0.26302962362333343, -0.030396415302535507, 0.209632771094667, 0.40898823122401184, 0.5375843198695371, 0.5868984204285561, 0.5667067709284037, 0.4977767788921179, 0.4038551667423139, 0.3054884678261664, 0.2167900021496088, 0.14496246447491137, 0.09162979026487528, 0.05488337067267696, 0.031209988866398874, 0.01687539855058424, 0.008686751352074272, 0.004261332735734368, 0.0019938277067416796, 0.0008904230727075194, 0.0003797858177480724] Harmonic Wave Function Movie import math , pylab n_states = 50 grid_x = [i * 0.1 for i in range ( - 50 , 51 )] psi = {} for x in grid_x: psi[x] = [math . exp( - x ** 2 / 2.0 ) / math . pi ** 0.25 ] # ground state psi[x] . append(math . sqrt( 2.0 ) * x * psi[x][ 0 ]) # first excited state # other excited states (through recursion): for n in range ( 2 , n_states): psi[x] . append(math . sqrt( 2.0 / n) * x * psi[x][n - 1 ] - math . sqrt((n - 1.0 ) / n) * psi[x][n - 2 ]) # graphics output for n in range (n_states): shifted_psi = [psi[x][n] + n for x in grid_x] # vertical shift pylab . plot(grid_x, shifted_psi) pylab . title( 'Harmonic oscillator wavefunctions' ) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$\\psi_n(x)$ (shifted)' , fontsize = 16 ) pylab . xlim( - 5.0 , 5.0 ) #pylab.savefig('plot-harmonic_wavefunction.png') pylab . show() Harmonic Wave Function Check import math def orthonormality_check (n, m): integral_n_m = sum (psi[n][i] * psi[m][i] for i in range (nx)) * dx return integral_n_m nx = 10 L = 10.0 dx = L / (nx - 1 ) x = [ - L / 2.0 + i * dx for i in range (nx)] n_states = 4 psi = [[math . exp( - x[i] ** 2 / 2.0 ) / math . pi ** 0.25 for i in range (nx)]] psi . append([math . sqrt( 2.0 ) * x[i] * psi[ 0 ][i] for i in range (nx)]) for n in range ( 2 , n_states): psi . append([math . sqrt( 2.0 / n) * x[i] * psi[n - 1 ][i] - \\ math . sqrt((n - 1.0 ) / n) * psi[n - 2 ][i] for i in range (nx)]) n = n_states - 1 print 'checking energy level' , n H_psi = [ 0.0 ] + [( - 0.5 * (psi[n][i + 1 ] - 2.0 * psi[n][i] + psi[n][i - 1 ]) / dx ** 2 + 0.5 * x[i] ** 2 * psi[n][i]) for i in range ( 1 , nx - 1 )] for i in range ( 1 , nx - 1 ): print n, x[i], H_psi[i] / psi[n][i] checking energy level 3 3 -3.88888888889 3.00668022555 3 -2.77777777778 4.04737813751 3 -1.66666666667 2.35349806276 3 -0.555555555556 1.7484816623 3 0.555555555556 1.7484816623 3 1.66666666667 2.35349806276 3 2.77777777778 4.04737813751 3 3.88888888889 3.00668022555 Harmonic Wave Function Check Movie import math , pylab nx = 300 # nx is even, to avoid division by zero L = 10.0 dx = L / (nx - 1 ) x = [ - L / 2.0 + i * dx for i in range (nx)] # construct wavefunctions: n_states = 4 psi = [[math . exp( - x[i] ** 2 / 2.0 ) / math . pi ** 0.25 for i in range (nx)]] # ground state psi . append([math . sqrt( 2.0 ) * x[i] * psi[ 0 ][i] for i in range (nx)]) # first excited state for n in range ( 2 , n_states): psi . append([math . sqrt( 2.0 / n) * x[i] * psi[n - 1 ][i] - \\ math . sqrt((n - 1.0 ) / n) * psi[n - 2 ][i] for i in range (nx)]) # local energy check: H_psi_over_psi = [] for n in range (n_states): H_psi = [( - 0.5 * (psi[n][i + 1 ] - 2.0 * psi[n][i] + psi[n][i - 1 ]) / dx ** 2 + 0.5 * x[i] ** 2 * psi[n][i]) for i in range ( 1 , nx - 1 )] H_psi_over_psi . append([H_psi[i] / psi[n][i + 1 ] for i in range (nx - 2 )]) # graphics output: for n in range (n_states): pylab . plot(x[ 1 : - 1 ], [n + 0.5 for i in x[ 1 : - 1 ]], 'k--' , lw = 1.5 ) pylab . plot(x[ 1 : - 1 ], H_psi_over_psi[n], '-' , lw = 1.5 ) pylab . xlabel( '$x$' , fontsize = 18 ) pylab . ylabel( '$H \\psi_ %i (x)/\\psi_ %i (x)$' % (n, n), fontsize = 18 ) pylab . xlim(x[ 0 ], x[ - 1 ]) pylab . ylim(n, n + 1 ) pylab . title( 'Schroedinger equation check (local energy)' ) #pylab.savefig('plot-check_schroedinger_energy-%i.png' % n) pylab . show()","title":"Density Matrix and Path Integral"},{"location":"PathIntegral/Intro/Intro/#tutorial","text":"Free Periodic Complex Exp import math , cmath ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho_complex = [] for i in range (nx): rho_complex . append([ sum ( math . exp( - 2.0 * beta * (math . pi * n / L) ** 2 ) * cmath . exp( 1j * 2.0 * n * math . pi * (x[i] - x[j]) / L) / L for n in range ( - (ntot - 1 ) / 2 , (ntot + 1 ) / 2 )) for j in range (nx)]) rho_real = [[rho_complex[i][j] . real for i in range (nx)] for j in range (nx)] Free Periodic Complex Movie import math , cmath , pylab ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho_complex = [] for i in range (nx): rho_complex . append([ sum ( math . exp( - 2.0 * beta * (math . pi * n / L) ** 2 ) * cmath . exp( 1j * 2.0 * n * math . pi * (x[i] - x[j]) / L) / L for n in range ( - (ntot - 1 ) / 2 , (ntot + 1 ) / 2 )) for j in range (nx)]) rho_real = [[rho_complex[i][j] . real for i in range (nx)] for j in range (nx)] # graphics output pylab . imshow(rho_real, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (complex exp)' % beta) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) #pylab.savefig('plot-periodic-complex.png') pylab . show() Periodic Sine Cosine import math # simmetric wavefunctions def psi_s (x, L, n): return math . sqrt( 2.0 / L) * math . cos( 2.0 * n * math . pi * x / L) # antysimmetric wavefunctions def psi_a (x, L, n): return math . sqrt( 2.0 / L) * math . sin( 2.0 * n * math . pi * x / L) ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho = [] for i in range (nx): rho . append([ 1.0 / L + sum ( math . exp( - beta * 2.0 * (math . pi * n / L) ** 2 ) * (psi_s(x[i], L, n) * psi_s(x[j], L, n) + psi_a(x[i], L, n) * psi_a(x[j], L, n) ) for n in range ( 1 , (ntot + 1 ) / 2 )) for j in range (nx)]) Periodic Sine Cosine Movie import math , pylab # simmetric wavefunctions def psi_s (x, L, n): return math . sqrt( 2.0 / L) * math . cos( 2.0 * n * math . pi * x / L) # antysimmetric wavefunctions def psi_a (x, L, n): return math . sqrt( 2.0 / L) * math . sin( 2.0 * n * math . pi * x / L) ntot = 21 # odd number beta = 1.0 nx = 100 L = 10.0 x = [i * L / float (nx - 1 ) for i in range (nx)] rho = [] for i in range (nx): rho . append([ 1.0 / L + sum ( math . exp( - beta * 2.0 * (math . pi * n / L) ** 2 ) * (psi_s(x[i], L, n) * psi_s(x[j], L, n) + psi_a(x[i], L, n) * psi_a(x[j], L, n) ) for n in range ( 1 , (ntot + 1 ) / 2 )) for j in range (nx)]) # graphics output pylab . imshow(rho, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (sine/cosine)' % beta) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) #pylab.savefig('plot-periodic-sine_cosine.png') pylab . show() Quantum Time Evolution import numpy , pylab , os def fourier_x_to_p (phi_x, dx): phi_p = [(phi_x * numpy . exp( - 1j * p * grid_x)) . sum() * dx for p in grid_p] return numpy . array(phi_p) def fourier_p_to_x (phi_p, dp): phi_x = [(phi_p * numpy . exp( 1j * x * grid_p)) . sum() for x in grid_x] return numpy . array(phi_x) / ( 2.0 * numpy . pi) def time_step_evolution (psi0, potential, grid_x, grid_p, dx, dp, delta_t): psi0 = numpy . exp( - 1j * potential * delta_t / 2.0 ) * psi0 psi0 = fourier_x_to_p(psi0, dx) psi0 = numpy . exp( - 1j * grid_p ** 2 * delta_t / 2.0 ) * psi0 psi0 = fourier_p_to_x(psi0, dp) psi0 = numpy . exp( - 1j * potential * delta_t / 2.0 ) * psi0 psi0 /= (numpy . absolute(psi0 ** 2 ) . sum() * dx) return psi0 def funct_potential (x): if x < - 8.0 : return (x + 8.0 ) ** 2 elif x <= - 1.0 : return 0.0 elif x < 1.0 : return numpy . exp( - 1.0 / ( 1.0 - x ** 2 )) / numpy . exp( - 1.0 ) else : return 0.0 output_dir = 'snapshots_time_evolution' if not os . path . exists(output_dir): os . makedirs(output_dir) def show (x, psi, pot, time, timestep): pylab . plot(x, psi, 'g' , linewidth = 2.0 , label = '$|\\psi(x)|^2$' ) pylab . xlim( - 10 , 15 ) pylab . ylim( - 0.1 , 1.15 ) pylab . plot(x, pot, 'k' , linewidth = 2.0 , label = '$V(x)$' ) pylab . xlabel( '$x$' , fontsize = 20 ) pylab . title( 'time = %s ' % time) pylab . legend(loc = 1 ) #pylab.savefig(output_dir + '/snapshot_%05i.png' % timestep) timestep += 1 #pylab.clf() pylab . show() steps = 800 x_min = - 12.0 x_max = 40.0 grid_x = numpy . linspace(x_min, x_max, steps) grid_p = numpy . linspace(x_min, x_max, steps) dx = grid_x[ 1 ] - grid_x[ 0 ] dp = grid_p[ 1 ] - grid_p[ 0 ] delta_t = 0.1 t_max = 1.0 potential = [funct_potential(x) for x in grid_x] potential = numpy . array(potential) # initial state: x0 = - 8.0 sigma = . 5 psi = numpy . exp( - (grid_x - x0) ** 2 / ( 2.0 * sigma ** 2 ) ) psi /= numpy . sqrt( sigma * numpy . sqrt( numpy . pi ) ) # time evolution time = 0.0 timestep = 0 while time < t_max: if timestep % 4 == 0 : show(grid_x, numpy . absolute(psi) ** 2.0 , potential, time, timestep) print time time += delta_t timestep += 1 psi = time_step_evolution(psi, potential, grid_x, grid_p, dx, dp, delta_t) 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 Harmonic Totter import math , pylab # density matrix for a free particle (exact) def funct_rho_free (x, xp, beta): return (math . exp( - (x - xp) ** 2 / ( 2.0 * beta)) / math . sqrt( 2.0 * math . pi * beta)) beta = 0.1 nx = 300 L = 10.0 x = [ - L / 2.0 + i * L / float (nx - 1 ) for i in range (nx)] rho_free, rho_harm = [], [] for i in range (nx): rho_free . append([funct_rho_free(x[i], x[j], beta) for j in range (nx)]) rho_harm . append([rho_free[i][j] * math . exp( - beta * x[i] ** 2 / 4.0 - beta * x[j] ** 2 / 4.0 ) for j in range (nx)]) # graphics output (free particle) pylab . imshow(rho_free, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (free)' % beta) #pylab.savefig('plot-trotter-free.png') #pylab.clf() pylab . show() # graphics output (harmonic potential) pylab . imshow(rho_harm, extent = [ 0.0 , L, 0.0 , L], origin = 'lower' ) pylab . xlabel( '$x$' , fontsize = 16 ) pylab . ylabel( '$x \\' $' , fontsize = 16 ) pylab . colorbar() pylab . title( '$ \\\\ beta$= %s (harmonic)' % beta) #pylab.savefig('plot-trotter-harmonic.png') pylab . show()","title":"TUTORIAL"},{"location":"Projects/Diffusion/Diffusion/","text":"Diffusion Patterns Read more about diffusion here import numpy as np import json import random as random import math as math import matplotlib.pyplot as plt import seaborn as sns sns . set() Consider a 2D lattice of length L L = 10 Create initial configuration: We can use a vacant list to create initial configuration where initially particle is at middle of the lattice. def start (L): '''create a vacant list of list ''' P = [[ 0 for i in range (L)] for j in range (L)] '''put particle at center''' P[ int (L / 2 )][ int (L / 2 )] = 1 return P P = start(L) P [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] Make a plot of the lattice. plt . figure(figsize = [ 8 , 6 ]) sns . heatmap(P,annot = True ,cmap = 'YlGn' ) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1a1dafde48&gt; Create a function to diffuse a particle: $$ P[i,j] = P[i+1,j] + P[i-1,j] + P[i,j+1] + P[i,j-1]$$ def diffuse_primitive (P,L): '''create vacant list of list''' PP = [[ 0 for i in range (L)] for j in range (L)] for i in range (L): for j in range (L): '''diffuse one step''' PP[i][j] = P[i + 1 ][j] + P[i - 1 ][j] + P[i][j + 1 ] + P[i][j - 1 ] '''normalize''' PP = PP / np . sum(PP) return PP L = 10 P = start(L) #P = diffuse_primitive(P,L) Set boundary conditons Lower limit P[0-1,j] = P[L,j] P[I,0-1] = P[i,L] Upper Limit P[L+1,j] = P[o,j] P[i,L+1] = P[i,0] def diffuse (P,L): '''create vacant list of list''' PP = [[ 0 for i in range (L)] for j in range (L)] '''diffuse 1-step over supplied configuration''' for i in range (L): for j in range (L): '''set boundary condition at bottom and left''' ni = 0 ; nj = 0 if i == 0 :ni = L if j == 0 :nj = L '''add modulo to control boundary at top and right''' PP[i][j] = P[(i + 1 ) % L][j] + P[(i - 1 ) + ni][j]\\ + P[i][(j + 1 ) % L] + P[i][(j - 1 ) + nj] '''normalize''' PP = PP / np . sum(PP) return PP L = 10 P = start(L) plt . figure(figsize = [ 20 , 15 ]) plt . subplot( 3 , 3 , 1 ) P = diffuse(P,L) sns . heatmap(P,annot = True ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 2 ) P = diffuse(P,L) sns . heatmap(P,annot = True ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 3 ) P = diffuse(P,L) sns . heatmap(P,annot = True ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 4 ) P = diffuse(P,L) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 5 ) P = diffuse(P,L) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 6 ) P = diffuse(P,L) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 7 ) P = diffuse(P,L) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 8 ) P = diffuse(P,L) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 9 ) P = diffuse(P,L) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . savefig( 'plot/diffuse-step.pdf' ) plt . show() Run the diffusion step with desire no of running steps def run_diffuse (P,nrun,L): run = 0 '''diffuse N times''' while run < nrun: P = diffuse(P,L) run = run + 1 return P We can make a plot of arbitraty diffusion step by selecting \"irun\" in function runner. '''set parameters''' L = 100 ; nrun = 1000 ; P = start(L) '''run diffusion''' P = run_diffuse(P,nrun,L) plt . figure(figsize = [ 12 , 10 ]) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . savefig( 'plot/diffuse.pdf' ) plt . show() Much Finner L = 200 nrun = 1000 P = start(L) '''run diffusion''' P = run_diffuse(P,nrun,L) plt . figure(figsize = [ 12 , 10 ]) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . savefig( 'plot/diffuse-finner.pdf' ) plt . show()","title":"Diffusion"},{"location":"Projects/Diffusion/Diffusion/#diffusion-patterns","text":"Read more about diffusion here import numpy as np import json import random as random import math as math import matplotlib.pyplot as plt import seaborn as sns sns . set()","title":"Diffusion Patterns"},{"location":"Projects/Diffusion/Diffusion/#consider-a-2d-lattice-of-length-l","text":"L = 10","title":"Consider a 2D lattice of length L"},{"location":"Projects/Diffusion/Diffusion/#create-initial-configuration","text":"We can use a vacant list to create initial configuration where initially particle is at middle of the lattice. def start (L): '''create a vacant list of list ''' P = [[ 0 for i in range (L)] for j in range (L)] '''put particle at center''' P[ int (L / 2 )][ int (L / 2 )] = 1 return P P = start(L) P [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]","title":"Create initial configuration:"},{"location":"Projects/Diffusion/Diffusion/#make-a-plot-of-the-lattice","text":"plt . figure(figsize = [ 8 , 6 ]) sns . heatmap(P,annot = True ,cmap = 'YlGn' ) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1a1dafde48&gt;","title":"Make a plot of the lattice."},{"location":"Projects/Diffusion/Diffusion/#create-a-function-to-diffuse-a-particle","text":"$$ P[i,j] = P[i+1,j] + P[i-1,j] + P[i,j+1] + P[i,j-1]$$ def diffuse_primitive (P,L): '''create vacant list of list''' PP = [[ 0 for i in range (L)] for j in range (L)] for i in range (L): for j in range (L): '''diffuse one step''' PP[i][j] = P[i + 1 ][j] + P[i - 1 ][j] + P[i][j + 1 ] + P[i][j - 1 ] '''normalize''' PP = PP / np . sum(PP) return PP L = 10 P = start(L) #P = diffuse_primitive(P,L)","title":"Create a function to diffuse a particle:"},{"location":"Projects/Diffusion/Diffusion/#set-boundary-conditons","text":"Lower limit P[0-1,j] = P[L,j] P[I,0-1] = P[i,L] Upper Limit P[L+1,j] = P[o,j] P[i,L+1] = P[i,0] def diffuse (P,L): '''create vacant list of list''' PP = [[ 0 for i in range (L)] for j in range (L)] '''diffuse 1-step over supplied configuration''' for i in range (L): for j in range (L): '''set boundary condition at bottom and left''' ni = 0 ; nj = 0 if i == 0 :ni = L if j == 0 :nj = L '''add modulo to control boundary at top and right''' PP[i][j] = P[(i + 1 ) % L][j] + P[(i - 1 ) + ni][j]\\ + P[i][(j + 1 ) % L] + P[i][(j - 1 ) + nj] '''normalize''' PP = PP / np . sum(PP) return PP L = 10 P = start(L) plt . figure(figsize = [ 20 , 15 ]) plt . subplot( 3 , 3 , 1 ) P = diffuse(P,L) sns . heatmap(P,annot = True ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 2 ) P = diffuse(P,L) sns . heatmap(P,annot = True ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 3 ) P = diffuse(P,L) sns . heatmap(P,annot = True ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 4 ) P = diffuse(P,L) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 5 ) P = diffuse(P,L) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 6 ) P = diffuse(P,L) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 7 ) P = diffuse(P,L) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 8 ) P = diffuse(P,L) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . subplot( 3 , 3 , 9 ) P = diffuse(P,L) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . savefig( 'plot/diffuse-step.pdf' ) plt . show()","title":"Set boundary conditons"},{"location":"Projects/Diffusion/Diffusion/#run-the-diffusion-step-with-desire-no-of-running-steps","text":"def run_diffuse (P,nrun,L): run = 0 '''diffuse N times''' while run < nrun: P = diffuse(P,L) run = run + 1 return P We can make a plot of arbitraty diffusion step by selecting \"irun\" in function runner. '''set parameters''' L = 100 ; nrun = 1000 ; P = start(L) '''run diffusion''' P = run_diffuse(P,nrun,L) plt . figure(figsize = [ 12 , 10 ]) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . savefig( 'plot/diffuse.pdf' ) plt . show()","title":"Run the diffusion step with desire no of running steps"},{"location":"Projects/Diffusion/Diffusion/#much-finner","text":"L = 200 nrun = 1000 P = start(L) '''run diffusion''' P = run_diffuse(P,nrun,L) plt . figure(figsize = [ 12 , 10 ]) sns . heatmap(P,annot = False ,cmap = 'YlGn' ) plt . savefig( 'plot/diffuse-finner.pdf' ) plt . show()","title":"Much Finner"},{"location":"Projects/Fern/fern/","text":"Project: Fern import numpy as np import json import matplotlib.pyplot as plt import seaborn as sns import random as random % matplotlib inline sns . set() Read more about Fern here . Method - 1: Direct implementation import random as random x = 0 y = 0 X = [x] Y = [y] n = 1 isprint = False while n < 1000000 : r = random . uniform( 0 , 100 ) if r < 1.0 : x = 0 y = 0.16 * Y[n - 1 ] X . append(x) ; Y . append(y) elif r > 1.0 and r < 86.0 : x = 0.85 * X[n - 1 ] + 0.04 * Y[n - 1 ] y = - 0.04 * X[n - 1 ] + 0.85 * Y[n - 1 ] + 1.6 X . append(x);Y . append(y) elif r > 86.0 and r < 93.0 : x = 0.2 * X[n - 1 ] - 0.26 * Y[n - 1 ] y = 0.23 * X[n - 1 ] + 0.22 * Y[n - 1 ] + 1.6 X . append(x);Y . append(y) elif r > 93.0 and r < 100.0 : x = - 0.15 * X[n - 1 ] + 0.28 * Y[n - 1 ] y = 0.26 * X[n - 1 ] + 0.24 * Y[n - 1 ] + 0.44 X . append(x);Y . append(y) if isprint: print ( \"step: \" ,n, \"random number is: \" , r, \"coordinate is : \" , x,y) n = n + 1 #for i in range(len(X)): # print(X[i],Y[i]) with open ( 'data/fern.json' , 'w' ) as f1: json . dump([X,Y],f1) plt . figure(figsize = [ 10 , 12 ]) plt . scatter(X,Y,color = 'g' ,marker = '.' ) plt . savefig( 'plot/charge-lattice.png' ) plt . savefig( 'plot/charge-lattice.pdf' ) plt . show() Method-2 : Manual Matrix Multiplication These correspond to the following transformations: $$ {\\displaystyle f_{1}(x,y)={\\begin{bmatrix}\\ 0.00&\\ 0.00\\ \\\\ 0.00&\\ 0.16\\end{bmatrix}}{\\begin{bmatrix}\\ x\\\\y\\end{bmatrix}}}$$ $${\\displaystyle f_{2}(x,y)={\\begin{bmatrix}\\ 0.85 &\\ 0.04\\ \\\\ -0.04&\\ 0.85\\end{bmatrix}}{\\begin{bmatrix}\\ x\\\\y\\end{bmatrix}}+{\\begin{bmatrix}\\ 0.00\\\\ 1.60\\end{bmatrix}}}$$ $$ {\\displaystyle f_{3}(x,y)={\\begin{bmatrix}\\ 0.20&\\ -0.26\\ \\\\ 0.23&\\ 0.22\\end{bmatrix}}{\\begin{bmatrix}\\ x\\\\y\\end{bmatrix}}+{\\begin{bmatrix}\\ 0.00\\\\ 1.60\\end{bmatrix}}}$$ $${\\displaystyle f_{4}(x,y)={\\begin{bmatrix}\\ -0.15&\\ 0.28\\ \\\\ 0.26&\\ 0.24\\end{bmatrix}}{\\begin{bmatrix}\\ x\\\\y\\end{bmatrix}}+{\\begin{bmatrix}\\ 0.00\\\\0.44\\end{bmatrix}}}$$ ITR = 100000 x = np . array([[ 0.0 , 0.0 ] for k in range (ITR)]) A = np . array([[ 0.0 , 0.0 ],[ 0.0 , 0.16 ]]) B = np . array([[ 0.85 , 0.04 ],[ - 0.04 , 0.85 ]]) C = np . array([[ 0.20 , - 0.26 ],[ 0.23 , 0.22 ]]) D = np . array([[ - 0.15 , 0.28 ],[ 0.26 , 0.24 ]]) AD = np . array([[ 0.0 , 0.0 ], [ 0.0 , 1.6 ], [ 0.0 , 1.6 ], [ 0.0 , 0.44 ]]) X = [] Y = [] x[ 0 , 0 ] = 0.0 x[ 0 , 1 ] = 0.0 t = 0 while t < ITR: ct = random . uniform( 0 , 100 ) '''First condition''' if ct < 1.0 : for p in range ( 2 ): x[t,p] = 0.0 for q in range ( 2 ): x[t,p] = x[t,p] + A[p,q] * x[t - 1 ,q] '''second condition''' elif ct > 1.0 and ct < 86.0 : for p in range ( 2 ): x[t,p] = 0.0 for q in range ( 2 ): x[t,p] = x[t,p] + B[p,q] * x[t - 1 ,q] for p in range ( 2 ): x[t,p] = x[t,p] + AD[ 1 ,p] '''third condition''' elif ct > 86.0 and ct < 93.0 : for p in range ( 2 ): x[t,p] = 0.0 for q in range ( 2 ): x[t,p] = x[t,p] + C[p,q] * x[t - 1 ,q] for p in range ( 2 ): x[t,p] = x[t,p] + AD[ 2 ,p] '''fourth condition ''' elif ct > 93.0 and ct < 100.0 : for p in range ( 2 ): x[ 1 ,p] = 0.0 for q in range ( 2 ): x[t,p] = x[t,p] + D[p,q] * x[t - 1 ,q] for p in range ( 2 ): x[t,p] = x[t,p] + AD[ 3 ,p] X . append(x[t, 0 ]) Y . append(x[t, 1 ]) t = t + 1 plt . figure(figsize = [ 10 , 12 ]) plt . scatter(X,Y,color = 'g' ,marker = '.' ) plt . savefig( 'plot/fern.pdf' ) plt . show() Method 3-Numpy '''Matrices''' A = np . array([[ 0.0 , 0.0 ],[ 0.0 , 0.16 ]]) B = np . array([[ 0.85 , 0.04 ],[ - 0.04 , 0.85 ]]) C = np . array([[ 0.20 , - 0.26 ],[ 0.23 , 0.22 ]]) D = np . array([[ - 0.15 , 0.28 ],[ 0.26 , 0.24 ]]) AD = np . array([[ 0.0 , 0.0 ], [ 0.0 , 1.6 ], [ 0.0 , 1.6 ], [ 0.0 , 0.44 ]]) u = np . array([ 0 , 0 ]) U = [u] n = 1 while n < 10000 : '''generate a random number''' r = random . uniform( 0 , 100 ) '''1rst condition''' if r < 1.0 : u = np . dot(A,u) U . append(u) '''second condition''' elif r > 1.0 and r < 86.0 : u = np . dot(B,u) + AD[ 1 ] U . append(u) '''third condition''' elif r > 86.0 and r < 93.0 : u = np . dot(C,u) + AD[ 2 ] U . append(u) '''fourth condition''' elif r > 93.0 and r < 100.0 : u = np . dot(D,u) + AD[ 3 ] U . append(u) '''update n''' n = n + 1 plt . figure(figsize = [ 10 , 12 ]) for item in U: plt . scatter(item[ 0 ],item[ 1 ],color = 'g' ,marker = '.' ) plt . show()","title":"Fern"},{"location":"Projects/Fern/fern/#project-fern","text":"import numpy as np import json import matplotlib.pyplot as plt import seaborn as sns import random as random % matplotlib inline sns . set() Read more about Fern here .","title":"Project: Fern"},{"location":"Projects/Fern/fern/#method-1-direct-implementation","text":"import random as random x = 0 y = 0 X = [x] Y = [y] n = 1 isprint = False while n < 1000000 : r = random . uniform( 0 , 100 ) if r < 1.0 : x = 0 y = 0.16 * Y[n - 1 ] X . append(x) ; Y . append(y) elif r > 1.0 and r < 86.0 : x = 0.85 * X[n - 1 ] + 0.04 * Y[n - 1 ] y = - 0.04 * X[n - 1 ] + 0.85 * Y[n - 1 ] + 1.6 X . append(x);Y . append(y) elif r > 86.0 and r < 93.0 : x = 0.2 * X[n - 1 ] - 0.26 * Y[n - 1 ] y = 0.23 * X[n - 1 ] + 0.22 * Y[n - 1 ] + 1.6 X . append(x);Y . append(y) elif r > 93.0 and r < 100.0 : x = - 0.15 * X[n - 1 ] + 0.28 * Y[n - 1 ] y = 0.26 * X[n - 1 ] + 0.24 * Y[n - 1 ] + 0.44 X . append(x);Y . append(y) if isprint: print ( \"step: \" ,n, \"random number is: \" , r, \"coordinate is : \" , x,y) n = n + 1 #for i in range(len(X)): # print(X[i],Y[i]) with open ( 'data/fern.json' , 'w' ) as f1: json . dump([X,Y],f1) plt . figure(figsize = [ 10 , 12 ]) plt . scatter(X,Y,color = 'g' ,marker = '.' ) plt . savefig( 'plot/charge-lattice.png' ) plt . savefig( 'plot/charge-lattice.pdf' ) plt . show()","title":"Method - 1: Direct implementation"},{"location":"Projects/Fern/fern/#method-2-manual-matrix-multiplication","text":"These correspond to the following transformations: $$ {\\displaystyle f_{1}(x,y)={\\begin{bmatrix}\\ 0.00&\\ 0.00\\ \\\\ 0.00&\\ 0.16\\end{bmatrix}}{\\begin{bmatrix}\\ x\\\\y\\end{bmatrix}}}$$ $${\\displaystyle f_{2}(x,y)={\\begin{bmatrix}\\ 0.85 &\\ 0.04\\ \\\\ -0.04&\\ 0.85\\end{bmatrix}}{\\begin{bmatrix}\\ x\\\\y\\end{bmatrix}}+{\\begin{bmatrix}\\ 0.00\\\\ 1.60\\end{bmatrix}}}$$ $$ {\\displaystyle f_{3}(x,y)={\\begin{bmatrix}\\ 0.20&\\ -0.26\\ \\\\ 0.23&\\ 0.22\\end{bmatrix}}{\\begin{bmatrix}\\ x\\\\y\\end{bmatrix}}+{\\begin{bmatrix}\\ 0.00\\\\ 1.60\\end{bmatrix}}}$$ $${\\displaystyle f_{4}(x,y)={\\begin{bmatrix}\\ -0.15&\\ 0.28\\ \\\\ 0.26&\\ 0.24\\end{bmatrix}}{\\begin{bmatrix}\\ x\\\\y\\end{bmatrix}}+{\\begin{bmatrix}\\ 0.00\\\\0.44\\end{bmatrix}}}$$ ITR = 100000 x = np . array([[ 0.0 , 0.0 ] for k in range (ITR)]) A = np . array([[ 0.0 , 0.0 ],[ 0.0 , 0.16 ]]) B = np . array([[ 0.85 , 0.04 ],[ - 0.04 , 0.85 ]]) C = np . array([[ 0.20 , - 0.26 ],[ 0.23 , 0.22 ]]) D = np . array([[ - 0.15 , 0.28 ],[ 0.26 , 0.24 ]]) AD = np . array([[ 0.0 , 0.0 ], [ 0.0 , 1.6 ], [ 0.0 , 1.6 ], [ 0.0 , 0.44 ]]) X = [] Y = [] x[ 0 , 0 ] = 0.0 x[ 0 , 1 ] = 0.0 t = 0 while t < ITR: ct = random . uniform( 0 , 100 ) '''First condition''' if ct < 1.0 : for p in range ( 2 ): x[t,p] = 0.0 for q in range ( 2 ): x[t,p] = x[t,p] + A[p,q] * x[t - 1 ,q] '''second condition''' elif ct > 1.0 and ct < 86.0 : for p in range ( 2 ): x[t,p] = 0.0 for q in range ( 2 ): x[t,p] = x[t,p] + B[p,q] * x[t - 1 ,q] for p in range ( 2 ): x[t,p] = x[t,p] + AD[ 1 ,p] '''third condition''' elif ct > 86.0 and ct < 93.0 : for p in range ( 2 ): x[t,p] = 0.0 for q in range ( 2 ): x[t,p] = x[t,p] + C[p,q] * x[t - 1 ,q] for p in range ( 2 ): x[t,p] = x[t,p] + AD[ 2 ,p] '''fourth condition ''' elif ct > 93.0 and ct < 100.0 : for p in range ( 2 ): x[ 1 ,p] = 0.0 for q in range ( 2 ): x[t,p] = x[t,p] + D[p,q] * x[t - 1 ,q] for p in range ( 2 ): x[t,p] = x[t,p] + AD[ 3 ,p] X . append(x[t, 0 ]) Y . append(x[t, 1 ]) t = t + 1 plt . figure(figsize = [ 10 , 12 ]) plt . scatter(X,Y,color = 'g' ,marker = '.' ) plt . savefig( 'plot/fern.pdf' ) plt . show()","title":"Method-2 : Manual Matrix Multiplication"},{"location":"Projects/Fern/fern/#method-3-numpy","text":"'''Matrices''' A = np . array([[ 0.0 , 0.0 ],[ 0.0 , 0.16 ]]) B = np . array([[ 0.85 , 0.04 ],[ - 0.04 , 0.85 ]]) C = np . array([[ 0.20 , - 0.26 ],[ 0.23 , 0.22 ]]) D = np . array([[ - 0.15 , 0.28 ],[ 0.26 , 0.24 ]]) AD = np . array([[ 0.0 , 0.0 ], [ 0.0 , 1.6 ], [ 0.0 , 1.6 ], [ 0.0 , 0.44 ]]) u = np . array([ 0 , 0 ]) U = [u] n = 1 while n < 10000 : '''generate a random number''' r = random . uniform( 0 , 100 ) '''1rst condition''' if r < 1.0 : u = np . dot(A,u) U . append(u) '''second condition''' elif r > 1.0 and r < 86.0 : u = np . dot(B,u) + AD[ 1 ] U . append(u) '''third condition''' elif r > 86.0 and r < 93.0 : u = np . dot(C,u) + AD[ 2 ] U . append(u) '''fourth condition''' elif r > 93.0 and r < 100.0 : u = np . dot(D,u) + AD[ 3 ] U . append(u) '''update n''' n = n + 1 plt . figure(figsize = [ 10 , 12 ]) for item in U: plt . scatter(item[ 0 ],item[ 1 ],color = 'g' ,marker = '.' ) plt . show()","title":"Method 3-Numpy"},{"location":"Projects/Ncharges/Ncharges/","text":"Project: N-charge system $$ E = q * \\frac{\\hat{r}}{r}$$ $$ V = q * \\frac{1}{r}$$ $$ V = q * \\frac{1}{\\sqrt{((x-x^{'})^{2} + (y - y^{'})^{2})}} $$ import matplotlib.pyplot as plt from matplotlib import cm % matplotlib inline import seaborn as sns sns . set() Class Charge class Charge : '''Data incapsulation''' def __init__ ( self , q, pos): self . q = q self . pos = pos def line ( self , x,y): '''create a vector from charge to observation point''' self . vector = [x - self . pos[ 0 ],y - self . pos[ 1 ]] '''norm of the vector''' self . norm = np . sqrt(( self . vector[ 0 ]) ** 2 + ( self . vector[ 1 ]) ** 2 ) def V_point_charge ( self , x, y): '''recall length''' self . line(x,y) '''Make sure to exclude source itself''' if self . norm > 0 : self . V = self . q / self . norm '''if length is zero, set V equal to 0''' else : self . V = 0 return self . V Example : Lets use charge q = 100 at posiotion x =5 and y =5 to find electric potential at different points in 2D C = Charge( 100 , [ 5 , 5 ]) for x in range ( 10 ): for y in range ( 10 ): print (x,y, \"|\" , C . V_point_charge(x, y)) 0 0 | 5.652334189442215 0 1 | 5.892556509887896 0 2 | 6.142951168339512 0 3 | 6.401843996644799 0 4 | 6.666666666666667 0 5 | 6.933752452815364 0 6 | 7.198157507486946 0 7 | 7.453559924999299 0 8 | 7.6923076923076925 0 9 | 7.905694150420948 1 0 | 5.872202195147034 1 1 | 6.142951168339512 1 2 | 6.42824346533225 1 3 | 6.726727939963125 1 4 | 7.035975447302919 1 5 | 7.352146220938077 1 6 | 7.669649888473704 1 7 | 7.9808688446762215 1 8 | 8.27605888602368 1 9 | 8.54357657716761 2 0 | 6.097107608496923 2 1 | 6.401843996644799 2 2 | 6.726727939963125 2 3 | 7.071067811865475 2 4 | 7.432941462471663 2 5 | 7.808688094430304 2 6 | 8.192319205190405 2 7 | 8.574929257125442 2 8 | 8.94427190999916 2 9 | 9.284766908852594 3 0 | 6.324555320336759 3 1 | 6.666666666666667 3 2 | 7.035975447302919 3 3 | 7.432941462471663 3 4 | 7.856742013183862 3 5 | 8.304547985373997 3 6 | 8.770580193070293 3 7 | 9.245003270420485 3 8 | 9.712858623572641 3 9 | 10.15346165133619 4 0 | 6.551217820804184 4 1 | 6.933752452815364 4 2 | 7.352146220938077 4 3 | 7.808688094430304 4 4 | 8.304547985373997 4 5 | 8.838834764831843 4 6 | 9.407208683835972 4 7 | 10.0 4 8 | 10.599978800063601 4 9 | 11.180339887498947 5 0 | 6.772854614785964 5 1 | 7.198157507486946 5 2 | 7.669649888473704 5 3 | 8.192319205190405 5 4 | 8.770580193070293 5 5 | 9.407208683835972 5 6 | 10.101525445522107 5 7 | 10.846522890932809 5 8 | 11.624763874381928 5 9 | 12.403473458920846 6 0 | 6.984302957695782 6 1 | 7.453559924999299 6 2 | 7.9808688446762215 6 3 | 8.574929257125442 6 4 | 9.245003270420485 6 5 | 10.0 6 6 | 10.846522890932809 6 7 | 11.785113019775793 6 8 | 12.803687993289598 6 9 | 13.867504905630728 7 0 | 7.179581586177381 7 1 | 7.6923076923076925 7 2 | 8.27605888602368 7 3 | 8.94427190999916 7 4 | 9.712858623572641 7 5 | 10.599978800063601 7 6 | 11.624763874381928 7 7 | 12.803687993289598 7 8 | 14.14213562373095 7 9 | 15.617376188860607 8 0 | 7.352146220938077 8 1 | 7.905694150420948 8 2 | 8.54357657716761 8 3 | 9.284766908852594 8 4 | 10.15346165133619 8 5 | 11.180339887498947 8 6 | 12.403473458920846 8 7 | 13.867504905630728 8 8 | 15.617376188860607 8 9 | 17.677669529663685 9 0 | 7.495316889958614 9 1 | 8.084520834544433 9 2 | 8.770580193070293 9 3 | 9.578262852211514 9 4 | 10.540925533894598 9 5 | 11.704114719613058 9 6 | 13.130643285972255 9 7 | 14.907119849998598 9 8 | 17.149858514250884 9 9 | 20.0 Total Electric potential def V_total (x, y, charges): V = 0 for C in charges: Vp = C . V_point_charge(x, y) V = V + Vp return V Example: Lets use collection of charges to find a electric potential at point x = 4, y =4 sample_charges = [Charge(q = 20 , pos = [ 23 , 34 ]), Charge(q = 25 , pos = [ 13 , 48 ]), Charge(q = 40 , pos = [ 3 , 14 ]), Charge(q = 80 , pos = [ 88 , 60 ])] V_total(x = 4 , y = 4 , charges = sample_charges) 5.892446541150622 Implementation - 1 : Lattice of charges '''first charge to be at x=1,y=1''' q = 100 '''Dictionary to collect charges, x and y xoordinates''' Qd = [] '''List to collect Charge objects''' charges = [] '''use for loops to construct collection of charges objects''' for i in range ( 5 ): for j in range ( 5 ): '''Collecting charges and their coordinates''' Qd . append({ \"q\" : q, \"x\" : i * 20 , \"y\" :j * 20 }) '''charge objects are being collected''' charges . append(Charge(q , [ 20 * i, 20 * j])) '''change the sign of charge alternatly''' q = - q import json with open ( 'data/charg-lattice.json' , 'w' ) as f1: json . dump(Qd,f1) Plot of lattice of charges '''Plot the lattice of charges''' plt . figure(figsize = [ 10 , 8 ]) for item in Qd: '''Sctaeer as red dot if charge is positive''' if item[ 'q' ] > 0 : plt . scatter(item[ 'x' ], item[ 'y' ], c = 'r' ) '''Scatter as blue dot if charge is negative''' else : plt . scatter(item[ 'x' ], item[ 'y' ], c = 'b' ) plt . savefig( 'plot/charge-lattice.pdf' ) plt . show() Find Electric Potential '''Create X and Y coordinate''' X = np . arange( - 10 , 110 , 1 ) Y = np . arange( - 10 , 110 , 1 ) '''Initiate vacant V-list of list''' V = [[ 0.0 for i in range ( len (X))] for j in range ( len (Y))] '''Calculate Electric potential at each x,y coordinate''' for i,x in enumerate (X): for j,y in enumerate (Y): v = V_total(x, y, charges) V[i][j] = v VV = np . array(V) Save electric potential data import json with open ( 'data/potential-lattice.json' , 'w' ) as f2: json . dump(V,f2) Plot Electric potential plt . figure(figsize = [ 18 , 14 ]) sns . heatmap(VV,annot = False ,cmap = 'YlGnBu' ) plt . savefig( 'plot/potential-lattice.png' ) plt . show() Implementation - 2 : Random Charges import random as random '''first charge to be at x=1,y=1''' q = 20 '''Dictionary to collect charges, x and y xoordinates''' Qd = [] '''List to collect Charge objects''' charges = [] '''use for loops to construct collection of charges objects''' for i in range ( 10 ): for j in range ( 10 ): rx = random . randint( 1 , 100 ) ry = random . randint( 1 , 100 ) '''collecting charges and their coordinates''' Qd . append({ \"q\" : q, \"x\" : rx, \"y\" :ry}) '''charge objects are being collected''' charges . append(Charge(q , [rx,ry])) '''change the sign of charge alternatly''' q = - q Save charge configuration import json with open ( 'data/charg-random.json' , 'w' ) as f3: json . dump(Qd,f3) Plot charge system '''Plot the lattice of charges''' plt . figure(figsize = [ 10 , 8 ]) for item in Qd: '''Sctaeer as red dot if charge is positive''' if item[ 'q' ] > 0 : plt . scatter(item[ 'x' ], item[ 'y' ], c = 'r' ) '''Scatter as blue dot if charge is negative''' else : plt . scatter(item[ 'x' ], item[ 'y' ], c = 'b' ) plt . savefig( 'plot/charge-random.pdf' ) plt . show() Calculate electric potential '''Create X and Y coordinate''' X = np . arange( - 10 , 110 , 1 ) Y = np . arange( - 10 , 110 , 1 ) '''Initiate vacant V-list of list''' V = [[ 0.0 for i in range ( len (X))] for j in range ( len (Y))] '''Calculate Electric potential at each x,y coordinate''' for i,x in enumerate (X): for j,y in enumerate (Y): v = V_total(x, y, charges) V[i][j] = v Save electric potential dta import json with open ( 'data/potential-random.json' , 'w' ) as f4: json . dump(V,f4) Plot potential V = np . array(V) plt . figure(figsize = [ 18 , 14 ]) sns . heatmap(V,annot = False ,cmap = 'YlGnBu' ) plt . savefig( 'plot/potential-random.pdf' ) plt . show() Much finner '''Create X and Y coordinate''' X = np . arange( - 10 , 110 , 0.5 ) Y = np . arange( - 10 , 110 , 0.5 ) '''Initiate vacant V-list of list''' V = [[ 0.0 for i in range ( len (X))] for j in range ( len (Y))] '''Calculate Electric potential at each x,y coordinate''' for i,x in enumerate (X): for j,y in enumerate (Y): v = V_total(x, y, charges) V[i][j] = v V = np . array(V) plt . figure(figsize = [ 18 , 14 ]) sns . heatmap(V,annot = False ,cmap = 'YlGnBu' ) plt . savefig( 'plot/potential-random.pdf' ) plt . show()","title":"Ncharges"},{"location":"Projects/Ncharges/Ncharges/#project-n-charge-system","text":"$$ E = q * \\frac{\\hat{r}}{r}$$ $$ V = q * \\frac{1}{r}$$ $$ V = q * \\frac{1}{\\sqrt{((x-x^{'})^{2} + (y - y^{'})^{2})}} $$ import matplotlib.pyplot as plt from matplotlib import cm % matplotlib inline import seaborn as sns sns . set()","title":"Project: N-charge system"},{"location":"Projects/Ncharges/Ncharges/#class-charge","text":"class Charge : '''Data incapsulation''' def __init__ ( self , q, pos): self . q = q self . pos = pos def line ( self , x,y): '''create a vector from charge to observation point''' self . vector = [x - self . pos[ 0 ],y - self . pos[ 1 ]] '''norm of the vector''' self . norm = np . sqrt(( self . vector[ 0 ]) ** 2 + ( self . vector[ 1 ]) ** 2 ) def V_point_charge ( self , x, y): '''recall length''' self . line(x,y) '''Make sure to exclude source itself''' if self . norm > 0 : self . V = self . q / self . norm '''if length is zero, set V equal to 0''' else : self . V = 0 return self . V","title":"Class Charge"},{"location":"Projects/Ncharges/Ncharges/#example","text":"Lets use charge q = 100 at posiotion x =5 and y =5 to find electric potential at different points in 2D C = Charge( 100 , [ 5 , 5 ]) for x in range ( 10 ): for y in range ( 10 ): print (x,y, \"|\" , C . V_point_charge(x, y)) 0 0 | 5.652334189442215 0 1 | 5.892556509887896 0 2 | 6.142951168339512 0 3 | 6.401843996644799 0 4 | 6.666666666666667 0 5 | 6.933752452815364 0 6 | 7.198157507486946 0 7 | 7.453559924999299 0 8 | 7.6923076923076925 0 9 | 7.905694150420948 1 0 | 5.872202195147034 1 1 | 6.142951168339512 1 2 | 6.42824346533225 1 3 | 6.726727939963125 1 4 | 7.035975447302919 1 5 | 7.352146220938077 1 6 | 7.669649888473704 1 7 | 7.9808688446762215 1 8 | 8.27605888602368 1 9 | 8.54357657716761 2 0 | 6.097107608496923 2 1 | 6.401843996644799 2 2 | 6.726727939963125 2 3 | 7.071067811865475 2 4 | 7.432941462471663 2 5 | 7.808688094430304 2 6 | 8.192319205190405 2 7 | 8.574929257125442 2 8 | 8.94427190999916 2 9 | 9.284766908852594 3 0 | 6.324555320336759 3 1 | 6.666666666666667 3 2 | 7.035975447302919 3 3 | 7.432941462471663 3 4 | 7.856742013183862 3 5 | 8.304547985373997 3 6 | 8.770580193070293 3 7 | 9.245003270420485 3 8 | 9.712858623572641 3 9 | 10.15346165133619 4 0 | 6.551217820804184 4 1 | 6.933752452815364 4 2 | 7.352146220938077 4 3 | 7.808688094430304 4 4 | 8.304547985373997 4 5 | 8.838834764831843 4 6 | 9.407208683835972 4 7 | 10.0 4 8 | 10.599978800063601 4 9 | 11.180339887498947 5 0 | 6.772854614785964 5 1 | 7.198157507486946 5 2 | 7.669649888473704 5 3 | 8.192319205190405 5 4 | 8.770580193070293 5 5 | 9.407208683835972 5 6 | 10.101525445522107 5 7 | 10.846522890932809 5 8 | 11.624763874381928 5 9 | 12.403473458920846 6 0 | 6.984302957695782 6 1 | 7.453559924999299 6 2 | 7.9808688446762215 6 3 | 8.574929257125442 6 4 | 9.245003270420485 6 5 | 10.0 6 6 | 10.846522890932809 6 7 | 11.785113019775793 6 8 | 12.803687993289598 6 9 | 13.867504905630728 7 0 | 7.179581586177381 7 1 | 7.6923076923076925 7 2 | 8.27605888602368 7 3 | 8.94427190999916 7 4 | 9.712858623572641 7 5 | 10.599978800063601 7 6 | 11.624763874381928 7 7 | 12.803687993289598 7 8 | 14.14213562373095 7 9 | 15.617376188860607 8 0 | 7.352146220938077 8 1 | 7.905694150420948 8 2 | 8.54357657716761 8 3 | 9.284766908852594 8 4 | 10.15346165133619 8 5 | 11.180339887498947 8 6 | 12.403473458920846 8 7 | 13.867504905630728 8 8 | 15.617376188860607 8 9 | 17.677669529663685 9 0 | 7.495316889958614 9 1 | 8.084520834544433 9 2 | 8.770580193070293 9 3 | 9.578262852211514 9 4 | 10.540925533894598 9 5 | 11.704114719613058 9 6 | 13.130643285972255 9 7 | 14.907119849998598 9 8 | 17.149858514250884 9 9 | 20.0","title":"Example :"},{"location":"Projects/Ncharges/Ncharges/#total-electric-potential","text":"def V_total (x, y, charges): V = 0 for C in charges: Vp = C . V_point_charge(x, y) V = V + Vp return V","title":"Total Electric potential"},{"location":"Projects/Ncharges/Ncharges/#example_1","text":"Lets use collection of charges to find a electric potential at point x = 4, y =4 sample_charges = [Charge(q = 20 , pos = [ 23 , 34 ]), Charge(q = 25 , pos = [ 13 , 48 ]), Charge(q = 40 , pos = [ 3 , 14 ]), Charge(q = 80 , pos = [ 88 , 60 ])] V_total(x = 4 , y = 4 , charges = sample_charges) 5.892446541150622","title":"Example:"},{"location":"Projects/Ncharges/Ncharges/#implementation-1-lattice-of-charges","text":"'''first charge to be at x=1,y=1''' q = 100 '''Dictionary to collect charges, x and y xoordinates''' Qd = [] '''List to collect Charge objects''' charges = [] '''use for loops to construct collection of charges objects''' for i in range ( 5 ): for j in range ( 5 ): '''Collecting charges and their coordinates''' Qd . append({ \"q\" : q, \"x\" : i * 20 , \"y\" :j * 20 }) '''charge objects are being collected''' charges . append(Charge(q , [ 20 * i, 20 * j])) '''change the sign of charge alternatly''' q = - q import json with open ( 'data/charg-lattice.json' , 'w' ) as f1: json . dump(Qd,f1)","title":"Implementation - 1 : Lattice of charges"},{"location":"Projects/Ncharges/Ncharges/#plot-of-lattice-of-charges","text":"'''Plot the lattice of charges''' plt . figure(figsize = [ 10 , 8 ]) for item in Qd: '''Sctaeer as red dot if charge is positive''' if item[ 'q' ] > 0 : plt . scatter(item[ 'x' ], item[ 'y' ], c = 'r' ) '''Scatter as blue dot if charge is negative''' else : plt . scatter(item[ 'x' ], item[ 'y' ], c = 'b' ) plt . savefig( 'plot/charge-lattice.pdf' ) plt . show()","title":"Plot of lattice of charges"},{"location":"Projects/Ncharges/Ncharges/#find-electric-potential","text":"'''Create X and Y coordinate''' X = np . arange( - 10 , 110 , 1 ) Y = np . arange( - 10 , 110 , 1 ) '''Initiate vacant V-list of list''' V = [[ 0.0 for i in range ( len (X))] for j in range ( len (Y))] '''Calculate Electric potential at each x,y coordinate''' for i,x in enumerate (X): for j,y in enumerate (Y): v = V_total(x, y, charges) V[i][j] = v VV = np . array(V)","title":"Find Electric Potential"},{"location":"Projects/Ncharges/Ncharges/#save-electric-potential-data","text":"import json with open ( 'data/potential-lattice.json' , 'w' ) as f2: json . dump(V,f2)","title":"Save electric potential data"},{"location":"Projects/Ncharges/Ncharges/#plot-electric-potential","text":"plt . figure(figsize = [ 18 , 14 ]) sns . heatmap(VV,annot = False ,cmap = 'YlGnBu' ) plt . savefig( 'plot/potential-lattice.png' ) plt . show()","title":"Plot Electric potential"},{"location":"Projects/Ncharges/Ncharges/#implementation-2-random-charges","text":"import random as random '''first charge to be at x=1,y=1''' q = 20 '''Dictionary to collect charges, x and y xoordinates''' Qd = [] '''List to collect Charge objects''' charges = [] '''use for loops to construct collection of charges objects''' for i in range ( 10 ): for j in range ( 10 ): rx = random . randint( 1 , 100 ) ry = random . randint( 1 , 100 ) '''collecting charges and their coordinates''' Qd . append({ \"q\" : q, \"x\" : rx, \"y\" :ry}) '''charge objects are being collected''' charges . append(Charge(q , [rx,ry])) '''change the sign of charge alternatly''' q = - q","title":"Implementation - 2 : Random Charges"},{"location":"Projects/Ncharges/Ncharges/#save-charge-configuration","text":"import json with open ( 'data/charg-random.json' , 'w' ) as f3: json . dump(Qd,f3)","title":"Save charge configuration"},{"location":"Projects/Ncharges/Ncharges/#plot-charge-system","text":"'''Plot the lattice of charges''' plt . figure(figsize = [ 10 , 8 ]) for item in Qd: '''Sctaeer as red dot if charge is positive''' if item[ 'q' ] > 0 : plt . scatter(item[ 'x' ], item[ 'y' ], c = 'r' ) '''Scatter as blue dot if charge is negative''' else : plt . scatter(item[ 'x' ], item[ 'y' ], c = 'b' ) plt . savefig( 'plot/charge-random.pdf' ) plt . show()","title":"Plot charge system"},{"location":"Projects/Ncharges/Ncharges/#calculate-electric-potential","text":"'''Create X and Y coordinate''' X = np . arange( - 10 , 110 , 1 ) Y = np . arange( - 10 , 110 , 1 ) '''Initiate vacant V-list of list''' V = [[ 0.0 for i in range ( len (X))] for j in range ( len (Y))] '''Calculate Electric potential at each x,y coordinate''' for i,x in enumerate (X): for j,y in enumerate (Y): v = V_total(x, y, charges) V[i][j] = v","title":"Calculate electric potential"},{"location":"Projects/Ncharges/Ncharges/#save-electric-potential-dta","text":"import json with open ( 'data/potential-random.json' , 'w' ) as f4: json . dump(V,f4)","title":"Save electric potential dta"},{"location":"Projects/Ncharges/Ncharges/#plot-potential","text":"V = np . array(V) plt . figure(figsize = [ 18 , 14 ]) sns . heatmap(V,annot = False ,cmap = 'YlGnBu' ) plt . savefig( 'plot/potential-random.pdf' ) plt . show()","title":"Plot potential"},{"location":"Projects/Ncharges/Ncharges/#much-finner","text":"'''Create X and Y coordinate''' X = np . arange( - 10 , 110 , 0.5 ) Y = np . arange( - 10 , 110 , 0.5 ) '''Initiate vacant V-list of list''' V = [[ 0.0 for i in range ( len (X))] for j in range ( len (Y))] '''Calculate Electric potential at each x,y coordinate''' for i,x in enumerate (X): for j,y in enumerate (Y): v = V_total(x, y, charges) V[i][j] = v V = np . array(V) plt . figure(figsize = [ 18 , 14 ]) sns . heatmap(V,annot = False ,cmap = 'YlGnBu' ) plt . savefig( 'plot/potential-random.pdf' ) plt . show()","title":"Much finner"},{"location":"Projects/Rwalk/Rwalk/","text":"Random Walk import numpy as np import random as random import matplotlib.pyplot as plt import seaborn as sns sns . set() Random walk in one dimension Direct Implementation '''X stores 1-D coordinate''' X = [] '''T stores time coordinate''' T = [] '''starting point''' x = 0 '''length of each step''' d = 1 '''iteratefor N steps''' for t in range ( 100 ): '''Walk one step ahead''' x = x + d * random . choice([ - 1 , 1 ]) '''collect time''' T . append(t) '''collect position''' X . append(x) '''Make a plot''' plt . figure(figsize = [ 12 , 6 ]) plt . scatter(T,X,marker = '.' ) plt . plot(T,X) plt . xlabel( \"Time\" ) plt . ylabel( 'Displacement' ) plt . grid( True ) plt . show() Implement with function def walk1D (x,N,d): '''This function returns the space 'X' and time 'T' for random walk in 1D x: initial position N: total number of steps d: step length''' '''X stores 1-D coordinate''' X = [] '''T stores time coordinate''' T = [] '''iteratefor N steps''' for t in range (N): '''Walk one step ahead''' x = x + d * random . choice([ - 1 , 1 ]) '''collect time''' T . append(t) '''collect position''' X . append(x) return X,T '''Implement function to get data''' X,T = walk1D(x = 0 ,N = 100 ,d = 1 ) '''Make a plot''' plt . figure(figsize = [ 12 , 6 ]) plt . scatter(T,X,marker = '.' ) plt . plot(T,X) plt . xlabel( \"Time\" ) plt . ylabel( 'Displacement' ) plt . grid( True ) plt . show() Object Oriented Programming class Walker1D ( object ): ''' This is a class to create on dimentional walk: x0 : initial position d : step size N : number of steps in random walk ''' def __init__ ( self ,N,d,x0): self . N = N self . X = [] self . d = d self . x0 = x0 def walk1D ( self ): '''note initial position''' x = self . x0 k = 0 while k < self . N: '''Walk one step ahead''' x = x + self . d * random . choice([ - 1 , 1 ]) '''collect position''' self . X . append(x) k = k + 1 return self . X Let's generate 4 different random walks of step 1000 each X1 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() X2 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() X3 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() X4 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() T = [i for i in range ( len (X1))] import json with open ( 'data/rwalk4.json' , 'w' ) as f4: json . dump([X1,X2,X3,X4,T],f4) Let's visualize them plt . figure(figsize = [ 20 , 12 ]) plt . plot(T,X1) plt . plot(T,X2) plt . plot(T,X3) plt . plot(T,X4) plt . xlabel( \"Time\" ) plt . ylabel( 'Displacement' ) plt . grid( True ) plt . savefig( 'plot/rwalk4.pdf' ) plt . show() Random Walk in 2D Create a function to walk a single step def move2D (xi,yi): ''' This function choose a direction and walk one step in 2D ''' direction = random . choice([ 'x' , 'y' ]) if direction == 'x' : r = random . choice([ - 1 , 1 ]) if r == 1 :xf = xi + 1 else : xf = xi - 1 yf = yi if direction == 'y' : r = random . choice([ - 1 , 1 ]) if r == 1 :yf = yi + 1 else : yf = yi - 1 xf = xi return xf,yf Lets walk in 2D using above function def walk2D (N,pos): ''' This function walks N step in 2d implementing move2D ''' '''coordinate collectors''' X = [] ; Y = [] '''from where to start''' x0 = pos[ 0 ] ; y0 = pos[ 0 ] k = 0 while k < N: '''move a step''' x,y = move2D(x0,y0) '''collect X coordinate''' X . append(x) '''collect Y coordinate''' Y . append(y) '''set previous position for next step''' x0 = x y0 = y k = k + 1 return X,Y Lets create a 3 different Random walk in 2D N = 10000 U = walk2D(N,[ 0 , 0 ]) V = walk2D(N,[ 0 , 0 ]) W = walk2D(N,[ 0 , 0 ]) with open ( 'data/rwalk4.json' , 'w' ) as f: json . dump([U,V,W],f) plt . figure(figsize = [ 15 , 12 ]) plt . plot(U[ 0 ],U[ 1 ], \"-\" ) plt . plot(V[ 0 ],V[ 1 ], \"-\" ) plt . plot(W[ 0 ],W[ 1 ], \"-\" ) plt . axis([ - 100 , 100 , - 100 , 100 ]) plt . xlabel( \"x-axis\" ) plt . ylabel( \"y-axis\" ) plt . grid( True ) plt . title( \"Brownian motion in 2D\" ) plt . savefig( 'plot/rwalk2D.pdf' ) plt . show()","title":"Project Random Walk"},{"location":"Projects/Rwalk/Rwalk/#random-walk","text":"import numpy as np import random as random import matplotlib.pyplot as plt import seaborn as sns sns . set()","title":"Random Walk"},{"location":"Projects/Rwalk/Rwalk/#random-walk-in-one-dimension","text":"","title":"Random walk in one dimension"},{"location":"Projects/Rwalk/Rwalk/#direct-implementation","text":"'''X stores 1-D coordinate''' X = [] '''T stores time coordinate''' T = [] '''starting point''' x = 0 '''length of each step''' d = 1 '''iteratefor N steps''' for t in range ( 100 ): '''Walk one step ahead''' x = x + d * random . choice([ - 1 , 1 ]) '''collect time''' T . append(t) '''collect position''' X . append(x) '''Make a plot''' plt . figure(figsize = [ 12 , 6 ]) plt . scatter(T,X,marker = '.' ) plt . plot(T,X) plt . xlabel( \"Time\" ) plt . ylabel( 'Displacement' ) plt . grid( True ) plt . show()","title":"Direct Implementation"},{"location":"Projects/Rwalk/Rwalk/#implement-with-function","text":"def walk1D (x,N,d): '''This function returns the space 'X' and time 'T' for random walk in 1D x: initial position N: total number of steps d: step length''' '''X stores 1-D coordinate''' X = [] '''T stores time coordinate''' T = [] '''iteratefor N steps''' for t in range (N): '''Walk one step ahead''' x = x + d * random . choice([ - 1 , 1 ]) '''collect time''' T . append(t) '''collect position''' X . append(x) return X,T '''Implement function to get data''' X,T = walk1D(x = 0 ,N = 100 ,d = 1 ) '''Make a plot''' plt . figure(figsize = [ 12 , 6 ]) plt . scatter(T,X,marker = '.' ) plt . plot(T,X) plt . xlabel( \"Time\" ) plt . ylabel( 'Displacement' ) plt . grid( True ) plt . show()","title":"Implement with function"},{"location":"Projects/Rwalk/Rwalk/#object-oriented-programming","text":"class Walker1D ( object ): ''' This is a class to create on dimentional walk: x0 : initial position d : step size N : number of steps in random walk ''' def __init__ ( self ,N,d,x0): self . N = N self . X = [] self . d = d self . x0 = x0 def walk1D ( self ): '''note initial position''' x = self . x0 k = 0 while k < self . N: '''Walk one step ahead''' x = x + self . d * random . choice([ - 1 , 1 ]) '''collect position''' self . X . append(x) k = k + 1 return self . X","title":"Object Oriented Programming"},{"location":"Projects/Rwalk/Rwalk/#lets-generate-4-different-random-walks-of-step-1000-each","text":"X1 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() X2 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() X3 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() X4 = Walker1D(N = 1000 ,d = 1 ,x0 = 0 ) . walk1D() T = [i for i in range ( len (X1))] import json with open ( 'data/rwalk4.json' , 'w' ) as f4: json . dump([X1,X2,X3,X4,T],f4)","title":"Let's generate 4 different random walks of step 1000 each"},{"location":"Projects/Rwalk/Rwalk/#lets-visualize-them","text":"plt . figure(figsize = [ 20 , 12 ]) plt . plot(T,X1) plt . plot(T,X2) plt . plot(T,X3) plt . plot(T,X4) plt . xlabel( \"Time\" ) plt . ylabel( 'Displacement' ) plt . grid( True ) plt . savefig( 'plot/rwalk4.pdf' ) plt . show()","title":"Let's visualize them"},{"location":"Projects/Rwalk/Rwalk/#random-walk-in-2d","text":"","title":"Random Walk in 2D"},{"location":"Projects/Rwalk/Rwalk/#create-a-function-to-walk-a-single-step","text":"def move2D (xi,yi): ''' This function choose a direction and walk one step in 2D ''' direction = random . choice([ 'x' , 'y' ]) if direction == 'x' : r = random . choice([ - 1 , 1 ]) if r == 1 :xf = xi + 1 else : xf = xi - 1 yf = yi if direction == 'y' : r = random . choice([ - 1 , 1 ]) if r == 1 :yf = yi + 1 else : yf = yi - 1 xf = xi return xf,yf","title":"Create a function to walk a single step"},{"location":"Projects/Rwalk/Rwalk/#lets-walk-in-2d-using-above-function","text":"def walk2D (N,pos): ''' This function walks N step in 2d implementing move2D ''' '''coordinate collectors''' X = [] ; Y = [] '''from where to start''' x0 = pos[ 0 ] ; y0 = pos[ 0 ] k = 0 while k < N: '''move a step''' x,y = move2D(x0,y0) '''collect X coordinate''' X . append(x) '''collect Y coordinate''' Y . append(y) '''set previous position for next step''' x0 = x y0 = y k = k + 1 return X,Y","title":"Lets walk in 2D using above function"},{"location":"Projects/Rwalk/Rwalk/#lets-create-a-3-different-random-walk-in-2d","text":"N = 10000 U = walk2D(N,[ 0 , 0 ]) V = walk2D(N,[ 0 , 0 ]) W = walk2D(N,[ 0 , 0 ]) with open ( 'data/rwalk4.json' , 'w' ) as f: json . dump([U,V,W],f) plt . figure(figsize = [ 15 , 12 ]) plt . plot(U[ 0 ],U[ 1 ], \"-\" ) plt . plot(V[ 0 ],V[ 1 ], \"-\" ) plt . plot(W[ 0 ],W[ 1 ], \"-\" ) plt . axis([ - 100 , 100 , - 100 , 100 ]) plt . xlabel( \"x-axis\" ) plt . ylabel( \"y-axis\" ) plt . grid( True ) plt . title( \"Brownian motion in 2D\" ) plt . savefig( 'plot/rwalk2D.pdf' ) plt . show()","title":"Lets create a 3 different Random walk in 2D"},{"location":"Python/ds/","text":"Fundamental Data Structure : List, Tuple and Dictionary List To initiate a blank List. l = [] To find the type of the object. type (l) list To create a list from scratch. L = [ 1 , 2 , 3 , 4 , 5 , 6 ] Indexing of list. L[ 0 ],L[ 1 ],L[ 5 ] (1, 2, 6) Revers indexing is also possible. L[ - 1 ],L[ - 2 ],L[ - 3 ] (6, 5, 4) To find the length of list. len (L) 6 To add the element from last. L . append( 12 ) L [1, 2, 3, 4, 5, 6, 12] To find the sum of the elements (if they are of same types like int. double etc) sum (L) 33 To find maximum and minimum of the list max (L), min (L) (12, 1) To create a list of heterogeneous element types. L = [ 1 , 2.0 , 3 , 4 , 5 , \"Apple\" ] To find the type of elements of a list. type (L[ 1 ]), type (L[ 5 ]) (float, str) To create a list of list. L = [[ 1 , 2 , 3 ],[ 3 , 4 , 5 ],[ 5 , 7 , 9 ]] To find list inside a list. L[ 0 ] [1, 2, 3] L[ 0 ][ 1 ] 2 To add list L1 = [ 1 , 2 , 3 ] ; L2 = [ 2 , 4 , 6 ] L1 + L2, set (L1 + L2) ([1, 2, 3, 2, 4, 6], {1, 2, 3, 4, 6}) To create array for algebraic operations import numpy as np L1 = np . array([ 1 , 2 , 3 ]); L2 = np . array([ 2 , 4 , 6 ]) L1 + L2 array([3, 6, 9]) To iterate over the element of list L = [i for i in range ( 10 )] L [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] To create a random List import random as random L = [random . uniform( 0 , 1 ) for k in range ( 10 )] L [0.43053490647858217, 0.4042754547551368, 0.4825961844418639, 0.07969436319497114, 0.5359042493237792, 0.521045536638314, 0.9657067090287339, 0.11515389590934644, 0.20310645682803774, 0.3875919385817722] To create a random list of lists LL = [[random . uniform( 0 , 1 ) for k in range ( 3 )] for l in range ( 3 )] LL [[0.27628847122005273, 0.8897450734835115, 0.18989122408874082], [0.13835865058469599, 0.7262672634594681, 0.10898554004253247], [0.42276719493338266, 0.11377775037902738, 0.4901096855852801]] To save the data to json file import json with open ( 'data/mylist.json' , 'w' ) as f1: json . dump(LL,f1) Tuples To define a tuples from scratch t = ( 2 , 3 , 4 , 5 ) Find type type (t) tuple Indexing t[ 1 ] 3 Dictionary To initiate a dictionary D = dict () DD = {} Create a dictionary from scratch D = { \"fruit\" : 'apple' , \"vegetable\" : 'carrot' , \"rice\" : 2.0 , 'milk' : 10 ,} What are keys? D . keys() dict_keys(['fruit', 'vegetable', 'rice', 'milk']) What are values? D . values() dict_values(['apple', 'carrot', 2.0, 10]) Indexing D[ 'fruit' ] 'apple' Iteration over key and values for key,value in D . items(): print (key,value) fruit apple vegetable carrot rice 2.0 milk 10 Update a dictionary D . update({ \"salt\" : 2.0 }) D {'fruit': 'apple', 'vegetable': 'carrot', 'rice': 2.0, 'milk': 10, 'salt': 2.0} Create a list form a Dictionary list (D) ['fruit', 'vegetable', 'rice', 'milk', 'salt'] Create a list of keys list (D . keys()) ['fruit', 'vegetable', 'rice', 'milk', 'salt'] Create a list of values list (D . values()) ['apple', 'carrot', 2.0, 10, 2.0] Create a random Dictionary DD = {} for item in [ 'A' , 'B' , 'C' , 'D' , 'E' ]: DD . update({item:[random . uniform( 0 , 1 ) for k in range ( 10 )]}) DD {'A': [0.8623300586958146, 0.9817282451404751, 0.918013419185538, 0.7163654763224003, 0.9605939306786828, 0.10535569850024595, 0.11017993829505879, 0.7967874445465515, 0.40100560974033395, 0.6683804538904957], 'B': [0.9108032733225849, 0.5126845596833859, 0.2889475226297349, 0.4361419616905007, 0.9162781988261498, 0.6417420997937421, 0.5703303219382578, 0.8317203028864074, 0.9987773067590386, 0.19901433153401582], 'C': [0.6877286885216957, 0.16565933820204293, 0.25063345210121424, 0.31595887595060124, 0.03522116131022823, 0.5286776181365936, 0.8154337189974739, 0.8202821745739262, 0.0672014040433101, 0.12327287509980445], 'D': [0.4836330819912691, 0.8546497284804153, 0.14752285825255218, 0.5918584543549938, 0.14518319590340412, 0.025762251428333438, 0.016788596008689316, 0.009725555304236244, 0.8177641188673302, 0.5450138847266498], 'E': [0.6456541452062622, 0.7662672636891902, 0.04445215914793821, 0.3159171150800496, 0.9400712936126994, 0.6085210458061509, 0.6029509689621034, 0.34555270993185316, 0.7452915466172698, 0.03229045002223074]} Save a dictionary to a json file import json with open ( 'data/mydic.json' , 'w' ) as f2: json . dump(DD,f2)","title":"Fundamental Data Structure :"},{"location":"Python/ds/#fundamental-data-structure","text":"","title":"Fundamental Data Structure :"},{"location":"Python/ds/#list-tuple-and-dictionary","text":"","title":"List, Tuple and Dictionary"},{"location":"Python/ds/#list","text":"To initiate a blank List. l = [] To find the type of the object. type (l) list To create a list from scratch. L = [ 1 , 2 , 3 , 4 , 5 , 6 ] Indexing of list. L[ 0 ],L[ 1 ],L[ 5 ] (1, 2, 6) Revers indexing is also possible. L[ - 1 ],L[ - 2 ],L[ - 3 ] (6, 5, 4) To find the length of list. len (L) 6 To add the element from last. L . append( 12 ) L [1, 2, 3, 4, 5, 6, 12] To find the sum of the elements (if they are of same types like int. double etc) sum (L) 33 To find maximum and minimum of the list max (L), min (L) (12, 1) To create a list of heterogeneous element types. L = [ 1 , 2.0 , 3 , 4 , 5 , \"Apple\" ] To find the type of elements of a list. type (L[ 1 ]), type (L[ 5 ]) (float, str) To create a list of list. L = [[ 1 , 2 , 3 ],[ 3 , 4 , 5 ],[ 5 , 7 , 9 ]] To find list inside a list. L[ 0 ] [1, 2, 3] L[ 0 ][ 1 ] 2 To add list L1 = [ 1 , 2 , 3 ] ; L2 = [ 2 , 4 , 6 ] L1 + L2, set (L1 + L2) ([1, 2, 3, 2, 4, 6], {1, 2, 3, 4, 6}) To create array for algebraic operations import numpy as np L1 = np . array([ 1 , 2 , 3 ]); L2 = np . array([ 2 , 4 , 6 ]) L1 + L2 array([3, 6, 9]) To iterate over the element of list L = [i for i in range ( 10 )] L [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] To create a random List import random as random L = [random . uniform( 0 , 1 ) for k in range ( 10 )] L [0.43053490647858217, 0.4042754547551368, 0.4825961844418639, 0.07969436319497114, 0.5359042493237792, 0.521045536638314, 0.9657067090287339, 0.11515389590934644, 0.20310645682803774, 0.3875919385817722] To create a random list of lists LL = [[random . uniform( 0 , 1 ) for k in range ( 3 )] for l in range ( 3 )] LL [[0.27628847122005273, 0.8897450734835115, 0.18989122408874082], [0.13835865058469599, 0.7262672634594681, 0.10898554004253247], [0.42276719493338266, 0.11377775037902738, 0.4901096855852801]] To save the data to json file import json with open ( 'data/mylist.json' , 'w' ) as f1: json . dump(LL,f1)","title":"List"},{"location":"Python/ds/#tuples","text":"To define a tuples from scratch t = ( 2 , 3 , 4 , 5 ) Find type type (t) tuple Indexing t[ 1 ] 3","title":"Tuples"},{"location":"Python/ds/#dictionary","text":"To initiate a dictionary D = dict () DD = {} Create a dictionary from scratch D = { \"fruit\" : 'apple' , \"vegetable\" : 'carrot' , \"rice\" : 2.0 , 'milk' : 10 ,} What are keys? D . keys() dict_keys(['fruit', 'vegetable', 'rice', 'milk']) What are values? D . values() dict_values(['apple', 'carrot', 2.0, 10]) Indexing D[ 'fruit' ] 'apple' Iteration over key and values for key,value in D . items(): print (key,value) fruit apple vegetable carrot rice 2.0 milk 10 Update a dictionary D . update({ \"salt\" : 2.0 }) D {'fruit': 'apple', 'vegetable': 'carrot', 'rice': 2.0, 'milk': 10, 'salt': 2.0} Create a list form a Dictionary list (D) ['fruit', 'vegetable', 'rice', 'milk', 'salt'] Create a list of keys list (D . keys()) ['fruit', 'vegetable', 'rice', 'milk', 'salt'] Create a list of values list (D . values()) ['apple', 'carrot', 2.0, 10, 2.0] Create a random Dictionary DD = {} for item in [ 'A' , 'B' , 'C' , 'D' , 'E' ]: DD . update({item:[random . uniform( 0 , 1 ) for k in range ( 10 )]}) DD {'A': [0.8623300586958146, 0.9817282451404751, 0.918013419185538, 0.7163654763224003, 0.9605939306786828, 0.10535569850024595, 0.11017993829505879, 0.7967874445465515, 0.40100560974033395, 0.6683804538904957], 'B': [0.9108032733225849, 0.5126845596833859, 0.2889475226297349, 0.4361419616905007, 0.9162781988261498, 0.6417420997937421, 0.5703303219382578, 0.8317203028864074, 0.9987773067590386, 0.19901433153401582], 'C': [0.6877286885216957, 0.16565933820204293, 0.25063345210121424, 0.31595887595060124, 0.03522116131022823, 0.5286776181365936, 0.8154337189974739, 0.8202821745739262, 0.0672014040433101, 0.12327287509980445], 'D': [0.4836330819912691, 0.8546497284804153, 0.14752285825255218, 0.5918584543549938, 0.14518319590340412, 0.025762251428333438, 0.016788596008689316, 0.009725555304236244, 0.8177641188673302, 0.5450138847266498], 'E': [0.6456541452062622, 0.7662672636891902, 0.04445215914793821, 0.3159171150800496, 0.9400712936126994, 0.6085210458061509, 0.6029509689621034, 0.34555270993185316, 0.7452915466172698, 0.03229045002223074]} Save a dictionary to a json file import json with open ( 'data/mydic.json' , 'w' ) as f2: json . dump(DD,f2)","title":"Dictionary"},{"location":"Python/fnc/","text":"Functions and Classes import numpy as np Class Circle Define a function which will take radious as input and provides area as output for a circle. def area (r): A = np . pi * r ** 2 return A Claculate the area of a sample circle of radius 10. area( 10 ) 314.1592653589793 Define a function which will take radious as input and provides circumference as output for a circle. def circumference (r): C = 2 * np . pi * r return C Claculate the circumference of a sample circle of radius 10. circumference( 10 ) 62.83185307179586 Lets build a class implementing above constants and functions class Circle (): def __init__ ( self , r): self . r = r def area ( self ): A = np . pi * self . r ** 2 return A def circumference ( self ): C = 2 * np . pi * self . r return C Test using examples Circle( 5 ) . area() 78.53981633974483 CC = Circle( 5 ) CC . area(),CC . circumference() (78.53981633974483, 31.41592653589793) CC . r 5 for r in [ 2 , 3 , 6 , 24 , 25 , 46 , 567 ]: CC = Circle(r) print ( \"radius: \" , r,\\ \"area : \" , CC . area(),\\ \"circumf : \" , CC . circumference()) radius: 2 area : 12.566370614359172 circumf : 12.566370614359172 radius: 3 area : 28.274333882308138 circumf : 18.84955592153876 radius: 6 area : 113.09733552923255 circumf : 37.69911184307752 radius: 24 area : 1809.5573684677208 circumf : 150.79644737231007 radius: 25 area : 1963.4954084936207 circumf : 157.07963267948966 radius: 46 area : 6647.610054996002 circumf : 289.02652413026095 radius: 567 area : 1009987.480609929 circumf : 3562.5660691708254 Class Gravity def gravity (m1,m2,d): F = (m1 * m2) / d ** 2 return F gravity( 5 , 4 , 10 ) 0.2 Lets create a class for Gravity calculation class Newton (): def __init__ ( self ,value_of_G, value_of_g, supplied_info): self . G = value_of_G self . info = supplied_info self . g = value_of_g def gravity ( self ,m1,m2,d): F = self . G * (m1 * m2) / d ** 2 print ( self . info) return F def gravity_pot ( self ,m1): F = m1 * self . g return F N1 = Newton(value_of_G = 6.7 , value_of_g = 9.8 ,\\ supplied_info = \"great job\" ) N1 . G, N1 . g,N1 . gravity( 2 , 3 , 13 ),N1 . gravity_pot( 12 ) great job (6.7, 9.8, 0.2378698224852071, 117.60000000000001) N1 . gravity(m1 = 11 ,m2 = 12 ,d = 3 ) great job 98.26666666666667","title":"Functions and Classes"},{"location":"Python/fnc/#functions-and-classes","text":"import numpy as np","title":"Functions and Classes"},{"location":"Python/fnc/#class-circle","text":"Define a function which will take radious as input and provides area as output for a circle. def area (r): A = np . pi * r ** 2 return A Claculate the area of a sample circle of radius 10. area( 10 ) 314.1592653589793 Define a function which will take radious as input and provides circumference as output for a circle. def circumference (r): C = 2 * np . pi * r return C Claculate the circumference of a sample circle of radius 10. circumference( 10 ) 62.83185307179586 Lets build a class implementing above constants and functions class Circle (): def __init__ ( self , r): self . r = r def area ( self ): A = np . pi * self . r ** 2 return A def circumference ( self ): C = 2 * np . pi * self . r return C Test using examples Circle( 5 ) . area() 78.53981633974483 CC = Circle( 5 ) CC . area(),CC . circumference() (78.53981633974483, 31.41592653589793) CC . r 5 for r in [ 2 , 3 , 6 , 24 , 25 , 46 , 567 ]: CC = Circle(r) print ( \"radius: \" , r,\\ \"area : \" , CC . area(),\\ \"circumf : \" , CC . circumference()) radius: 2 area : 12.566370614359172 circumf : 12.566370614359172 radius: 3 area : 28.274333882308138 circumf : 18.84955592153876 radius: 6 area : 113.09733552923255 circumf : 37.69911184307752 radius: 24 area : 1809.5573684677208 circumf : 150.79644737231007 radius: 25 area : 1963.4954084936207 circumf : 157.07963267948966 radius: 46 area : 6647.610054996002 circumf : 289.02652413026095 radius: 567 area : 1009987.480609929 circumf : 3562.5660691708254","title":"Class Circle"},{"location":"Python/fnc/#class-gravity","text":"def gravity (m1,m2,d): F = (m1 * m2) / d ** 2 return F gravity( 5 , 4 , 10 ) 0.2 Lets create a class for Gravity calculation class Newton (): def __init__ ( self ,value_of_G, value_of_g, supplied_info): self . G = value_of_G self . info = supplied_info self . g = value_of_g def gravity ( self ,m1,m2,d): F = self . G * (m1 * m2) / d ** 2 print ( self . info) return F def gravity_pot ( self ,m1): F = m1 * self . g return F N1 = Newton(value_of_G = 6.7 , value_of_g = 9.8 ,\\ supplied_info = \"great job\" ) N1 . G, N1 . g,N1 . gravity( 2 , 3 , 13 ),N1 . gravity_pot( 12 ) great job (6.7, 9.8, 0.2378698224852071, 117.60000000000001) N1 . gravity(m1 = 11 ,m2 = 12 ,d = 3 ) great job 98.26666666666667","title":"Class Gravity"},{"location":"Python/lnc/","text":"Loops and conditions L = [ 'apple' , 'banana' , 'kite' , 'cellphone' ] '''Iterate over the items in a list''' for item in L: print (item) apple banana kite cellphone L = [] for k in range ( 10 ): print (k) '''Append values to list L''' L . append( 10 * k) 0 1 2 3 4 5 6 7 8 9 L [0, 10, 20, 30, 40, 50, 60, 70, 80, 90] D = {} for i in range ( 5 ): for j in range ( 5 ): if i == j : print (i, \"is equal to\" ,j) '''update dictionary with (i,j) as key and 2*i as value''' D . update({(i,j) : 10 * i + j}) elif i != j: '''update dictionary with (i,j) as key and 2*i as value''' D . update({(i,j) : 101 * i + j}) print (i, \"is not equal to\" ,j) 0 is equal to 0 0 is not equal to 1 0 is not equal to 2 0 is not equal to 3 0 is not equal to 4 1 is not equal to 0 1 is equal to 1 1 is not equal to 2 1 is not equal to 3 1 is not equal to 4 2 is not equal to 0 2 is not equal to 1 2 is equal to 2 2 is not equal to 3 2 is not equal to 4 3 is not equal to 0 3 is not equal to 1 3 is not equal to 2 3 is equal to 3 3 is not equal to 4 4 is not equal to 0 4 is not equal to 1 4 is not equal to 2 4 is not equal to 3 4 is equal to 4 D {(0, 0): 0, (0, 1): 1, (0, 2): 2, (0, 3): 3, (0, 4): 4, (1, 0): 101, (1, 1): 11, (1, 2): 103, (1, 3): 104, (1, 4): 105, (2, 0): 202, (2, 1): 203, (2, 2): 22, (2, 3): 205, (2, 4): 206, (3, 0): 303, (3, 1): 304, (3, 2): 305, (3, 3): 33, (3, 4): 307, (4, 0): 404, (4, 1): 405, (4, 2): 406, (4, 3): 407, (4, 4): 44} range ( 5 ) range(0, 5) for i,j in zip ( range ( 5 ), range ( 5 )): print (i,j) 0 0 1 1 2 2 3 3 4 4 for item,j in zip ([ 'apple' , 'banana' , 'kite' , 'cellphone' , 'pen' ], range ( 5 )): print (item,j) apple 0 banana 1 kite 2 cellphone 3 pen 4 for i,item in enumerate ([ 'apple' , 'banana' , 'kite' , 'cellphone' ]): print (i, item) 0 apple 1 banana 2 kite 3 cellphone A = [ 0 for k in range ( 10 )] A [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] A = [k for k in range ( 10 )] A [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] L = [[ 1 , 2 , 3 ],[ 3 , 4 , 5 ],[ 5 , 7 , 9 ]] for i in range ( len (L)): for j in range ( len (L[ 0 ])): print (L[i][j]) 1 2 3 3 4 5 5 7 9 LL = [[k + j for k in range ( 10 )] for j in range ( 10 )] LL [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [3, 4, 5, 6, 7, 8, 9, 10, 11, 12], [4, 5, 6, 7, 8, 9, 10, 11, 12, 13], [5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [8, 9, 10, 11, 12, 13, 14, 15, 16, 17], [9, 10, 11, 12, 13, 14, 15, 16, 17, 18]] i = 0 while i < 10 : print ( i, \"th turn\" ) i = i + 1 0 th turn 1 th turn 2 th turn 3 th turn 4 th turn 5 th turn 6 th turn 7 th turn 8 th turn 9 th turn import json '''download''' with open ( 'data/mylist.json' , 'w' ) as f1: json . dump(LL,f1) import json '''upload''' with open ( 'data/mydic.json' , 'r' ) as f2: AA = json . load(f2) for key,value in AA . items(): print ( \"key : \" , key, \"|\" , \"value: \" , value) key : A | value: [0.8623300586958146, 0.9817282451404751, 0.918013419185538, 0.7163654763224003, 0.9605939306786828, 0.10535569850024595, 0.11017993829505879, 0.7967874445465515, 0.40100560974033395, 0.6683804538904957] key : B | value: [0.9108032733225849, 0.5126845596833859, 0.2889475226297349, 0.4361419616905007, 0.9162781988261498, 0.6417420997937421, 0.5703303219382578, 0.8317203028864074, 0.9987773067590386, 0.19901433153401582] key : C | value: [0.6877286885216957, 0.16565933820204293, 0.25063345210121424, 0.31595887595060124, 0.03522116131022823, 0.5286776181365936, 0.8154337189974739, 0.8202821745739262, 0.0672014040433101, 0.12327287509980445] key : D | value: [0.4836330819912691, 0.8546497284804153, 0.14752285825255218, 0.5918584543549938, 0.14518319590340412, 0.025762251428333438, 0.016788596008689316, 0.009725555304236244, 0.8177641188673302, 0.5450138847266498] key : E | value: [0.6456541452062622, 0.7662672636891902, 0.04445215914793821, 0.3159171150800496, 0.9400712936126994, 0.6085210458061509, 0.6029509689621034, 0.34555270993185316, 0.7452915466172698, 0.03229045002223074] DNA = 'ATGCATGCATATCAAGCTAGCTAGCTAGCTAGCTAGAGCTATTTAATGCTA \\ GCTATATAGCGCTAGCTATAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCT \\ AGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCGCGCGCTA \\ TATATAGAGAGAGAGAGAGACACACATATATCTCTCTCTCTCGAGATCGAT \\ CGTACTAGCTAGCTAGCTAGCTAGCTAGCT' DNA . count( 'A' ),DNA . count( 'AT' ) (66, 16) count = 0 for letter in DNA: if letter == 'T' : count = count + 1 count 61 'I am ok' . split() ['I', 'am', 'ok'] Q: find sum from 0 to 1000 s = 0 for i in range ( 1000 + 1 ): s = s + i s 500500 Q: find sum from 0 to 1000 (only even) s = 0 LE = [] for i in range ( 1001 ): if i % 2 == 0 : LE . append(i) s = s + i s, sum (LE) (250500, 250500)","title":"Loops and conditions"},{"location":"Python/lnc/#loops-and-conditions","text":"L = [ 'apple' , 'banana' , 'kite' , 'cellphone' ] '''Iterate over the items in a list''' for item in L: print (item) apple banana kite cellphone L = [] for k in range ( 10 ): print (k) '''Append values to list L''' L . append( 10 * k) 0 1 2 3 4 5 6 7 8 9 L [0, 10, 20, 30, 40, 50, 60, 70, 80, 90] D = {} for i in range ( 5 ): for j in range ( 5 ): if i == j : print (i, \"is equal to\" ,j) '''update dictionary with (i,j) as key and 2*i as value''' D . update({(i,j) : 10 * i + j}) elif i != j: '''update dictionary with (i,j) as key and 2*i as value''' D . update({(i,j) : 101 * i + j}) print (i, \"is not equal to\" ,j) 0 is equal to 0 0 is not equal to 1 0 is not equal to 2 0 is not equal to 3 0 is not equal to 4 1 is not equal to 0 1 is equal to 1 1 is not equal to 2 1 is not equal to 3 1 is not equal to 4 2 is not equal to 0 2 is not equal to 1 2 is equal to 2 2 is not equal to 3 2 is not equal to 4 3 is not equal to 0 3 is not equal to 1 3 is not equal to 2 3 is equal to 3 3 is not equal to 4 4 is not equal to 0 4 is not equal to 1 4 is not equal to 2 4 is not equal to 3 4 is equal to 4 D {(0, 0): 0, (0, 1): 1, (0, 2): 2, (0, 3): 3, (0, 4): 4, (1, 0): 101, (1, 1): 11, (1, 2): 103, (1, 3): 104, (1, 4): 105, (2, 0): 202, (2, 1): 203, (2, 2): 22, (2, 3): 205, (2, 4): 206, (3, 0): 303, (3, 1): 304, (3, 2): 305, (3, 3): 33, (3, 4): 307, (4, 0): 404, (4, 1): 405, (4, 2): 406, (4, 3): 407, (4, 4): 44} range ( 5 ) range(0, 5) for i,j in zip ( range ( 5 ), range ( 5 )): print (i,j) 0 0 1 1 2 2 3 3 4 4 for item,j in zip ([ 'apple' , 'banana' , 'kite' , 'cellphone' , 'pen' ], range ( 5 )): print (item,j) apple 0 banana 1 kite 2 cellphone 3 pen 4 for i,item in enumerate ([ 'apple' , 'banana' , 'kite' , 'cellphone' ]): print (i, item) 0 apple 1 banana 2 kite 3 cellphone A = [ 0 for k in range ( 10 )] A [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] A = [k for k in range ( 10 )] A [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] L = [[ 1 , 2 , 3 ],[ 3 , 4 , 5 ],[ 5 , 7 , 9 ]] for i in range ( len (L)): for j in range ( len (L[ 0 ])): print (L[i][j]) 1 2 3 3 4 5 5 7 9 LL = [[k + j for k in range ( 10 )] for j in range ( 10 )] LL [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [3, 4, 5, 6, 7, 8, 9, 10, 11, 12], [4, 5, 6, 7, 8, 9, 10, 11, 12, 13], [5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [8, 9, 10, 11, 12, 13, 14, 15, 16, 17], [9, 10, 11, 12, 13, 14, 15, 16, 17, 18]] i = 0 while i < 10 : print ( i, \"th turn\" ) i = i + 1 0 th turn 1 th turn 2 th turn 3 th turn 4 th turn 5 th turn 6 th turn 7 th turn 8 th turn 9 th turn import json '''download''' with open ( 'data/mylist.json' , 'w' ) as f1: json . dump(LL,f1) import json '''upload''' with open ( 'data/mydic.json' , 'r' ) as f2: AA = json . load(f2) for key,value in AA . items(): print ( \"key : \" , key, \"|\" , \"value: \" , value) key : A | value: [0.8623300586958146, 0.9817282451404751, 0.918013419185538, 0.7163654763224003, 0.9605939306786828, 0.10535569850024595, 0.11017993829505879, 0.7967874445465515, 0.40100560974033395, 0.6683804538904957] key : B | value: [0.9108032733225849, 0.5126845596833859, 0.2889475226297349, 0.4361419616905007, 0.9162781988261498, 0.6417420997937421, 0.5703303219382578, 0.8317203028864074, 0.9987773067590386, 0.19901433153401582] key : C | value: [0.6877286885216957, 0.16565933820204293, 0.25063345210121424, 0.31595887595060124, 0.03522116131022823, 0.5286776181365936, 0.8154337189974739, 0.8202821745739262, 0.0672014040433101, 0.12327287509980445] key : D | value: [0.4836330819912691, 0.8546497284804153, 0.14752285825255218, 0.5918584543549938, 0.14518319590340412, 0.025762251428333438, 0.016788596008689316, 0.009725555304236244, 0.8177641188673302, 0.5450138847266498] key : E | value: [0.6456541452062622, 0.7662672636891902, 0.04445215914793821, 0.3159171150800496, 0.9400712936126994, 0.6085210458061509, 0.6029509689621034, 0.34555270993185316, 0.7452915466172698, 0.03229045002223074] DNA = 'ATGCATGCATATCAAGCTAGCTAGCTAGCTAGCTAGAGCTATTTAATGCTA \\ GCTATATAGCGCTAGCTATAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCT \\ AGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCGCGCGCTA \\ TATATAGAGAGAGAGAGAGACACACATATATCTCTCTCTCTCGAGATCGAT \\ CGTACTAGCTAGCTAGCTAGCTAGCTAGCT' DNA . count( 'A' ),DNA . count( 'AT' ) (66, 16) count = 0 for letter in DNA: if letter == 'T' : count = count + 1 count 61 'I am ok' . split() ['I', 'am', 'ok']","title":"Loops and conditions"},{"location":"Python/lnc/#q-find-sum-from-0-to-1000","text":"s = 0 for i in range ( 1000 + 1 ): s = s + i s 500500","title":"Q: find sum from 0 to 1000"},{"location":"Python/lnc/#q-find-sum-from-0-to-1000-only-even","text":"s = 0 LE = [] for i in range ( 1001 ): if i % 2 == 0 : LE . append(i) s = s + i s, sum (LE) (250500, 250500)","title":"Q: find sum from 0 to 1000 (only even)"},{"location":"optimization/SimulatedAnealing/simulatedAnn/","text":"Simulated Annealing By Dibakar Sigdel : Date April-26-2016 Introduction to Simulated Annealing Simulated annealing [1] copies a phenomenon in nature--the annealing of solids--to optimize a complex system. Annealing refers to heating a solid and then cooling it slowly. Atoms then assume a nearly globally minimum energy state. In 1953 Metropolis created an algorithm to simulate the annealing process. The algorithm simulates a small random displacement of an atom that results in a change in energy. If the change in energy is negative, the energy state of the new configuration is lower and the new configuration is accepted. If the change in energy is positive, the new configuration has a higher energy state; however, it may still be accepted according to the Boltzmann probability factor: $$P = exp(\\frac{-\\triangle E}{K_{b}T})$$ where $K_b$ is the Boltzmann constant and T is the current temperature. By examining this equation we should note two things: the probability is proportional to temperature--as the solid cools, the probability gets smaller; and inversely proportional to --as the change in energy is larger the probability of accepting the change gets smaller. Pictorial Algorithm from IPython.display import Image Image(filename = 'sim.png' ) When applied to engineering design, an analogy is made between energy and the objective function. The design is started at a high \u201ctemperature\u201d, where it has a high objective (we assume we are minimizing). Random perturbations are then made to the design. If the objective is lower, the new design is made the current design; if it is higher, it may still be accepted according the probability given by the Boltzmann factor. The Boltzmann probability is compared to a random number drawn from a uniform distribution between 0 and 1; if the random number is smaller than the Boltzmann probability, the configuration is accepted. This allows the algorithm to escape local minima. Required Libraries import matplotlib import numpy as np import matplotlib.pyplot as plt import random import math from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm from matplotlib.ticker import LinearLocator, FormatStrFormatter import matplotlib.pyplot as plt import numpy as np % matplotlib inline Part -I : Problem set up Define Objective function Consider a 2D system where atoms are interacting with the surface of a material. A model for the interaction potential is $$V(x) = V_{o}\\left \\lbrace nA + \\sum_{i=1}^{n}[x_{i}^{2} - A \\cos(2\\pi x_{i})]\\right \\rbrace $$ where $n = 2$: two dimensions. A = 10; $V_{o}$ is in energy unit. Consider the section $x_{1,2} \\in [-4,4]$ of the surface. Surface Potential function def potential (x1,x2): obj = ( 2 * 10.0 ) + x1 ** 2 + x2 ** 2 - ( 10.0 ) * (math . cos( 2.0 * 3.1415 * x1) - math . cos( 2.0 * 3.1415 * x2)) return obj Design variables for mesh points ix = np . arange( - 4.0 , 4.0 , 0.05 ) iy = np . arange( - 4.0 , 4.0 , 0.05 ) X,Y = np . meshgrid(ix, iy) fz = np . zeros(X . shape) for i in range (X . shape[ 0 ]): for j in range (X . shape[ 1 ]): fz[i][j] = potential(X[i][j],Y[i][j]) 3D plot of surface potential fig = plt . figure(figsize = ( 14 , 10 )) ax = fig . gca(projection = '3d' ) surf = ax . plot_surface(X, Y, fz, rstride = 1 , cstride = 1 , cmap = cm . coolwarm, linewidth = 0 , antialiased = False ) ax . set_zlim( - 0.01 , 60.01 ) ax . zaxis . set_major_locator(LinearLocator( 10 )) ax . zaxis . set_major_formatter(FormatStrFormatter( ' %.02f ' )) fig . colorbar(surf, shrink = 0.5 , aspect = 5 ) plt . show() Density Plot of surface potential plt . figure(figsize = ( 12 , 8 )) # Specify contour lines CS = plt . contour(x1m, x2m, fm) #,lines) # Label contours plt . clabel(CS, inline = 1 , fontsize = 10 ) # Add some text to the plot plt . title( 'Density plot of surface potential' ) plt . xlabel( 'x1' ) plt . ylabel( 'x2' ) &lt;matplotlib.text.Text at 0x12e704410&gt; Part - II : Simulation Task Put $N = 1000$ atoms on the surface. Compute a configuration $X_{o} = {x_{1},...,x_{N}}$ of minial potential energy $E[X_{o}]$ using simulated annealing. Apply Bose statistics, any number of atoms may occupy a local minimum $\\vec{x}_{min}$. Simulation setting # Start location x_start = [ 0.5 , - 0.5 ] #Number of particles N = 1000 # Number of cycles n = 1000 # Number of trials per cycle m = 500 # Number of accepted solutions na = 0.0 # Probability of accepting worse solution at the start p1 = 0.7 # Probability of accepting worse solution at the end p50 = 0.001 # Initial temperature t1 = - 1.0 / math . log(p1) # Final temperature t50 = - 1.0 / math . log(p50) # Fractional reduction every cycle frac = (t50 / t1) ** ( 1.0 / (n - 1.0 )) # Initialize x x = np . zeros((n + 1 , 2 )) x[ 0 ] = x_start xi = np . zeros( 2 ) xi = x_start na = na + 1.0 # Current best results so far xc = np . zeros( 2 ) xc = x[ 0 ] fc = potential(xi[ 0 ],xi[ 1 ]) fs = np . zeros(n + 1 ) fs[ 0 ] = fc # Current temperature t = t1 # DeltaE Average DeltaE_avg = 0.0 Simulation for i in range (n): #print 'Cycle: ' + str(i) + ' with Temperature: ' + str(t) for j in range (m): # Generate new trial points xi[ 0 ] = xc[ 0 ] + random . random() - 0.5 xi[ 1 ] = xc[ 1 ] + random . random() - 0.5 # Clip to upper and lower bounds xi[ 0 ] = max ( min (xi[ 0 ], 1.0 ), - 1.0 ) xi[ 1 ] = max ( min (xi[ 1 ], 1.0 ), - 1.0 ) DeltaE = abs (f(xi) - fc) if (potential(xi[ 0 ],xi[ 1 ]) > fc): # Initialize DeltaE_avg if a worse solution was found # on the first iteration if (i == 0 and j == 0 ): DeltaE_avg = DeltaE # objective function is worse # generate probability of acceptance p = math . exp( - DeltaE / (DeltaE_avg * t)) # determine whether to accept worse point if (random . random() < p): # accept the worse solution accept = True else : # don't accept the worse solution accept = False else : # objective function is lower, automatically accept accept = True if (accept == True ): # update currently accepted solution xc[ 0 ] = xi[ 0 ] xc[ 1 ] = xi[ 1 ] fc = potential(xc[ 0 ],xc[ 1 ]) # increment number of accepted solutions na = na + 1.0 # update DeltaE_avg DeltaE_avg = (DeltaE_avg * (na - 1.0 ) + DeltaE) / na # Record the best x values at the end of every cycle x[i + 1 ][ 0 ] = xc[ 0 ] x[i + 1 ][ 1 ] = xc[ 1 ] fs[i + 1 ] = fc # Lower the temperature for next cycle t = frac * t # print solution print 'Best solution: ' + str (xc) print 'Best objective: ' + str (fc) plt . figure(figsize = ( 10 , 8 )) plt . plot(x[:, 0 ],x[:, 1 ], 'y-o' ) #plt.savefig('contour.png') fig = plt . figure(figsize = ( 10 , 8 )) ax1 = fig . add_subplot( 211 ) ax1 . plot(fs, 'r.-' ) ax1 . legend([ 'Objective' ]) ax2 = fig . add_subplot( 212 ) ax2 . plot(x[:, 0 ], 'b.-' ) ax2 . plot(x[:, 1 ], 'g--' ) ax2 . legend([ 'x1' , 'x2' ]) # Save the figure as a PNG #plt.savefig('iterations.png') plt . show() Best solution: [ 0.91536557 -0.66902677] Best objective: 7.79514624035 Repeat this for 1000 particles References 1 . Simulated Annealing Tutorial http://apmonitor.com/me575/index.php/Main/SimulatedAnnealing 2 . The Simulated Annealing Algorithm http://katrinaeg.com/simulated-annealing.html 3 . Simulated Annealing for beginners http://www.theprojectspot.com/tutorial-post/simulated-annealing-algorithm-for-beginners/6 4 . Simulated Annealing: http://csg.sph.umich.edu/abecasis/class/2006/615.19.pdf 5 . Simulated Annealing : http://mathworld.wolfram.com/SimulatedAnnealing.html","title":"Simulated Annealing"},{"location":"optimization/SimulatedAnealing/simulatedAnn/#simulated-annealing","text":"By Dibakar Sigdel : Date April-26-2016","title":"Simulated Annealing"},{"location":"optimization/SimulatedAnealing/simulatedAnn/#introduction-to-simulated-annealing","text":"Simulated annealing [1] copies a phenomenon in nature--the annealing of solids--to optimize a complex system. Annealing refers to heating a solid and then cooling it slowly. Atoms then assume a nearly globally minimum energy state. In 1953 Metropolis created an algorithm to simulate the annealing process. The algorithm simulates a small random displacement of an atom that results in a change in energy. If the change in energy is negative, the energy state of the new configuration is lower and the new configuration is accepted. If the change in energy is positive, the new configuration has a higher energy state; however, it may still be accepted according to the Boltzmann probability factor: $$P = exp(\\frac{-\\triangle E}{K_{b}T})$$ where $K_b$ is the Boltzmann constant and T is the current temperature. By examining this equation we should note two things: the probability is proportional to temperature--as the solid cools, the probability gets smaller; and inversely proportional to --as the change in energy is larger the probability of accepting the change gets smaller. Pictorial Algorithm from IPython.display import Image Image(filename = 'sim.png' ) When applied to engineering design, an analogy is made between energy and the objective function. The design is started at a high \u201ctemperature\u201d, where it has a high objective (we assume we are minimizing). Random perturbations are then made to the design. If the objective is lower, the new design is made the current design; if it is higher, it may still be accepted according the probability given by the Boltzmann factor. The Boltzmann probability is compared to a random number drawn from a uniform distribution between 0 and 1; if the random number is smaller than the Boltzmann probability, the configuration is accepted. This allows the algorithm to escape local minima. Required Libraries import matplotlib import numpy as np import matplotlib.pyplot as plt import random import math from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm from matplotlib.ticker import LinearLocator, FormatStrFormatter import matplotlib.pyplot as plt import numpy as np % matplotlib inline","title":"Introduction to Simulated Annealing"},{"location":"optimization/SimulatedAnealing/simulatedAnn/#part-i-problem-set-up","text":"","title":"Part -I : Problem set up"},{"location":"optimization/SimulatedAnealing/simulatedAnn/#define-objective-function","text":"Consider a 2D system where atoms are interacting with the surface of a material. A model for the interaction potential is $$V(x) = V_{o}\\left \\lbrace nA + \\sum_{i=1}^{n}[x_{i}^{2} - A \\cos(2\\pi x_{i})]\\right \\rbrace $$ where $n = 2$: two dimensions. A = 10; $V_{o}$ is in energy unit. Consider the section $x_{1,2} \\in [-4,4]$ of the surface. Surface Potential function def potential (x1,x2): obj = ( 2 * 10.0 ) + x1 ** 2 + x2 ** 2 - ( 10.0 ) * (math . cos( 2.0 * 3.1415 * x1) - math . cos( 2.0 * 3.1415 * x2)) return obj Design variables for mesh points ix = np . arange( - 4.0 , 4.0 , 0.05 ) iy = np . arange( - 4.0 , 4.0 , 0.05 ) X,Y = np . meshgrid(ix, iy) fz = np . zeros(X . shape) for i in range (X . shape[ 0 ]): for j in range (X . shape[ 1 ]): fz[i][j] = potential(X[i][j],Y[i][j])","title":"Define Objective function"},{"location":"optimization/SimulatedAnealing/simulatedAnn/#3d-plot-of-surface-potential","text":"fig = plt . figure(figsize = ( 14 , 10 )) ax = fig . gca(projection = '3d' ) surf = ax . plot_surface(X, Y, fz, rstride = 1 , cstride = 1 , cmap = cm . coolwarm, linewidth = 0 , antialiased = False ) ax . set_zlim( - 0.01 , 60.01 ) ax . zaxis . set_major_locator(LinearLocator( 10 )) ax . zaxis . set_major_formatter(FormatStrFormatter( ' %.02f ' )) fig . colorbar(surf, shrink = 0.5 , aspect = 5 ) plt . show()","title":"3D plot of surface potential"},{"location":"optimization/SimulatedAnealing/simulatedAnn/#density-plot-of-surface-potential","text":"plt . figure(figsize = ( 12 , 8 )) # Specify contour lines CS = plt . contour(x1m, x2m, fm) #,lines) # Label contours plt . clabel(CS, inline = 1 , fontsize = 10 ) # Add some text to the plot plt . title( 'Density plot of surface potential' ) plt . xlabel( 'x1' ) plt . ylabel( 'x2' ) &lt;matplotlib.text.Text at 0x12e704410&gt;","title":"Density Plot of surface potential"},{"location":"optimization/SimulatedAnealing/simulatedAnn/#part-ii-simulation","text":"","title":"Part - II : Simulation"},{"location":"optimization/SimulatedAnealing/simulatedAnn/#task","text":"Put $N = 1000$ atoms on the surface. Compute a configuration $X_{o} = {x_{1},...,x_{N}}$ of minial potential energy $E[X_{o}]$ using simulated annealing. Apply Bose statistics, any number of atoms may occupy a local minimum $\\vec{x}_{min}$. Simulation setting # Start location x_start = [ 0.5 , - 0.5 ] #Number of particles N = 1000 # Number of cycles n = 1000 # Number of trials per cycle m = 500 # Number of accepted solutions na = 0.0 # Probability of accepting worse solution at the start p1 = 0.7 # Probability of accepting worse solution at the end p50 = 0.001 # Initial temperature t1 = - 1.0 / math . log(p1) # Final temperature t50 = - 1.0 / math . log(p50) # Fractional reduction every cycle frac = (t50 / t1) ** ( 1.0 / (n - 1.0 )) # Initialize x x = np . zeros((n + 1 , 2 )) x[ 0 ] = x_start xi = np . zeros( 2 ) xi = x_start na = na + 1.0 # Current best results so far xc = np . zeros( 2 ) xc = x[ 0 ] fc = potential(xi[ 0 ],xi[ 1 ]) fs = np . zeros(n + 1 ) fs[ 0 ] = fc # Current temperature t = t1 # DeltaE Average DeltaE_avg = 0.0 Simulation for i in range (n): #print 'Cycle: ' + str(i) + ' with Temperature: ' + str(t) for j in range (m): # Generate new trial points xi[ 0 ] = xc[ 0 ] + random . random() - 0.5 xi[ 1 ] = xc[ 1 ] + random . random() - 0.5 # Clip to upper and lower bounds xi[ 0 ] = max ( min (xi[ 0 ], 1.0 ), - 1.0 ) xi[ 1 ] = max ( min (xi[ 1 ], 1.0 ), - 1.0 ) DeltaE = abs (f(xi) - fc) if (potential(xi[ 0 ],xi[ 1 ]) > fc): # Initialize DeltaE_avg if a worse solution was found # on the first iteration if (i == 0 and j == 0 ): DeltaE_avg = DeltaE # objective function is worse # generate probability of acceptance p = math . exp( - DeltaE / (DeltaE_avg * t)) # determine whether to accept worse point if (random . random() < p): # accept the worse solution accept = True else : # don't accept the worse solution accept = False else : # objective function is lower, automatically accept accept = True if (accept == True ): # update currently accepted solution xc[ 0 ] = xi[ 0 ] xc[ 1 ] = xi[ 1 ] fc = potential(xc[ 0 ],xc[ 1 ]) # increment number of accepted solutions na = na + 1.0 # update DeltaE_avg DeltaE_avg = (DeltaE_avg * (na - 1.0 ) + DeltaE) / na # Record the best x values at the end of every cycle x[i + 1 ][ 0 ] = xc[ 0 ] x[i + 1 ][ 1 ] = xc[ 1 ] fs[i + 1 ] = fc # Lower the temperature for next cycle t = frac * t # print solution print 'Best solution: ' + str (xc) print 'Best objective: ' + str (fc) plt . figure(figsize = ( 10 , 8 )) plt . plot(x[:, 0 ],x[:, 1 ], 'y-o' ) #plt.savefig('contour.png') fig = plt . figure(figsize = ( 10 , 8 )) ax1 = fig . add_subplot( 211 ) ax1 . plot(fs, 'r.-' ) ax1 . legend([ 'Objective' ]) ax2 = fig . add_subplot( 212 ) ax2 . plot(x[:, 0 ], 'b.-' ) ax2 . plot(x[:, 1 ], 'g--' ) ax2 . legend([ 'x1' , 'x2' ]) # Save the figure as a PNG #plt.savefig('iterations.png') plt . show() Best solution: [ 0.91536557 -0.66902677] Best objective: 7.79514624035 Repeat this for 1000 particles","title":"Task"},{"location":"optimization/SimulatedAnealing/simulatedAnn/#references","text":"1 . Simulated Annealing Tutorial http://apmonitor.com/me575/index.php/Main/SimulatedAnnealing 2 . The Simulated Annealing Algorithm http://katrinaeg.com/simulated-annealing.html 3 . Simulated Annealing for beginners http://www.theprojectspot.com/tutorial-post/simulated-annealing-algorithm-for-beginners/6 4 . Simulated Annealing: http://csg.sph.umich.edu/abecasis/class/2006/615.19.pdf 5 . Simulated Annealing : http://mathworld.wolfram.com/SimulatedAnnealing.html","title":"References"},{"location":"optimization/intro/Optimization/","text":"Scipy Optimization Source SciPy optimize provides functions for minimizing (or maximizing) objective functions, possibly subject to constraints. It includes solvers for nonlinear problems (with support for both local and global optimization algorithms), linear programing, constrained and nonlinear least-squares, root finding and curve fitting. Scalar Functions Optimization Local (Multivariate) Optimization Global Optimization Least-squares and Curve Fitting Root finding Gradient Descient import numpy as np import numpy.linalg as la import scipy.optimize as sopt import matplotlib.pyplot as pt from mpl_toolkits.mplot3d import axes3d % matplotlib inline import seaborn as sns sns . set() Spherical Surface : $$F(x,y) = x^{2} + y^{2}$$ def sphere (x): return x[ 0 ] ** 2 + x[ 1 ] ** 2 def df_sphere (x): return np . array([ 2.0 * x[ 0 ], 2.0 * x[ 1 ]]) Plot Surfaces Sphere fig = pt . figure(figsize = [ 8 , 8 ]) ax = fig . gca(projection = \"3d\" ) xmesh, ymesh = np . mgrid[ - 2 : 2 : 50j , - 2 : 2 : 50j ] fmesh = sphere(np . array([xmesh, ymesh])) ax . plot_surface(xmesh, ymesh, fmesh) &lt;mpl_toolkits.mplot3d.art3d.Poly3DCollection at 0x1a18961550&gt; Plot Concors pt . figure( figsize = [ 5 , 5 ]) pt . axis( \"equal\" ) pt . contour(xmesh, ymesh, fmesh, 20 ) &lt;matplotlib.contour.QuadContourSet at 0x7f0bfe84f7b8&gt; Find Minimum guesses = [np . array([ 2 , 2 ])] for i in range ( 10000 ): x = guesses[ - 1 ] s = - df_sphere(x) alpha = 0.001 next_guess = x + alpha * s guesses . append(next_guess) guesses[ 0 : 10 ] [array([2, 2]), array([1.996, 1.996]), array([1.992008, 1.992008]), array([1.98802398, 1.98802398]), array([1.98404794, 1.98404794]), array([1.98007984, 1.98007984]), array([1.97611968, 1.97611968]), array([1.97216744, 1.97216744]), array([1.96822311, 1.96822311]), array([1.96428666, 1.96428666])] pt . figure( figsize = [ 5 , 5 ]) pt . axis( \"equal\" ) pt . contour(xmesh, ymesh, fmesh, 10 ) it_array = np . array(guesses) pt . plot(it_array . T[ 0 ], it_array . T[ 1 ], \"o\" ) [&lt;matplotlib.lines.Line2D at 0x7f0bfea38828&gt;] Abritrary Surface source def surface (x): return np . sin( 0.5 * x[ 0 ] ** 2 - 0.25 * x[ 1 ] ** 2 + 3 ) * np . cos( 2.0 * x[ 0 ] + 1.0 + np . exp(x[ 1 ])) def df_surface (x): u = np . sin( 0.5 * x[ 0 ] ** 2 - 0.25 * x[ 1 ] ** 2 + 3 ) u_x = np . cos( 0.5 * x[ 0 ] ** 2 - 0.25 * x[ 1 ] ** 2 + 3 ) * x[ 0 ] u_y = - np . cos( 0.5 * x[ 0 ] ** 2 - 0.25 * x[ 1 ] ** 2 + 3 ) * 0.5 * x[ 1 ] v = np . cos( 2.0 * x[ 0 ] + 1.0 + np . exp(x[ 1 ])) v_x = - np . sin( 2.0 * x[ 0 ] + 1.0 + np . exp(x[ 1 ])) * 2.0 v_y = np . sin( 2.0 * x[ 0 ] + 1.0 + np . exp(x[ 1 ])) * np . exp(x[ 1 ]) df_x = u_x * v + u * v_x df_y = u_y * v + u * v_y return np . array([df_x,df_y]) Plot Surface fig = pt . figure(figsize = [ 8 , 8 ]) ax = fig . gca(projection = \"3d\" ) xmesh, ymesh = np . mgrid[ - 2 : 2 : 50j , - 2 : 2 : 50j ] fmesh = surface(np . array([xmesh, ymesh])) ax . plot_surface(xmesh, ymesh, fmesh) &lt;mpl_toolkits.mplot3d.art3d.Poly3DCollection at 0x7f0bfea68cc0&gt; Plot Contor pt . figure( figsize = [ 5 , 5 ]) pt . axis( \"equal\" ) pt . contour(xmesh, ymesh, fmesh, 20 ) &lt;matplotlib.contour.QuadContourSet at 0x7f0bfeb2d390&gt; guesses = [np . array([ - 0.25 , 0.5 ])] for i in range ( 100000 ): x = guesses[ - 1 ] s = - df_surface(x) alpha = 0.0001 next_guess = x + alpha * s guesses . append(next_guess) guesses[ 0 : 10 ] [array([-0.25, 0.5 ]), array([-0.24995774, 0.4999897 ]), array([-0.24991547, 0.49997941]), array([-0.24987321, 0.49996911]), array([-0.24983095, 0.49995882]), array([-0.24978869, 0.49994853]), array([-0.24974643, 0.49993824]), array([-0.24970417, 0.49992795]), array([-0.24966191, 0.49991766]), array([-0.24961965, 0.49990738])] pt . figure( figsize = [ 5 , 5 ]) pt . axis( \"equal\" ) pt . contour(xmesh, ymesh, fmesh, 10 ) it_array = np . array(guesses) pt . plot(it_array . T[ 0 ], it_array . T[ 1 ], \"o\" ) [&lt;matplotlib.lines.Line2D at 0x7f0bfdcb7e80&gt;] Scipy Optimization from scipy.optimize import minimize Sphere x0 = [np . array([ 5 , 5 ])] res = minimize(sphere, x0, method = 'nelder-mead' , options = { 'xtol' : 1e-8 , 'disp' : True }) Optimization terminated successfully. Current function value: 0.000000 Iterations: 73 Function evaluations: 137 res final_simplex: (array([[-1.53149299e-09, 3.72359970e-09], [-1.89733109e-09, -4.32207878e-09], [ 5.12426026e-09, -1.63696990e-09]]), array([1.62106655e-17, 2.22802302e-17, 2.89377136e-17])) fun: 1.6210665476880626e-17 message: 'Optimization terminated successfully.' nfev: 137 nit: 73 status: 0 success: True x: array([-1.53149299e-09, 3.72359970e-09]) Surface x0 = [np . array([ - 0.25 , 0.5 ])] res = minimize(surface, x0, method = 'nelder-mead' , options = { 'xtol' : 1e-8 , 'disp' : True }) Optimization terminated successfully. Current function value: -0.380860 Iterations: 76 Function evaluations: 148 res final_simplex: (array([[-0.36266707, 1.17858233], [-0.36266707, 1.17858233], [-0.36266707, 1.17858233]]), array([-0.38086004, -0.38086004, -0.38086004])) fun: -0.3808600432413275 message: 'Optimization terminated successfully.' nfev: 148 nit: 76 status: 0 success: True x: array([-0.36266707, 1.17858233]) Newton's Conjugate Gradient Method The minimum value of this function is 0 which is achieved when x =1 def rosen (x): \"\"\"The Rosenbrock function\"\"\" return sum ( 100.0 * (x[ 1 :] - x[: - 1 ] ** 2.0 ) ** 2.0 + ( 1 - x[: - 1 ]) ** 2.0 ) def rosen_der (x): xm = x[ 1 : - 1 ] xm_m1 = x[: - 2 ] xm_p1 = x[ 2 :] der = np . zeros_like(x) der[ 1 : - 1 ] = 200 * (xm - xm_m1 ** 2 ) - 400 * (xm_p1 - xm ** 2 ) * xm - 2 * ( 1 - xm) der[ 0 ] = - 400 * x[ 0 ] * (x[ 1 ] - x[ 0 ] ** 2 ) - 2 * ( 1 - x[ 0 ]) der[ - 1 ] = 200 * (x[ - 1 ] - x[ - 2 ] ** 2 ) return der def rosen_hess (x): x = np . asarray(x) H = np . diag( - 400 * x[: - 1 ], 1 ) - np . diag( 400 * x[: - 1 ], - 1 ) diagonal = np . zeros_like(x) diagonal[ 0 ] = 1200 * x[ 0 ] ** 2 - 400 * x[ 1 ] + 2 diagonal[ - 1 ] = 200 diagonal[ 1 : - 1 ] = 202 + 1200 * x[ 1 : - 1 ] ** 2 - 400 * x[ 2 :] H = H + np . diag(diagonal) return H x0 = np . array([ 1.3 , 0.7 , 0.8 , 1.9 , 1.2 ]) res = minimize(rosen, x0, method = 'Newton-CG' ,jac = rosen_der, hess = rosen_hess, options = { 'xtol' : 1e-8 , 'disp' : True }) Optimization terminated successfully. Current function value: 0.000000 Iterations: 24 Function evaluations: 33 Gradient evaluations: 56 Hessian evaluations: 24 res . x array([1. , 1. , 1. , 0.99999999, 0.99999999]) References https://andreask.cs.illinois.edu/cs357-s15/public/demos/12-optimization/Steepest%20Descent.html https://scipy-lectures.org/advanced/mathematical_optimization/auto_examples/plot_gradient_descent.html https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html https://scipy-cookbook.readthedocs.io/index.html http://folk.ntnu.no/leifh/teaching/tkt4140/._main000.html","title":"Optimization"},{"location":"optimization/intro/Optimization/#scipy-optimization-source","text":"SciPy optimize provides functions for minimizing (or maximizing) objective functions, possibly subject to constraints. It includes solvers for nonlinear problems (with support for both local and global optimization algorithms), linear programing, constrained and nonlinear least-squares, root finding and curve fitting. Scalar Functions Optimization Local (Multivariate) Optimization Global Optimization Least-squares and Curve Fitting Root finding","title":"Scipy Optimization Source"},{"location":"optimization/intro/Optimization/#gradient-descient","text":"import numpy as np import numpy.linalg as la import scipy.optimize as sopt import matplotlib.pyplot as pt from mpl_toolkits.mplot3d import axes3d % matplotlib inline import seaborn as sns sns . set() Spherical Surface : $$F(x,y) = x^{2} + y^{2}$$ def sphere (x): return x[ 0 ] ** 2 + x[ 1 ] ** 2 def df_sphere (x): return np . array([ 2.0 * x[ 0 ], 2.0 * x[ 1 ]])","title":"Gradient Descient"},{"location":"optimization/intro/Optimization/#plot-surfaces","text":"Sphere fig = pt . figure(figsize = [ 8 , 8 ]) ax = fig . gca(projection = \"3d\" ) xmesh, ymesh = np . mgrid[ - 2 : 2 : 50j , - 2 : 2 : 50j ] fmesh = sphere(np . array([xmesh, ymesh])) ax . plot_surface(xmesh, ymesh, fmesh) &lt;mpl_toolkits.mplot3d.art3d.Poly3DCollection at 0x1a18961550&gt;","title":"Plot Surfaces"},{"location":"optimization/intro/Optimization/#plot-concors","text":"pt . figure( figsize = [ 5 , 5 ]) pt . axis( \"equal\" ) pt . contour(xmesh, ymesh, fmesh, 20 ) &lt;matplotlib.contour.QuadContourSet at 0x7f0bfe84f7b8&gt;","title":"Plot Concors"},{"location":"optimization/intro/Optimization/#find-minimum","text":"guesses = [np . array([ 2 , 2 ])] for i in range ( 10000 ): x = guesses[ - 1 ] s = - df_sphere(x) alpha = 0.001 next_guess = x + alpha * s guesses . append(next_guess) guesses[ 0 : 10 ] [array([2, 2]), array([1.996, 1.996]), array([1.992008, 1.992008]), array([1.98802398, 1.98802398]), array([1.98404794, 1.98404794]), array([1.98007984, 1.98007984]), array([1.97611968, 1.97611968]), array([1.97216744, 1.97216744]), array([1.96822311, 1.96822311]), array([1.96428666, 1.96428666])] pt . figure( figsize = [ 5 , 5 ]) pt . axis( \"equal\" ) pt . contour(xmesh, ymesh, fmesh, 10 ) it_array = np . array(guesses) pt . plot(it_array . T[ 0 ], it_array . T[ 1 ], \"o\" ) [&lt;matplotlib.lines.Line2D at 0x7f0bfea38828&gt;]","title":"Find Minimum"},{"location":"optimization/intro/Optimization/#abritrary-surface-source","text":"def surface (x): return np . sin( 0.5 * x[ 0 ] ** 2 - 0.25 * x[ 1 ] ** 2 + 3 ) * np . cos( 2.0 * x[ 0 ] + 1.0 + np . exp(x[ 1 ])) def df_surface (x): u = np . sin( 0.5 * x[ 0 ] ** 2 - 0.25 * x[ 1 ] ** 2 + 3 ) u_x = np . cos( 0.5 * x[ 0 ] ** 2 - 0.25 * x[ 1 ] ** 2 + 3 ) * x[ 0 ] u_y = - np . cos( 0.5 * x[ 0 ] ** 2 - 0.25 * x[ 1 ] ** 2 + 3 ) * 0.5 * x[ 1 ] v = np . cos( 2.0 * x[ 0 ] + 1.0 + np . exp(x[ 1 ])) v_x = - np . sin( 2.0 * x[ 0 ] + 1.0 + np . exp(x[ 1 ])) * 2.0 v_y = np . sin( 2.0 * x[ 0 ] + 1.0 + np . exp(x[ 1 ])) * np . exp(x[ 1 ]) df_x = u_x * v + u * v_x df_y = u_y * v + u * v_y return np . array([df_x,df_y])","title":"Abritrary Surface source"},{"location":"optimization/intro/Optimization/#plot-surface","text":"fig = pt . figure(figsize = [ 8 , 8 ]) ax = fig . gca(projection = \"3d\" ) xmesh, ymesh = np . mgrid[ - 2 : 2 : 50j , - 2 : 2 : 50j ] fmesh = surface(np . array([xmesh, ymesh])) ax . plot_surface(xmesh, ymesh, fmesh) &lt;mpl_toolkits.mplot3d.art3d.Poly3DCollection at 0x7f0bfea68cc0&gt;","title":"Plot Surface"},{"location":"optimization/intro/Optimization/#plot-contor","text":"pt . figure( figsize = [ 5 , 5 ]) pt . axis( \"equal\" ) pt . contour(xmesh, ymesh, fmesh, 20 ) &lt;matplotlib.contour.QuadContourSet at 0x7f0bfeb2d390&gt; guesses = [np . array([ - 0.25 , 0.5 ])] for i in range ( 100000 ): x = guesses[ - 1 ] s = - df_surface(x) alpha = 0.0001 next_guess = x + alpha * s guesses . append(next_guess) guesses[ 0 : 10 ] [array([-0.25, 0.5 ]), array([-0.24995774, 0.4999897 ]), array([-0.24991547, 0.49997941]), array([-0.24987321, 0.49996911]), array([-0.24983095, 0.49995882]), array([-0.24978869, 0.49994853]), array([-0.24974643, 0.49993824]), array([-0.24970417, 0.49992795]), array([-0.24966191, 0.49991766]), array([-0.24961965, 0.49990738])] pt . figure( figsize = [ 5 , 5 ]) pt . axis( \"equal\" ) pt . contour(xmesh, ymesh, fmesh, 10 ) it_array = np . array(guesses) pt . plot(it_array . T[ 0 ], it_array . T[ 1 ], \"o\" ) [&lt;matplotlib.lines.Line2D at 0x7f0bfdcb7e80&gt;]","title":"Plot Contor"},{"location":"optimization/intro/Optimization/#scipy-optimization","text":"from scipy.optimize import minimize Sphere x0 = [np . array([ 5 , 5 ])] res = minimize(sphere, x0, method = 'nelder-mead' , options = { 'xtol' : 1e-8 , 'disp' : True }) Optimization terminated successfully. Current function value: 0.000000 Iterations: 73 Function evaluations: 137 res final_simplex: (array([[-1.53149299e-09, 3.72359970e-09], [-1.89733109e-09, -4.32207878e-09], [ 5.12426026e-09, -1.63696990e-09]]), array([1.62106655e-17, 2.22802302e-17, 2.89377136e-17])) fun: 1.6210665476880626e-17 message: 'Optimization terminated successfully.' nfev: 137 nit: 73 status: 0 success: True x: array([-1.53149299e-09, 3.72359970e-09]) Surface x0 = [np . array([ - 0.25 , 0.5 ])] res = minimize(surface, x0, method = 'nelder-mead' , options = { 'xtol' : 1e-8 , 'disp' : True }) Optimization terminated successfully. Current function value: -0.380860 Iterations: 76 Function evaluations: 148 res final_simplex: (array([[-0.36266707, 1.17858233], [-0.36266707, 1.17858233], [-0.36266707, 1.17858233]]), array([-0.38086004, -0.38086004, -0.38086004])) fun: -0.3808600432413275 message: 'Optimization terminated successfully.' nfev: 148 nit: 76 status: 0 success: True x: array([-0.36266707, 1.17858233])","title":"Scipy Optimization"},{"location":"optimization/intro/Optimization/#newtons-conjugate-gradient-method","text":"The minimum value of this function is 0 which is achieved when x =1 def rosen (x): \"\"\"The Rosenbrock function\"\"\" return sum ( 100.0 * (x[ 1 :] - x[: - 1 ] ** 2.0 ) ** 2.0 + ( 1 - x[: - 1 ]) ** 2.0 ) def rosen_der (x): xm = x[ 1 : - 1 ] xm_m1 = x[: - 2 ] xm_p1 = x[ 2 :] der = np . zeros_like(x) der[ 1 : - 1 ] = 200 * (xm - xm_m1 ** 2 ) - 400 * (xm_p1 - xm ** 2 ) * xm - 2 * ( 1 - xm) der[ 0 ] = - 400 * x[ 0 ] * (x[ 1 ] - x[ 0 ] ** 2 ) - 2 * ( 1 - x[ 0 ]) der[ - 1 ] = 200 * (x[ - 1 ] - x[ - 2 ] ** 2 ) return der def rosen_hess (x): x = np . asarray(x) H = np . diag( - 400 * x[: - 1 ], 1 ) - np . diag( 400 * x[: - 1 ], - 1 ) diagonal = np . zeros_like(x) diagonal[ 0 ] = 1200 * x[ 0 ] ** 2 - 400 * x[ 1 ] + 2 diagonal[ - 1 ] = 200 diagonal[ 1 : - 1 ] = 202 + 1200 * x[ 1 : - 1 ] ** 2 - 400 * x[ 2 :] H = H + np . diag(diagonal) return H x0 = np . array([ 1.3 , 0.7 , 0.8 , 1.9 , 1.2 ]) res = minimize(rosen, x0, method = 'Newton-CG' ,jac = rosen_der, hess = rosen_hess, options = { 'xtol' : 1e-8 , 'disp' : True }) Optimization terminated successfully. Current function value: 0.000000 Iterations: 24 Function evaluations: 33 Gradient evaluations: 56 Hessian evaluations: 24 res . x array([1. , 1. , 1. , 0.99999999, 0.99999999])","title":"Newton's Conjugate Gradient Method"},{"location":"optimization/intro/Optimization/#references","text":"https://andreask.cs.illinois.edu/cs357-s15/public/demos/12-optimization/Steepest%20Descent.html https://scipy-lectures.org/advanced/mathematical_optimization/auto_examples/plot_gradient_descent.html https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html https://scipy-cookbook.readthedocs.io/index.html http://folk.ntnu.no/leifh/teaching/tkt4140/._main000.html","title":"References"}]}